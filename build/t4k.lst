   1              	@ a4.s   - arm forth
   2              	@ ------------------------------------------------------------------------
   3              	
   4              	  .thumb
   5              	  .syntax unified
   6              	
   7              	@ ------------------------------------------------------------------------
   8              	
   9              	ver     = 0x0001
  10              	
  11              	MEMSZ   = 0x100000          @ memory size of process
  12              	STKSZ   = 0x1000            @ size of return stack buffer
  13              	FLDSZ   = 36 * 5            @ fload stack size
  14              	TIBSZ   = 0x400             @ terminal input buffer size
  15              	
  16              	@ ------------------------------------------------------------------------
  17              	@ load macros to create word headers in own section etc
  18              	
  19              	  .include "macros.s"       @ this is where the magic happens
   1              	@ macros.s
   2              	@ ------------------------------------------------------------------------
   3              	@ return stack pointer is r12
   4              	
   5              	  rp .req r12
   6              	
   7              	@ ------------------------------------------------------------------------
   8              	
   9              	  .set lex,        0        @ marks next word as immediate, alias etc
  10              	  .set _thread,    0        @ link to previous word in current vocabulary
  11              	
  12              	  .set forth_link, 0        @ link to previous word in each vocabulary
  13              	  .set comp_link,  0        @ these are only set when some other
  14              	  .set root_link,  0        @ vocabulary is current
  15              	
  16              	  .set _voclink,   0        @ assembly voc linkage
  17              	
  18              	@ ------------------------------------------------------------------------
  19              	@ vocabulary ids
  20              	
  21              	  .set FORTH,    1
  22              	  .set COMPILER, 2
  23              	  .set ROOT,     3
  24              	
  25              	@ ------------------------------------------------------------------------
  26              	
  27              	  LEXMASK   = 0x3f          @ mask for nfa count byte
  28              	  IMM       = 0x80          @ marks nfa count byte: word as immediate
  29              	  ALIAS     = 0x40          @ marks nfa count byte: word is an alias
  30              	  BODY      = 8             @ distance from cfa to body = 2 opcodes
  31              	
  32              	@ ------------------------------------------------------------------------
  33              	@ make next assembled word an immediate word
  34              	
  35              	.macro _imm_
  36              	  .set lex, IMM
  37              	.endm
  38              	
  39              	@ ------------------------------------------------------------------------
  40              	@ macros to push and pop from both stacks
  41              	
  42              	.macro rpush reg
  43              	  str \reg, [rp, #-4]!
  44              	.endm
  45              	
  46              	.macro rpop reg
  47              	  ldr \reg, [rp], #4
  48              	.endm
  49              	
  50              	@ ------------------------------------------------------------------------
  51              	@ return from coded definition, execute next token from high level def
  52              	
  53              	.macro next
  54              	  bx lr
  55              	.endm
  56              	
  57              	@ ------------------------------------------------------------------------
  58              	@ return from high level definition
  59              	
  60              	.macro exit
  61              	  rpop pc
  62              	.endm
  63              	
  64              	@ ------------------------------------------------------------------------
  65              	@ assemble a counted string (nfa of word etc)
  66              	
  67              	.macro hstring name
  68              	  .byte lex + 9f-(.+1)      @ compile length byte plus lex bits
  69              	  .ascii "\name"            @ compile string
  70              	9:
  71              	  .balign 4, 0              @ end of streaing must be word aligned
  72              	.endm
  73              	
  74              	@ ------------------------------------------------------------------------
  75              	@ make new header but dont assemble anything to cfa
  76              	
  77              	.macro _header_ name, cfa
  78              	  .section .data            @ assemble into head space
  79              	  .int _thread
  80              	  .set _thread, .
  81              	8:                          @ address to link next word header against
  82              	  hstring "\name"
  83              	  .set lex, 0
  84              	  .int \cfa                 @ point header at new words cfa
  85              	  .previous                 @ assemble into list space
  86              	.endm
  87              	
  88              	@ ------------------------------------------------------------------------
  89              	@ assemble a new word header, set cfa -4 = pointer to nfa
  90              	
  91              	.macro header name, cfa
  92              	  _header_ "\name", \cfa
  93              	  .balign 4, 0              @ make sure cfa aligned so body data will be
  94              	  .int _thread              @ cfa -4 points to nfa
  95              	.endm
  96              	
  97              	@ ------------------------------------------------------------------------
  98              	@ create a second header for an already existing word
  99              	
 100              	.macro _alias_ name, cfa, label
 101              	  .set lex, ALIAS
 102              	  _header_ "\name", \cfa
 103              	  .set \label, \cfa
 104              	.endm
 105              	
 106              	@ ------------------------------------------------------------------------
 107              	@ assemble a coded definition
 108              	
 109              	.macro code name, cfa
 110              	  header "\name", \cfa
 111              	\cfa:
 112              	.endm
 113              	
 114              	@ ------------------------------------------------------------------------
 115              	@ assemble a colon definition
 116              	
 117              	.macro colon name, cfa
 118              	  header "\name", \cfa
 119              	\cfa:
 120              	  nop.w                     @ nest
 121              	  rpush lr                  @ save current ip to return stack
 122              	.endm
 123              	
 124              	@ ------------------------------------------------------------------------
 125              	@ assemble a constant
 126              	
 127              	.macro _constant_ name, cfa, value
 128              	  header "\name", \cfa
 129              	\cfa:
 130              	  rpush lr
 131              	  bl dovar
 132              	  .int \value
 133              	.endm
 134              	
 135              	@ ------------------------------------------------------------------------
 136              	@ assemble a variable
 137              	
 138              	.macro _variable_ name, cfa, value
 139              	  header "\name", \cfa
 140              	\cfa:
 141              	  rpush lr
 142              	  bl dovariable
 143              	  .int \value
 144              	.endm
 145              	
 146              	@ ------------------------------------------------------------------------
 147              	
 148              	.macro _var_ name, cfa, value
 149              	  header "\name", \cfa
 150              	\cfa:
 151              	  rpush lr
 152              	  bl dovar
 153              	  .int \value
 154              	.endm
 155              	
 156              	@ ------------------------------------------------------------------------
 157              	@ assemble a deferred word
 158              	
 159              	.macro _defer_ name, cfa, value
 160              	  header "\name", \cfa
 161              	\cfa:
 162              	  rpush lr
 163              	  bl dodefer
 164              	  .int \value
 165              	.endm
 166              	
 167              	@ ------------------------------------------------------------------------
 168              	@ assebmel a system call
 169              	
 170              	.macro _syscall_ name, cfa, sysnum, pcount
 171              	  header "\name", \cfa
 172              	\cfa:
 173              	  rpush lr
 174              	  bl do_syscall
 175              	  .hword \sysnum            @ syscall number
 176              	  .hword \pcount            @ parameter count
 177              	.endm
 178              	
 179              	@ ------------------------------------------------------------------------
 180              	
 181              	.macro _vocab_ name, cfa, thread
 182              	  header "\name", \cfa
 183              	\cfa:
 184              	  rpush lr
 185              	  bl dovoc
 186              	  .int \thread
 187              	  .fill 63, 4, 0
 188              	  .int _voclink
 189              	  .set _voclink, \cfa
 190              	.endm
 191              	
 192              	@ ------------------------------------------------------------------------
 193              	
 194              	.macro literal n1
 195              	  push { r0 }
 196              	  movw r0, #:lower16:\n1
 197              	  movt r0, #:upper16:\n1
 198              	.endm
 199              	
 200              	@ ------------------------------------------------------------------------
 201              	
 202              	.macro wliteral n1
 203              	  push { r0 }
 204              	  movw r0, #\n1
 205              	.endm
 206              	
 207              	@ ------------------------------------------------------------------------
 208              	
 209              	.macro cliteral n1
 210              	  push { r0 }
 211              	  movs r0, #\n1
 212              	.endm
 213              	
 214              	@ ------------------------------------------------------------------------
 215              	
 216              	.macro _forth_
 217              	  .if voc != forth
 218              	  .if voc == compiler       @ if vocabulary currently set to compiler
 219              	    .set comp_link, _thread   @ save compilers voc link
 220              	  .endif
 221              	
 222              	  .if voc == root           @ if vocabulary currently set to root
 223              	    .set root_link, _thread   @ save roots voc link
 224              	  .endif
 225              	
 226              	  .set voc, forth
 227              	  .set _thread, forth_link
 228              	  .endif
 229              	.endm
 230              	
 231              	@ ------------------------------------------------------------------------
 232              	
 233              	.macro _compiler_
 234              	  .if voc != compiler
 235              	  .if voc == forth          @ if vocabulary currently set to forth
 236              	    .set forth_link, _thread  @ save forths voc link
 237              	  .endif
 238              	
 239              	  .if voc == root           @ if vocabulary currently set to root
 240              	    .set root_link, _thread   @ save roots voc link
 241              	  .endif
 242              	
 243              	  .set voc, compiler
 244              	  .set _thread, comp_link
 245              	  .endif
 246              	.endm
 247              	
 248              	@ ------------------------------------------------------------------------
 249              	
 250              	.macro _root_
 251              	  .if voc != root
 252              	  .if voc == forth          @ if vocabulary currently set to forth
 253              	    .set forth_link, _thread  @ save forths voc link
 254              	  .endif
 255              	
 256              	  .if voc == compiler       @ if vocabulary currently set to compiler
 257              	    .set comp_link, _thread   @ save compilers voc link
 258              	  .endif
 259              	
 260              	  .set voc, root
 261              	  .set _thread, root_link
 262              	  .endif
 263              	.endm
 264              	
 265              	@ ========================================================================
  20              	
  21              	@ ------------------------------------------------------------------------
  22              	@ red tape
  23              	
  24              	  .section .text
  25              	  .global origin            @ none of that _________start stuff here :)
  26              	
  27              	@ ------------------------------------------------------------------------
  28              	@ entry point to process must be a arm opcode
  29              	
  30              	.arm                        @ process entry point must be in ARM mode
  31              	origin:                     @ address of start of process code space
  32 0000 B20000FA 	  blx start                 @ this switches us to thumb mode
  33              	.thumb
  34              	
  35              	@ ------------------------------------------------------------------------
  36              	
  37              	  _forth_                   @ put words in the forth vocabulary
  37              	>  .if voc!=forth
  37              	>  .if voc==compiler
  37              	>  .set comp_link,_thread
  37              	>  .endif
  37              	> 
  37              	>  .if voc==root
  37              	>  .set root_link,_thread
  37              	>  .endif
  37              	> 
  37              	>  .set voc,forth
  37              	>  .set _thread,forth_link
  37              	>  .endif
  38              	
  39              	  _constant_ "origin",     org, origin
  39              	>  header "origin",org
  39              	>>  _header_ "origin",org
  39              	>>>  .section .data
  39 0000 00000000 	>>>  .int _thread
  39              	>>>  .set _thread,.
  39              	>>> 8:
  39              	>>>  hstring "origin"
  39 0004 06       	>>>>  .byte lex+9f-(.+1)
  39 0005 6F726967 	>>>>  .ascii "origin"
  39      696E
  39              	>>>> 9:
  39 000b 00       	>>>>  .balign 4,0
  39              	>>>  .set lex,0
  39 000c 08000000 	>>>  .int org
  39              	>>>  .previous
  39              	>>  .balign 4,0
  39 0004 04000000 	>>  .int _thread
  39              	> org:
  39              	>  rpush lr
  39 0008 4CF804ED 	>>  str lr,[rp,#-4]!
  39 000c 00F0B4F9 	>  bl dovar
  39 0010 00000000 	>  .int origin
  40              	  _constant_ "version",    version, ver
  40              	>  header "version",version
  40              	>>  _header_ "version",version
  40              	>>>  .section .data
  40 0010 04000000 	>>>  .int _thread
  40              	>>>  .set _thread,.
  40              	>>> 8:
  40              	>>>  hstring "version"
  40 0014 07       	>>>>  .byte lex+9f-(.+1)
  40 0015 76657273 	>>>>  .ascii "version"
  40      696F6E
  40              	>>>> 9:
  40              	>>>>  .balign 4,0
  40              	>>>  .set lex,0
  40 001c 18000000 	>>>  .int version
  40              	>>>  .previous
  40              	>>  .balign 4,0
  40 0014 14000000 	>>  .int _thread
  40              	> version:
  40              	>  rpush lr
  40 0018 4CF804ED 	>>  str lr,[rp,#-4]!
  40 001c 00F0ACF9 	>  bl dovar
  40 0020 01000000 	>  .int ver
  41              	  _constant_ "thead",      thead, 0
  41              	>  header "thead",thead
  41              	>>  _header_ "thead",thead
  41              	>>>  .section .data
  41 0020 14000000 	>>>  .int _thread
  41              	>>>  .set _thread,.
  41              	>>> 8:
  41              	>>>  hstring "thead"
  41 0024 05       	>>>>  .byte lex+9f-(.+1)
  41 0025 74686561 	>>>>  .ascii "thead"
  41      64
  41              	>>>> 9:
  41 002a 0000     	>>>>  .balign 4,0
  41              	>>>  .set lex,0
  41 002c 28000000 	>>>  .int thead
  41              	>>>  .previous
  41              	>>  .balign 4,0
  41 0024 24000000 	>>  .int _thread
  41              	> thead:
  41              	>  rpush lr
  41 0028 4CF804ED 	>>  str lr,[rp,#-4]!
  41 002c 00F0A4F9 	>  bl dovar
  41 0030 00000000 	>  .int 0
  42              	  _constant_ "head0",      bhead, 0
  42              	>  header "head0",bhead
  42              	>>  _header_ "head0",bhead
  42              	>>>  .section .data
  42 0030 24000000 	>>>  .int _thread
  42              	>>>  .set _thread,.
  42              	>>> 8:
  42              	>>>  hstring "head0"
  42 0034 05       	>>>>  .byte lex+9f-(.+1)
  42 0035 68656164 	>>>>  .ascii "head0"
  42      30
  42              	>>>> 9:
  42 003a 0000     	>>>>  .balign 4,0
  42              	>>>  .set lex,0
  42 003c 38000000 	>>>  .int bhead
  42              	>>>  .previous
  42              	>>  .balign 4,0
  42 0034 34000000 	>>  .int _thread
  42              	> bhead:
  42              	>  rpush lr
  42 0038 4CF804ED 	>>  str lr,[rp,#-4]!
  42 003c 00F09CF9 	>  bl dovar
  42 0040 00000000 	>  .int 0
  43              	
  44              	  _constant_ "arg0",       arg0, 0
  44              	>  header "arg0",arg0
  44              	>>  _header_ "arg0",arg0
  44              	>>>  .section .data
  44 0040 34000000 	>>>  .int _thread
  44              	>>>  .set _thread,.
  44              	>>> 8:
  44              	>>>  hstring "arg0"
  44 0044 04       	>>>>  .byte lex+9f-(.+1)
  44 0045 61726730 	>>>>  .ascii "arg0"
  44              	>>>> 9:
  44 0049 000000   	>>>>  .balign 4,0
  44              	>>>  .set lex,0
  44 004c 48000000 	>>>  .int arg0
  44              	>>>  .previous
  44              	>>  .balign 4,0
  44 0044 44000000 	>>  .int _thread
  44              	> arg0:
  44              	>  rpush lr
  44 0048 4CF804ED 	>>  str lr,[rp,#-4]!
  44 004c 00F094F9 	>  bl dovar
  44 0050 00000000 	>  .int 0
  45              	  _constant_ "argc",       argc, 0
  45              	>  header "argc",argc
  45              	>>  _header_ "argc",argc
  45              	>>>  .section .data
  45 0050 44000000 	>>>  .int _thread
  45              	>>>  .set _thread,.
  45              	>>> 8:
  45              	>>>  hstring "argc"
  45 0054 04       	>>>>  .byte lex+9f-(.+1)
  45 0055 61726763 	>>>>  .ascii "argc"
  45              	>>>> 9:
  45 0059 000000   	>>>>  .balign 4,0
  45              	>>>  .set lex,0
  45 005c 58000000 	>>>  .int argc
  45              	>>>  .previous
  45              	>>  .balign 4,0
  45 0054 54000000 	>>  .int _thread
  45              	> argc:
  45              	>  rpush lr
  45 0058 4CF804ED 	>>  str lr,[rp,#-4]!
  45 005c 00F08CF9 	>  bl dovar
  45 0060 00000000 	>  .int 0
  46              	  _constant_ "argv",       argv, 0
  46              	>  header "argv",argv
  46              	>>  _header_ "argv",argv
  46              	>>>  .section .data
  46 0060 54000000 	>>>  .int _thread
  46              	>>>  .set _thread,.
  46              	>>> 8:
  46              	>>>  hstring "argv"
  46 0064 04       	>>>>  .byte lex+9f-(.+1)
  46 0065 61726776 	>>>>  .ascii "argv"
  46              	>>>> 9:
  46 0069 000000   	>>>>  .balign 4,0
  46              	>>>  .set lex,0
  46 006c 68000000 	>>>  .int argv
  46              	>>>  .previous
  46              	>>  .balign 4,0
  46 0064 64000000 	>>  .int _thread
  46              	> argv:
  46              	>  rpush lr
  46 0068 4CF804ED 	>>  str lr,[rp,#-4]!
  46 006c 00F084F9 	>  bl dovar
  46 0070 00000000 	>  .int 0
  47              	  _constant_ "envp",       envp, 0
  47              	>  header "envp",envp
  47              	>>  _header_ "envp",envp
  47              	>>>  .section .data
  47 0070 64000000 	>>>  .int _thread
  47              	>>>  .set _thread,.
  47              	>>> 8:
  47              	>>>  hstring "envp"
  47 0074 04       	>>>>  .byte lex+9f-(.+1)
  47 0075 656E7670 	>>>>  .ascii "envp"
  47              	>>>> 9:
  47 0079 000000   	>>>>  .balign 4,0
  47              	>>>  .set lex,0
  47 007c 78000000 	>>>  .int envp
  47              	>>>  .previous
  47              	>>  .balign 4,0
  47 0074 74000000 	>>  .int _thread
  47              	> envp:
  47              	>  rpush lr
  47 0078 4CF804ED 	>>  str lr,[rp,#-4]!
  47 007c 00F07CF9 	>  bl dovar
  47 0080 00000000 	>  .int 0
  48              	  _constant_ "auxp",       auxp, 0
  48              	>  header "auxp",auxp
  48              	>>  _header_ "auxp",auxp
  48              	>>>  .section .data
  48 0080 74000000 	>>>  .int _thread
  48              	>>>  .set _thread,.
  48              	>>> 8:
  48              	>>>  hstring "auxp"
  48 0084 04       	>>>>  .byte lex+9f-(.+1)
  48 0085 61757870 	>>>>  .ascii "auxp"
  48              	>>>> 9:
  48 0089 000000   	>>>>  .balign 4,0
  48              	>>>  .set lex,0
  48 008c 88000000 	>>>  .int auxp
  48              	>>>  .previous
  48              	>>  .balign 4,0
  48 0084 84000000 	>>  .int _thread
  48              	> auxp:
  48              	>  rpush lr
  48 0088 4CF804ED 	>>  str lr,[rp,#-4]!
  48 008c 00F074F9 	>  bl dovar
  48 0090 00000000 	>  .int 0
  49              	
  50              	  _constant_ "shebang",    shebang, 0
  50              	>  header "shebang",shebang
  50              	>>  _header_ "shebang",shebang
  50              	>>>  .section .data
  50 0090 84000000 	>>>  .int _thread
  50              	>>>  .set _thread,.
  50              	>>> 8:
  50              	>>>  hstring "shebang"
  50 0094 07       	>>>>  .byte lex+9f-(.+1)
  50 0095 73686562 	>>>>  .ascii "shebang"
  50      616E67
  50              	>>>> 9:
  50              	>>>>  .balign 4,0
  50              	>>>  .set lex,0
  50 009c 98000000 	>>>  .int shebang
  50              	>>>  .previous
  50              	>>  .balign 4,0
  50 0094 94000000 	>>  .int _thread
  50              	> shebang:
  50              	>  rpush lr
  50 0098 4CF804ED 	>>  str lr,[rp,#-4]!
  50 009c 00F06CF9 	>  bl dovar
  50 00a0 00000000 	>  .int 0
  51              	  _constant_ "intty",      intty,0
  51              	>  header "intty",intty
  51              	>>  _header_ "intty",intty
  51              	>>>  .section .data
  51 00a0 94000000 	>>>  .int _thread
  51              	>>>  .set _thread,.
  51              	>>> 8:
  51              	>>>  hstring "intty"
  51 00a4 05       	>>>>  .byte lex+9f-(.+1)
  51 00a5 696E7474 	>>>>  .ascii "intty"
  51      79
  51              	>>>> 9:
  51 00aa 0000     	>>>>  .balign 4,0
  51              	>>>  .set lex,0
  51 00ac A8000000 	>>>  .int intty
  51              	>>>  .previous
  51              	>>  .balign 4,0
  51 00a4 A4000000 	>>  .int _thread
  51              	> intty:
  51              	>  rpush lr
  51 00a8 4CF804ED 	>>  str lr,[rp,#-4]!
  51 00ac 00F064F9 	>  bl dovar
  51 00b0 00000000 	>  .int 0
  52              	  _constant_ "outtty",     outtty, 0
  52              	>  header "outtty",outtty
  52              	>>  _header_ "outtty",outtty
  52              	>>>  .section .data
  52 00b0 A4000000 	>>>  .int _thread
  52              	>>>  .set _thread,.
  52              	>>> 8:
  52              	>>>  hstring "outtty"
  52 00b4 06       	>>>>  .byte lex+9f-(.+1)
  52 00b5 6F757474 	>>>>  .ascii "outtty"
  52      7479
  52              	>>>> 9:
  52 00bb 00       	>>>>  .balign 4,0
  52              	>>>  .set lex,0
  52 00bc B8000000 	>>>  .int outtty
  52              	>>>  .previous
  52              	>>  .balign 4,0
  52 00b4 B4000000 	>>  .int _thread
  52              	> outtty:
  52              	>  rpush lr
  52 00b8 4CF804ED 	>>  str lr,[rp,#-4]!
  52 00bc 00F05CF9 	>  bl dovar
  52 00c0 00000000 	>  .int 0
  53              	  _constant_ "turnkeyd",   turnkeyd, 0
  53              	>  header "turnkeyd",turnkeyd
  53              	>>  _header_ "turnkeyd",turnkeyd
  53              	>>>  .section .data
  53 00c0 B4000000 	>>>  .int _thread
  53              	>>>  .set _thread,.
  53              	>>> 8:
  53              	>>>  hstring "turnkeyd"
  53 00c4 08       	>>>>  .byte lex+9f-(.+1)
  53 00c5 7475726E 	>>>>  .ascii "turnkeyd"
  53      6B657964 
  53              	>>>> 9:
  53 00cd 000000   	>>>>  .balign 4,0
  53              	>>>  .set lex,0
  53 00d0 C8000000 	>>>  .int turnkeyd
  53              	>>>  .previous
  53              	>>  .balign 4,0
  53 00c4 C4000000 	>>  .int _thread
  53              	> turnkeyd:
  53              	>  rpush lr
  53 00c8 4CF804ED 	>>  str lr,[rp,#-4]!
  53 00cc 00F054F9 	>  bl dovar
  53 00d0 00000000 	>  .int 0
  54              	
  55              	  _var_      "?tty",       qtty, 0
  55              	>  header "?tty",qtty
  55              	>>  _header_ "?tty",qtty
  55              	>>>  .section .data
  55 00d4 C4000000 	>>>  .int _thread
  55              	>>>  .set _thread,.
  55              	>>> 8:
  55              	>>>  hstring "?tty"
  55 00d8 04       	>>>>  .byte lex+9f-(.+1)
  55 00d9 3F747479 	>>>>  .ascii "?tty"
  55              	>>>> 9:
  55 00dd 000000   	>>>>  .balign 4,0
  55              	>>>  .set lex,0
  55 00e0 D8000000 	>>>  .int qtty
  55              	>>>  .previous
  55              	>>  .balign 4,0
  55 00d4 D8000000 	>>  .int _thread
  55              	> qtty:
  55              	>  rpush lr
  55 00d8 4CF804ED 	>>  str lr,[rp,#-4]!
  55 00dc 00F04CF9 	>  bl dovar
  55 00e0 00000000 	>  .int 0
  56              	
  57              	  _var_      "lsp",        lsp, 0
  57              	>  header "lsp",lsp
  57              	>>  _header_ "lsp",lsp
  57              	>>>  .section .data
  57 00e4 D8000000 	>>>  .int _thread
  57              	>>>  .set _thread,.
  57              	>>> 8:
  57              	>>>  hstring "lsp"
  57 00e8 03       	>>>>  .byte lex+9f-(.+1)
  57 00e9 6C7370   	>>>>  .ascii "lsp"
  57              	>>>> 9:
  57              	>>>>  .balign 4,0
  57              	>>>  .set lex,0
  57 00ec E8000000 	>>>  .int lsp
  57              	>>>  .previous
  57              	>>  .balign 4,0
  57 00e4 E8000000 	>>  .int _thread
  57              	> lsp:
  57              	>  rpush lr
  57 00e8 4CF804ED 	>>  str lr,[rp,#-4]!
  57 00ec 00F044F9 	>  bl dovar
  57 00f0 00000000 	>  .int 0
  58              	
  59              	  _var_      "heap-prot",  heap_prot, 7
  59              	>  header "heap-prot",heap_prot
  59              	>>  _header_ "heap-prot",heap_prot
  59              	>>>  .section .data
  59 00f0 E8000000 	>>>  .int _thread
  59              	>>>  .set _thread,.
  59              	>>> 8:
  59              	>>>  hstring "heap-prot"
  59 00f4 09       	>>>>  .byte lex+9f-(.+1)
  59 00f5 68656170 	>>>>  .ascii "heap-prot"
  59      2D70726F 
  59      74
  59              	>>>> 9:
  59 00fe 0000     	>>>>  .balign 4,0
  59              	>>>  .set lex,0
  59 0100 F8000000 	>>>  .int heap_prot
  59              	>>>  .previous
  59              	>>  .balign 4,0
  59 00f4 F4000000 	>>  .int _thread
  59              	> heap_prot:
  59              	>  rpush lr
  59 00f8 4CF804ED 	>>  str lr,[rp,#-4]!
  59 00fc 00F03CF9 	>  bl dovar
  59 0100 07000000 	>  .int 7
  60              	  _var_      "heap-flags", heap_flg, 0x22
  60              	>  header "heap-flags",heap_flg
  60              	>>  _header_ "heap-flags",heap_flg
  60              	>>>  .section .data
  60 0104 F4000000 	>>>  .int _thread
  60              	>>>  .set _thread,.
  60              	>>> 8:
  60              	>>>  hstring "heap-flags"
  60 0108 0A       	>>>>  .byte lex+9f-(.+1)
  60 0109 68656170 	>>>>  .ascii "heap-flags"
  60      2D666C61 
  60      6773
  60              	>>>> 9:
  60 0113 00       	>>>>  .balign 4,0
  60              	>>>  .set lex,0
  60 0114 08010000 	>>>  .int heap_flg
  60              	>>>  .previous
  60              	>>  .balign 4,0
  60 0104 08010000 	>>  .int _thread
  60              	> heap_flg:
  60              	>  rpush lr
  60 0108 4CF804ED 	>>  str lr,[rp,#-4]!
  60 010c 00F034F9 	>  bl dovar
  60 0110 22000000 	>  .int 0x22
  61              	
  62              	@ ------------------------------------------------------------------------
  63              	@ extreme magic hackery
  64              	
  65              	  _defer_    "rehash",     rehash, _rehash
  65              	>  header "rehash",rehash
  65              	>>  _header_ "rehash",rehash
  65              	>>>  .section .data
  65 0118 08010000 	>>>  .int _thread
  65              	>>>  .set _thread,.
  65              	>>> 8:
  65              	>>>  hstring "rehash"
  65 011c 06       	>>>>  .byte lex+9f-(.+1)
  65 011d 72656861 	>>>>  .ascii "rehash"
  65      7368
  65              	>>>> 9:
  65 0123 00       	>>>>  .balign 4,0
  65              	>>>  .set lex,0
  65 0124 18010000 	>>>  .int rehash
  65              	>>>  .previous
  65              	>>  .balign 4,0
  65 0114 1C010000 	>>  .int _thread
  65              	> rehash:
  65              	>  rpush lr
  65 0118 4CF804ED 	>>  str lr,[rp,#-4]!
  65 011c 00F022F9 	>  bl dodefer
  65 0120 22280000 	>  .int _rehash
  66              	  _defer_    "unpack",     unpack, kunpack
  66              	>  header "unpack",unpack
  66              	>>  _header_ "unpack",unpack
  66              	>>>  .section .data
  66 0128 1C010000 	>>>  .int _thread
  66              	>>>  .set _thread,.
  66              	>>> 8:
  66              	>>>  hstring "unpack"
  66 012c 06       	>>>>  .byte lex+9f-(.+1)
  66 012d 756E7061 	>>>>  .ascii "unpack"
  66      636B
  66              	>>>> 9:
  66 0133 00       	>>>>  .balign 4,0
  66              	>>>  .set lex,0
  66 0134 28010000 	>>>  .int unpack
  66              	>>>  .previous
  66              	>>  .balign 4,0
  66 0124 2C010000 	>>  .int _thread
  66              	> unpack:
  66              	>  rpush lr
  66 0128 4CF804ED 	>>  str lr,[rp,#-4]!
  66 012c 00F01AF9 	>  bl dodefer
  66 0130 E2260000 	>  .int kunpack
  67              	
  68              	@ ------------------------------------------------------------------------
  69              	@ prioritized initialization chains
  70              	
  71              	  _defer_    "pdefault",   pdefault, noop
  71              	>  header "pdefault",pdefault
  71              	>>  _header_ "pdefault",pdefault
  71              	>>>  .section .data
  71 0138 2C010000 	>>>  .int _thread
  71              	>>>  .set _thread,.
  71              	>>> 8:
  71              	>>>  hstring "pdefault"
  71 013c 08       	>>>>  .byte lex+9f-(.+1)
  71 013d 70646566 	>>>>  .ascii "pdefault"
  71      61756C74 
  71              	>>>> 9:
  71 0145 000000   	>>>>  .balign 4,0
  71              	>>>  .set lex,0
  71 0148 38010000 	>>>  .int pdefault
  71              	>>>  .previous
  71              	>>  .balign 4,0
  71 0134 3C010000 	>>  .int _thread
  71              	> pdefault:
  71              	>  rpush lr
  71 0138 4CF804ED 	>>  str lr,[rp,#-4]!
  71 013c 00F012F9 	>  bl dodefer
  71 0140 28030000 	>  .int noop
  72              	  _defer_    "default",    default, noop
  72              	>  header "default",default
  72              	>>  _header_ "default",default
  72              	>>>  .section .data
  72 014c 3C010000 	>>>  .int _thread
  72              	>>>  .set _thread,.
  72              	>>> 8:
  72              	>>>  hstring "default"
  72 0150 07       	>>>>  .byte lex+9f-(.+1)
  72 0151 64656661 	>>>>  .ascii "default"
  72      756C74
  72              	>>>> 9:
  72              	>>>>  .balign 4,0
  72              	>>>  .set lex,0
  72 0158 48010000 	>>>  .int default
  72              	>>>  .previous
  72              	>>  .balign 4,0
  72 0144 50010000 	>>  .int _thread
  72              	> default:
  72              	>  rpush lr
  72 0148 4CF804ED 	>>  str lr,[rp,#-4]!
  72 014c 00F00AF9 	>  bl dodefer
  72 0150 28030000 	>  .int noop
  73              	  _defer_    "ldefault",   ldefault, noop
  73              	>  header "ldefault",ldefault
  73              	>>  _header_ "ldefault",ldefault
  73              	>>>  .section .data
  73 015c 50010000 	>>>  .int _thread
  73              	>>>  .set _thread,.
  73              	>>> 8:
  73              	>>>  hstring "ldefault"
  73 0160 08       	>>>>  .byte lex+9f-(.+1)
  73 0161 6C646566 	>>>>  .ascii "ldefault"
  73      61756C74 
  73              	>>>> 9:
  73 0169 000000   	>>>>  .balign 4,0
  73              	>>>  .set lex,0
  73 016c 58010000 	>>>  .int ldefault
  73              	>>>  .previous
  73              	>>  .balign 4,0
  73 0154 60010000 	>>  .int _thread
  73              	> ldefault:
  73              	>  rpush lr
  73 0158 4CF804ED 	>>  str lr,[rp,#-4]!
  73 015c 00F002F9 	>  bl dodefer
  73 0160 28030000 	>  .int noop
  74              	
  75              	@ ------------------------------------------------------------------------
  76              	@ cleanup prior to exit back to system
  77              	
  78              	  _defer_    "atexit",     atexit, noop
  78              	>  header "atexit",atexit
  78              	>>  _header_ "atexit",atexit
  78              	>>>  .section .data
  78 0170 60010000 	>>>  .int _thread
  78              	>>>  .set _thread,.
  78              	>>> 8:
  78              	>>>  hstring "atexit"
  78 0174 06       	>>>>  .byte lex+9f-(.+1)
  78 0175 61746578 	>>>>  .ascii "atexit"
  78      6974
  78              	>>>> 9:
  78 017b 00       	>>>>  .balign 4,0
  78              	>>>  .set lex,0
  78 017c 68010000 	>>>  .int atexit
  78              	>>>  .previous
  78              	>>  .balign 4,0
  78 0164 74010000 	>>  .int _thread
  78              	> atexit:
  78              	>  rpush lr
  78 0168 4CF804ED 	>>  str lr,[rp,#-4]!
  78 016c 00F0FAF8 	>  bl dodefer
  78 0170 28030000 	>  .int noop
  79              	
  80              	@ ------------------------------------------------------------------------
  81              	@ useful debug words (defined in an extension)
  82              	
  83              	  _defer_    ".s",         dots, noop
  83              	>  header ".s",dots
  83              	>>  _header_ ".s",dots
  83              	>>>  .section .data
  83 0180 74010000 	>>>  .int _thread
  83              	>>>  .set _thread,.
  83              	>>> 8:
  83              	>>>  hstring ".s"
  83 0184 02       	>>>>  .byte lex+9f-(.+1)
  83 0185 2E73     	>>>>  .ascii ".s"
  83              	>>>> 9:
  83 0187 00       	>>>>  .balign 4,0
  83              	>>>  .set lex,0
  83 0188 78010000 	>>>  .int dots
  83              	>>>  .previous
  83              	>>  .balign 4,0
  83 0174 84010000 	>>  .int _thread
  83              	> dots:
  83              	>  rpush lr
  83 0178 4CF804ED 	>>  str lr,[rp,#-4]!
  83 017c 00F0F2F8 	>  bl dodefer
  83 0180 28030000 	>  .int noop
  84              	  _defer_    ".us",        udots, noop
  84              	>  header ".us",udots
  84              	>>  _header_ ".us",udots
  84              	>>>  .section .data
  84 018c 84010000 	>>>  .int _thread
  84              	>>>  .set _thread,.
  84              	>>> 8:
  84              	>>>  hstring ".us"
  84 0190 03       	>>>>  .byte lex+9f-(.+1)
  84 0191 2E7573   	>>>>  .ascii ".us"
  84              	>>>> 9:
  84              	>>>>  .balign 4,0
  84              	>>>  .set lex,0
  84 0194 88010000 	>>>  .int udots
  84              	>>>  .previous
  84              	>>  .balign 4,0
  84 0184 90010000 	>>  .int _thread
  84              	> udots:
  84              	>  rpush lr
  84 0188 4CF804ED 	>>  str lr,[rp,#-4]!
  84 018c 00F0EAF8 	>  bl dodefer
  84 0190 28030000 	>  .int noop
  85              	
  86              	@ ------------------------------------------------------------------------
  87              	@ check specified descriptor for being a controlling terminal
  88              	
  89              	_chktty:                    @ ( --- f1 )
  90 0194 3627     	  movs r7, #0x36            @ sys_ioctl
  91 0196 45F20141 	  movw r1, #0x5401
  92              	
  93 019a 40F20002 	  movw r2, #:lower16:hp     @ point r2 to hp
  94 019e C0F20002 	  movt r2, #:upper16:hp
  95 01a2 9268     	  ldr r2, [r2, #BODY]       @ were not interested in the tios data
  96              	
  97 01a4 00DF     	  swi 0                     @ only the return value from the syscall
  98              	
  99 01a6 0138     	  subs r0, r0, #1           @ set result = t/f
 100 01a8 8041     	  sbcs r0, r0, r0
 101 01aa 7047     	  bx lr
 102              	
 103              	@ ------------------------------------------------------------------------
 104              	@ is stdin/stdout on a controlling terminal?
 105              	
 106              	chk_tty:
 107 01ac 00B5     	  push { lr }
 108 01ae 0020     	  movs r0, #0               @ is stdin a tty?
 109 01b0 FFF7F0FF 	  bl _chktty
 110 01b4 AFF21011 	  adr r1, intty             @ put t/f result in constant
 111 01b8 8860     	  str r0, [r1, #BODY]
 112 01ba 0120     	  movs r0, #1               @ is stdout a tty?
 113 01bc FFF7EAFF 	  bl _chktty
 114 01c0 AFF20C11 	  adr r1, outtty            @ put t/f result in constant
 115 01c4 8860     	  str r0, [r1, #BODY]
 116 01c6 00BD     	  pop { pc }
 117              	
 118              	@ ------------------------------------------------------------------------
 119              	@ initialize some of forths core variables
 120              	
 121              	@ r8 holds address of start of .text section which is also the address
 122              	@    of this processes elf headers
 123              	
 124              	init_vars:
 125 01c8 0020     	  movs r0, #0               @ terminal properties not set yet
 126 01ca AFF23411 	  adr r1, shebang           @ clear flag: launched from a #! script
 127 01ce 8860     	  str r0, [r1, #BODY]
 128              	
 129 01d0 4046     	  mov r0, r8                @ point to start of text section
 130              	
 131              	  @ add in memory size - fload stack size
 132              	
 133 01d2 4FF64C72 	  movw r2, #:lower16:MEMSZ-FLDSZ
 134 01d6 C0F20F02 	  movt r2, #:upper16:MEMSZ-FLDSZ
 135 01da 1044     	  add r0, r0, r2
 136 01dc AFF2F801 	  adr r1, lsp               @ this is the address of the fload stack buffer
 137 01e0 8860     	  str r0, [r1, #BODY]
 138              	
 139 01e2 4FF48062 	  mov r2, #TIBSZ            @ subtract size of terminal input buffer
 140 01e6 801A     	  subs r0, r0, r2
 141 01e8 0FF64C71 	  adr r1, tib
 142 01ec 8860     	  str r0, [r1, #BODY]       @ this is the address of the terminal input buffer
 143              	
 144 01ee AFF2C811 	  adr r1, thead
 145 01f2 8860     	  str r0, [r1, #BODY]       @ is the address of top of header space
 146              	
 147 01f4 4046     	  mov r0, r8                @ point to half way up memory
 148 01f6 4FF40022 	  mov r2, #MEMSZ / 2
 149 01fa 1044     	  add r0, r0, r2
 150              	
 151 01fc 0022     	  movs r2, #0
 152 01fe 40F2FF32 	  movw r2, #0x3ff           @ align to page
 153 0202 1044     	  add r0, r0, r2
 154 0204 20EA0200 	  bic r0, r0, r2
 155              	
 156 0208 AFF2D411 	  adr r1, bhead             @ bhead is needed by fsave so that it can tell
 157 020c 8860     	  str r0, [r1, #BODY]       @ where head space starts
 158 020e 7047     	  bx lr
 159              	
 160              	@ ------------------------------------------------------------------------
 161              	@ save args for later processing
 162              	
 163              	get_args:
 164 0210 05BC     	  pop { r0, r2 }            @ r0 = argc, r2 = arg0
 165              	
 166 0212 AFF2CC11 	  adr r1, arg0
 167 0216 8A60     	  str r2, [r1, #BODY]       @ name this process was launched under
 168              	
 169 0218 AFF2B411 	  adr r1, argv              @ arg pointers are not moved off the stack
 170 021c C1F808D0 	  str sp, [r1, #BODY]       @ we just need to remember where they are
 171              	
 172 0220 1DEB8002 	  adds r2, sp, r0, lsl #2   @ point r2 past arg pointers on the stack **
 173 0224 0138     	  subs r0, r0, #1           @ argc does not count arg0 now
 174 0226 AFF2D011 	  adr r1, argc              @ remember arg count
 175 022a 8860     	  str r0, [r1, #BODY]
 176 022c AFF2B811 	  adr r1, envp              @ ** r2 was set to point to the env above
 177 0230 8A60     	  str r2, [r1, #BODY]       @ save address of array of env var pointers
 178              	
 179              	0:
 180 0232 52F8040B 	  ldr r0, [r2], #4          @ scan through env array next to null pointer
 181 0236 0028     	  cmp r0, #0
 182 0238 FBD1     	  bne 0b
 183 023a AFF2B411 	  adr r1, auxp              @ this is the address of the aux variables
 184 023e 8A60     	  str r2, [r1, #BODY]
 185              	
 186 0240 7047     	  bx lr
 187              	
 188              	@ ------------------------------------------------------------------------
 189              	@ primitive for memory allocation = fetch an anonumous memory mapping
 190              	
 191              	_fetchmap:
 192 0242 0020     	  movs r0, #0               @ addr
 193 0244 6FF00004 	  mvn r4, #0                @ fd = annonymous mapping
 194 0248 0025     	  movs r5, #0               @ start address
 195 024a C027     	  movs r7, #0xc0            @ sys mmap2
 196 024c 00DF     	  swi 0
 197 024e 7047     	  bx lr
 198              	
 199              	@ ------------------------------------------------------------------------
 200              	@ allocate the return stack
 201              	
 202              	alloc_ret:
 203 0250 00B5     	  push { lr }
 204 0252 4FF48051 	  mov r1, #STKSZ            @ size
 205 0256 0322     	  movs r2, #3               @ prot
 206 0258 2223     	  movs r3, #0x22            @ flags
 207 025a FFF7F2FF 	  bl _fetchmap
 208              	
 209 025e 4FF48051 	  mov r1, #STKSZ            @ set rp address = top of return stack buffer
 210 0262 0844     	  add r0, r0, r1
 211              	
 212 0264 A0A1     	  adr r1, rp0               @ point r1 at rp0 variable
 213 0266 8860     	  str r0, [r1, #BODY]       @ set constant bottom of return stack
 214 0268 8446     	  mov rp, r0                @ set rp = bottom of return stack
 215 026a 9BA1     	  adr r1, sp0               @ point r1 at sp0 variable
 216 026c C1F808D0 	  str sp, [r1, #BODY]       @ set constant bottom of parameter stack
 217              	
 218 0270 00BD     	  pop { pc }
 219              	
 220              	@ ------------------------------------------------------------------------
 221              	@ sys mprotect entire memory range of process to +rwx
 222              	
 223              	init_mem:
 224 0272 4046     	  mov r0, r8                @ point r0 at start of memory
 225 0274 4FF48011 	  mov r1, #MEMSZ            @ mem size = 1 meg
 226 0278 0722     	  movs r2, #7               @ +r +w +x
 227 027a 7D27     	  movs r7, #0x7d            @ sys mprotect
 228 027c 00DF     	  swi 0
 229 027e 7047     	  bx lr
 230              	
 231              	@ ------------------------------------------------------------------------
 232              	@ used by the memory manager extension
 233              	
 234              	@     ( size --- a1 f | t )
 235              	
 236              	colon "@map", fmap
 236              	>  header "@map",fmap
 236              	>>  _header_ "@map",fmap
 236              	>>>  .section .data
 236 0198 90010000 	>>>  .int _thread
 236              	>>>  .set _thread,.
 236              	>>> 8:
 236              	>>>  hstring "@map"
 236 019c 04       	>>>>  .byte lex+9f-(.+1)
 236 019d 406D6170 	>>>>  .ascii "@map"
 236              	>>>> 9:
 236 01a1 000000   	>>>>  .balign 4,0
 236              	>>>  .set lex,0
 236 01a4 84020000 	>>>  .int fmap
 236              	>>>  .previous
 236              	>>  .balign 4,0
 236 0280 9C010000 	>>  .int _thread
 236              	> fmap:
 236 0284 AFF30080 	>  nop.w
 236              	>  rpush lr
 236 0288 4CF804ED 	>>  str lr,[rp,#-4]!
 237 028c AFF29812 	  adr r2, heap_prot         @ user selectable heap protection
 238 0290 9268     	  ldr r2, [r2, #BODY]
 239 0292 AFF28C13 	  adr r3, heap_flg          @ user selectable flags
 240 0296 9B68     	  ldr r3, [r3, #BODY]
 241 0298 0100     	  movs r1, r0               @ size
 242 029a FFF7D2FF 	  bl _fetchmap              @ get an anonymous mapping
 243 029e 10F5805F 	  cmp r0, #0xfffff000       @ unable to allocate?
 244 02a2 03D3     	  blo 1f
 245 02a4 6FF00000 	  mvn r0, #0                @ yup, return failure
 246              	  exit
 246              	>  rpop pc
 246 02a8 5CF804FB 	>>  ldr pc,[rp],#4
 247              	
 248              	1:
 249 02ac 01B4     	  push { r0 }               @ success. return address of mapping
 250 02ae 0020     	  movs r0, #0               @ return success indication
 251              	  exit
 251              	>  rpop pc
 251 02b0 5CF804FB 	>>  ldr pc,[rp],#4
 252              	
 253              	@ ------------------------------------------------------------------------
 254              	@ clear all memory from 'here' to head space
 255              	
 256              	@ doing this also causes all the memory that linux has assigned to this
 257              	@ application to be physically allocated not just virtually allocated to
 258              	@ it.
 259              	@
 260              	@ this is somewhat greedy because linux will probably assign pages to us
 261              	@ that we never actuallyuse other than to clear them here.  during deve
 262              	@ and testing this is fine as it speeds up compilation slightly for
 263              	@ production you probably should not be doing this.
 264              	
 265              	@ you can create two versions of the kernel, one with this function and
 266              	@ one without. during development use the one with. once development is
 267              	@ complete compile your application against the other and fsave or
 268              	@ turnkey a new application executable
 269              	
 270              	clr_mem:
 271 02b4 0020     	  movs r0, #0
 272 02b6 40F20001 	  movw r1, #:lower16:dp
 273 02ba C0F20001 	  movt r1, #:upper16:dp
 274 02be 8968     	  ldr r1, [r1, #BODY]
 275 02c0 AFF28C22 	  adr r2, bhead             @ point r2 at bottom of head space
 276 02c4 9268     	  ldr r2, [r2, #BODY]
 277              	0:
 278 02c6 41F8010B 	  str r0, [r1], #1
 279 02ca 9142     	  cmp r1, r2
 280 02cc FBD1     	  bne 0b
 281 02ce 7047     	  bx lr
 282              	
 283              	@ ------------------------------------------------------------------------
 284              	@ entry point to forths initialization
 285              	
 286              	start:
 287 02d0 F846     	  mov r8, pc                @ address of start of process memory
 288 02d2 4FF20000 	  movw r0, #0xf000
 289 02d6 CFF6FF70 	  movt r0, #0xffff
 290 02da 08EA0008 	  and r8, r8, r0
 291              	
 292 02de FFF7C8FF 	  bl init_mem               @ make process memory +rwx
 293 02e2 FFF771FF 	  bl init_vars              @ initialize some forth variables
 294 02e6 FFF793FF 	  bl get_args               @ initialize command line args
 295 02ea FFF7B1FF 	  bl alloc_ret              @ allocate return stack
 296 02ee FFF71BFF 	  bl unpack                 @ unpack headers into head space
 297 02f2 FFF711FF 	  bl rehash                 @ fixup for crippled gnu assembler
 298 02f6 FFF7DDFF 	  bl clr_mem                @ erase code space from here to headers
 299 02fa FFF757FF 	  bl chk_tty                @ see if we have a controlling terminal
 300              	
 301 02fe FFF71BFF 	  bl pdefault               @ high priority init (stuff must happen early)
 302 0302 FFF721FF 	  bl default                @ normal priority init chain
 303 0306 FFF727FF 	  bl ldefault               @ low priority default init chain
 304              	
 305 030a 01F013BA 	  b quit                    @ start running forths inner loop
 306              	
 307              	@ ------------------------------------------------------------------------
 308              	@ the beef
 309              	
 310              	  .include "exec.s"         @ basic forth execution handlers
   1              	@ exec.s    - forth execution primitives
   2              	@ ------------------------------------------------------------------------
   3              	
   4              	@ ------------------------------------------------------------------------
   5              	@ useful place to stuff a breakpoint if your unlucky enough to have to
   6              	@ debug this kernel using gdb... God save us from gnu dev tools!
   7              	@ and for debugging real code (assembler) lldb wont be any better.
   8              	
   9              	@  _imm_
  10              	
  11              	code "break", break
  11              	>  header "break",break
  11              	>>  _header_ "break",break
  11              	>>>  .section .data
  11 01a8 9C010000 	>>>  .int _thread
  11              	>>>  .set _thread,.
  11              	>>> 8:
  11              	>>>  hstring "break"
  11 01ac 05       	>>>>  .byte lex+9f-(.+1)
  11 01ad 62726561 	>>>>  .ascii "break"
  11      6B
  11              	>>>> 9:
  11 01b2 0000     	>>>>  .balign 4,0
  11              	>>>  .set lex,0
  11 01b4 14030000 	>>>  .int break
  11              	>>>  .previous
  11 030e 0000     	>>  .balign 4,0
  11 0310 AC010000 	>>  .int _thread
  11              	> break:
  12 0314 AFF30080 	  nop.w                     @ because gdb is too stupid to actually
  13 0318 AFF30080 	  nop.w                     @ break on the symbol unless these are here
  14 031c AFF30080 	  nop.w                     @ because it is defined within a macro?
  15              	  next
  15 0320 7047     	>  bx lr
  16              	
  17              	@ ------------------------------------------------------------------------
  18              	@ most useful forth word ever!
  19              	
  20              	code "noop", noop
  20              	>  header "noop",noop
  20              	>>  _header_ "noop",noop
  20              	>>>  .section .data
  20 01b8 AC010000 	>>>  .int _thread
  20              	>>>  .set _thread,.
  20              	>>> 8:
  20              	>>>  hstring "noop"
  20 01bc 04       	>>>>  .byte lex+9f-(.+1)
  20 01bd 6E6F6F70 	>>>>  .ascii "noop"
  20              	>>>> 9:
  20 01c1 000000   	>>>>  .balign 4,0
  20              	>>>  .set lex,0
  20 01c4 28030000 	>>>  .int noop
  20              	>>>  .previous
  20 0322 0000     	>>  .balign 4,0
  20 0324 BC010000 	>>  .int _thread
  20              	> noop:
  21              	  next
  21 0328 7047     	>  bx lr
  22              	
  23              	@ ------------------------------------------------------------------------
  24              	@ used in extensions to compile an exit from colon definitions
  25              	
  26              	  _imm_
  26              	>  .set lex,IMM
  27              	
  28              	colon "exit", xit
  28              	>  header "exit",xit
  28              	>>  _header_ "exit",xit
  28              	>>>  .section .data
  28 01c8 BC010000 	>>>  .int _thread
  28              	>>>  .set _thread,.
  28              	>>> 8:
  28              	>>>  hstring "exit"
  28 01cc 84       	>>>>  .byte lex+9f-(.+1)
  28 01cd 65786974 	>>>>  .ascii "exit"
  28              	>>>> 9:
  28 01d1 000000   	>>>>  .balign 4,0
  28              	>>>  .set lex,0
  28 01d4 30030000 	>>>  .int xit
  28              	>>>  .previous
  28 032a 0000     	>>  .balign 4,0
  28 032c CC010000 	>>  .int _thread
  28              	> xit:
  28 0330 AFF30080 	>  nop.w
  28              	>  rpush lr
  28 0334 4CF804ED 	>>  str lr,[rp,#-4]!
  29 0338 01F082FE 	  bl litc                   @ compile the following exit token into the
  30              	  exit                      @ definition currently being created
  30              	>  rpop pc
  30 033c 5CF804FB 	>>  ldr pc,[rp],#4
  31              	  exit
  31              	>  rpop pc
  31 0340 5CF804FB 	>>  ldr pc,[rp],#4
  32              	
  33              	@ ------------------------------------------------------------------------
  34              	@ conditionally exit from a colon definition
  35              	
  36              	@   ( f1 --- )
  37              	
  38              	code "?exit", qexit
  38              	>  header "?exit",qexit
  38              	>>  _header_ "?exit",qexit
  38              	>>>  .section .data
  38 01d8 CC010000 	>>>  .int _thread
  38              	>>>  .set _thread,.
  38              	>>> 8:
  38              	>>>  hstring "?exit"
  38 01dc 05       	>>>>  .byte lex+9f-(.+1)
  38 01dd 3F657869 	>>>>  .ascii "?exit"
  38      74
  38              	>>>> 9:
  38 01e2 0000     	>>>>  .balign 4,0
  38              	>>>  .set lex,0
  38 01e4 48030000 	>>>  .int qexit
  38              	>>>  .previous
  38              	>>  .balign 4,0
  38 0344 DC010000 	>>  .int _thread
  38              	> qexit:
  39 0348 08B1     	  cbz r0, 1f                @ if f1 is zero dont exit
  40              	  rpop lr                   @ else pop return address of return stack
  40 034a 5CF804EB 	>  ldr lr,[rp],#4
  41              	1:
  42 034e 01BC     	  pop { r0 }                @ either way pop new top of stack
  43              	  next
  43 0350 7047     	>  bx lr
  44              	
  45              	@ ------------------------------------------------------------------------
  46              	@ execute word whose cfa is at top of stack
  47              	
  48              	@     ( cfa --- )
  49              	
  50              	code "execute", execute
  50              	>  header "execute",execute
  50              	>>  _header_ "execute",execute
  50              	>>>  .section .data
  50 01e8 DC010000 	>>>  .int _thread
  50              	>>>  .set _thread,.
  50              	>>> 8:
  50              	>>>  hstring "execute"
  50 01ec 07       	>>>>  .byte lex+9f-(.+1)
  50 01ed 65786563 	>>>>  .ascii "execute"
  50      757465
  50              	>>>> 9:
  50              	>>>>  .balign 4,0
  50              	>>>  .set lex,0
  50 01f4 58030000 	>>>  .int execute
  50              	>>>  .previous
  50 0352 0000     	>>  .balign 4,0
  50 0354 EC010000 	>>  .int _thread
  50              	> execute:
  51 0358 411C     	  adds r1, r0, #1           @ thumbificate the target address
  52 035a 01BC     	  pop { r0 }
  53 035c 0847     	  bx r1
  54              	
  55              	@ ------------------------------------------------------------------------
  56              	@ execute a deferred word
  57              	
  58              	code "dodefer", dodefer
  58              	>  header "dodefer",dodefer
  58              	>>  _header_ "dodefer",dodefer
  58              	>>>  .section .data
  58 01f8 EC010000 	>>>  .int _thread
  58              	>>>  .set _thread,.
  58              	>>> 8:
  58              	>>>  hstring "dodefer"
  58 01fc 07       	>>>>  .byte lex+9f-(.+1)
  58 01fd 646F6465 	>>>>  .ascii "dodefer"
  58      666572
  58              	>>>> 9:
  58              	>>>>  .balign 4,0
  58              	>>>  .set lex,0
  58 0204 64030000 	>>>  .int dodefer
  58              	>>>  .previous
  58 035e 0000     	>>  .balign 4,0
  58 0360 FC010000 	>>  .int _thread
  58              	> dodefer:
  59 0364 2EF0010E 	  bic lr, #1                @ fetch body of deferred word
  60 0368 DEF80010 	  ldr r1, [lr]
  61              	  rpop lr
  61 036c 5CF804EB 	>  ldr lr,[rp],#4
  62 0370 0131     	  adds r1, #1               @ thumbificate the address
  63 0372 0847     	  bx r1
  64              	
  65              	@ ------------------------------------------------------------------------
  66              	@ return value of a constant
  67              	
  68              	@     ( --- n1 )
  69              	
  70              	code "dovar", dovar
  70              	>  header "dovar",dovar
  70              	>>  _header_ "dovar",dovar
  70              	>>>  .section .data
  70 0208 FC010000 	>>>  .int _thread
  70              	>>>  .set _thread,.
  70              	>>> 8:
  70              	>>>  hstring "dovar"
  70 020c 05       	>>>>  .byte lex+9f-(.+1)
  70 020d 646F7661 	>>>>  .ascii "dovar"
  70      72
  70              	>>>> 9:
  70 0212 0000     	>>>>  .balign 4,0
  70              	>>>  .set lex,0
  70 0214 78030000 	>>>  .int dovar
  70              	>>>  .previous
  70              	>>  .balign 4,0
  70 0374 0C020000 	>>  .int _thread
  70              	> dovar:
  71 0378 01B4     	  push { r0 }
  72 037a 2EF0010E 	  bic lr, #1
  73 037e DEF80000 	  ldr r0, [lr]
  74              	  exit
  74              	>  rpop pc
  74 0382 5CF804FB 	>>  ldr pc,[rp],#4
  75              	
  76              	@ ------------------------------------------------------------------------
  77              	@ return address of a variable
  78              	
  79              	@     ( --- a1 )
  80              	
  81              	code "dovariable", dovariable
  81              	>  header "dovariable",dovariable
  81              	>>  _header_ "dovariable",dovariable
  81              	>>>  .section .data
  81 0218 0C020000 	>>>  .int _thread
  81              	>>>  .set _thread,.
  81              	>>> 8:
  81              	>>>  hstring "dovariable"
  81 021c 0A       	>>>>  .byte lex+9f-(.+1)
  81 021d 646F7661 	>>>>  .ascii "dovariable"
  81      72696162 
  81      6C65
  81              	>>>> 9:
  81 0227 00       	>>>>  .balign 4,0
  81              	>>>  .set lex,0
  81 0228 8C030000 	>>>  .int dovariable
  81              	>>>  .previous
  81 0386 0000     	>>  .balign 4,0
  81 0388 1C020000 	>>  .int _thread
  81              	> dovariable:
  82 038c 01B4     	  push { r0 }
  83 038e 2EF0010E 	  bic lr, #1
  84 0392 7046     	  mov r0, lr
  85              	  exit
  85              	>  rpop pc
  85 0394 5CF804FB 	>>  ldr pc,[rp],#4
  86              	
  87              	@ ------------------------------------------------------------------------
  88              	
  89              	colon "bye", bye
  89              	>  header "bye",bye
  89              	>>  _header_ "bye",bye
  89              	>>>  .section .data
  89 022c 1C020000 	>>>  .int _thread
  89              	>>>  .set _thread,.
  89              	>>> 8:
  89              	>>>  hstring "bye"
  89 0230 03       	>>>>  .byte lex+9f-(.+1)
  89 0231 627965   	>>>>  .ascii "bye"
  89              	>>>> 9:
  89              	>>>>  .balign 4,0
  89              	>>>  .set lex,0
  89 0234 9C030000 	>>>  .int bye
  89              	>>>  .previous
  89              	>>  .balign 4,0
  89 0398 30020000 	>>  .int _thread
  89              	> bye:
  89 039c AFF30080 	>  nop.w
  89              	>  rpush lr
  89 03a0 4CF804ED 	>>  str lr,[rp,#-4]!
  90 03a4 FFF7E0FE 	  bl atexit                 @ run deferred atexit chain
  91 03a8 00F03CFF 	  bl cr_
  92 03ac 00F03AFF 	  bl cr_
  93 03b0 00F06CFF 	  bl pdotq
  94              	  hstring "Au Revoir!"
  94 03b4 0A       	>  .byte lex+9f-(.+1)
  94 03b5 41752052 	>  .ascii "Au Revoir!"
  94      65766F69 
  94      7221
  94              	> 9:
  94 03bf 00       	>  .balign 4,0
  95 03c0 00F030FF 	  bl cr_
  96 03c4 00F02EFF 	  bl cr_
  97 03c8 00F004F8 	  bl errno                  @ return errno to system
  98 03cc 00F034F8 	  bl sys_exit
  99              	
 100              	@ ========================================================================
 311              	  .include "syscalls.s"     @ system calls and signals
   1              	@ syscalls.s
   2              	@ ------------------------------------------------------------------------
   3              	
   4              	  _constant_ "errno", errno, 0
   4              	>  header "errno",errno
   4              	>>  _header_ "errno",errno
   4              	>>>  .section .data
   4 0238 30020000 	>>>  .int _thread
   4              	>>>  .set _thread,.
   4              	>>> 8:
   4              	>>>  hstring "errno"
   4 023c 05       	>>>>  .byte lex+9f-(.+1)
   4 023d 6572726E 	>>>>  .ascii "errno"
   4      6F
   4              	>>>> 9:
   4 0242 0000     	>>>>  .balign 4,0
   4              	>>>  .set lex,0
   4 0244 D4030000 	>>>  .int errno
   4              	>>>  .previous
   4              	>>  .balign 4,0
   4 03d0 3C020000 	>>  .int _thread
   4              	> errno:
   4              	>  rpush lr
   4 03d4 4CF804ED 	>>  str lr,[rp,#-4]!
   4 03d8 FFF7CEFF 	>  bl dovar
   4 03dc 00000000 	>  .int 0
   5              	
   6              	@ ------------------------------------------------------------------------
   7              	@ handle syscall with no parameters or one with all registers populated
   8              	
   9              	sys1:
  10              	sys0:                       @ syscall number is in r7
  11 03e0 00DF     	  swi 0                     @ execute system call
  12 03e2 10F5805F 	  cmp r0, #0xfffff000
  13 03e6 05D3     	  blo 1f
  14              	
  15 03e8 C043     	  mvns r0, r0               @ error: convert error return to positive val
  16 03ea AFF21801 	  adr r1, errno             @ stuff it in errno
  17 03ee 8860     	  str r0, [r1, #BODY]
  18 03f0 6FF00000 	  mvn r0, #0                @ return bad result
  19              	
  20              	1:
  21              	  exit
  21              	>  rpop pc
  21 03f4 5CF804FB 	>>  ldr pc,[rp],#4
  22              	
  23              	@ ------------------------------------------------------------------------
  24              	@ handle syscall with 2 parameters
  25              	
  26              	sys2:
  27 03f8 02BC     	  pop { r1 }
  28 03fa F1E7     	  b sys0
  29              	
  30              	@ ------------------------------------------------------------------------
  31              	@ handle syscall with 3 parameters
  32              	
  33              	sys3:
  34 03fc 06BC     	  pop { r1, r2 }
  35 03fe EFE7     	  b sys0
  36              	
  37              	@ ------------------------------------------------------------------------
  38              	
  39              	sys4:
  40 0400 0EBC     	  pop { r1, r2, r3 }
  41 0402 EDE7     	  b sys0
  42              	
  43              	@ ------------------------------------------------------------------------
  44              	
  45              	sys5:
  46 0404 1EBC     	  pop { r1, r2, r3, r4 }
  47 0406 EBE7     	  b sys0
  48              	
  49              	@ ------------------------------------------------------------------------
  50              	
  51              	sys6:
  52 0408 3EBC     	  pop { r1, r2, r3, r4, r5 }
  53 040a E9E7     	  b sys0
  54              	
  55              	@ ------------------------------------------------------------------------
  56              	
  57              	code "dosyscall", do_syscall
  57              	>  header "dosyscall",do_syscall
  57              	>>  _header_ "dosyscall",do_syscall
  57              	>>>  .section .data
  57 0248 3C020000 	>>>  .int _thread
  57              	>>>  .set _thread,.
  57              	>>> 8:
  57              	>>>  hstring "dosyscall"
  57 024c 09       	>>>>  .byte lex+9f-(.+1)
  57 024d 646F7379 	>>>>  .ascii "dosyscall"
  57      7363616C 
  57      6C
  57              	>>>> 9:
  57 0256 0000     	>>>>  .balign 4,0
  57              	>>>  .set lex,0
  57 0258 10040000 	>>>  .int do_syscall
  57              	>>>  .previous
  57              	>>  .balign 4,0
  57 040c 4C020000 	>>  .int _thread
  57              	> do_syscall:
  58 0410 2EF0010E 	  bic lr, #1
  59 0414 7346     	  mov r3, lr
  60 0416 1F88     	  ldrh r7, [r3]             @ get syscall number
  61 0418 5988     	  ldrh r1, [r3, #2]         @ parameter count
  62 041a DFE801F0 	  tbb [pc, r1]
  63              	
  64 041e 04050607 	  .byte 4, 5, 6, 7, 8, 9, 10
  64      08090A
  65 0425 00       	  .balign 2
  66              	
  67 0426 DBE7     	  b sys0
  68 0428 DAE7     	  b sys1
  69 042a E5E7     	  b sys2
  70 042c E6E7     	  b sys3
  71 042e E7E7     	  b sys4
  72 0430 E8E7     	  b sys5
  73 0432 E9E7     	  b sys6
  74              	
  75              	@ ------------------------------------------------------------------------
  76              	@ only defining syscalls that are used within the kernel. new syscalls
  77              	@ can be added at any time using '#params sys# syscall <sys_name>'
  78              	
  79              	 _syscall_ "<exit>",   sys_exit,   1,    1
  79              	>  header "<exit>",sys_exit
  79              	>>  _header_ "<exit>",sys_exit
  79              	>>>  .section .data
  79 025c 4C020000 	>>>  .int _thread
  79              	>>>  .set _thread,.
  79              	>>> 8:
  79              	>>>  hstring "<exit>"
  79 0260 06       	>>>>  .byte lex+9f-(.+1)
  79 0261 3C657869 	>>>>  .ascii "<exit>"
  79      743E
  79              	>>>> 9:
  79 0267 00       	>>>>  .balign 4,0
  79              	>>>  .set lex,0
  79 0268 38040000 	>>>  .int sys_exit
  79              	>>>  .previous
  79              	>>  .balign 4,0
  79 0434 60020000 	>>  .int _thread
  79              	> sys_exit:
  79              	>  rpush lr
  79 0438 4CF804ED 	>>  str lr,[rp,#-4]!
  79 043c FFF7E8FF 	>  bl do_syscall
  79 0440 0100     	>  .hword 1
  79 0442 0100     	>  .hword 1
  80              	 _syscall_ "<read>",   sys_read,   3,    3
  80              	>  header "<read>",sys_read
  80              	>>  _header_ "<read>",sys_read
  80              	>>>  .section .data
  80 026c 60020000 	>>>  .int _thread
  80              	>>>  .set _thread,.
  80              	>>> 8:
  80              	>>>  hstring "<read>"
  80 0270 06       	>>>>  .byte lex+9f-(.+1)
  80 0271 3C726561 	>>>>  .ascii "<read>"
  80      643E
  80              	>>>> 9:
  80 0277 00       	>>>>  .balign 4,0
  80              	>>>  .set lex,0
  80 0278 48040000 	>>>  .int sys_read
  80              	>>>  .previous
  80              	>>  .balign 4,0
  80 0444 70020000 	>>  .int _thread
  80              	> sys_read:
  80              	>  rpush lr
  80 0448 4CF804ED 	>>  str lr,[rp,#-4]!
  80 044c FFF7E0FF 	>  bl do_syscall
  80 0450 0300     	>  .hword 3
  80 0452 0300     	>  .hword 3
  81              	 _syscall_ "<write>",  sys_write,  4,    3
  81              	>  header "<write>",sys_write
  81              	>>  _header_ "<write>",sys_write
  81              	>>>  .section .data
  81 027c 70020000 	>>>  .int _thread
  81              	>>>  .set _thread,.
  81              	>>> 8:
  81              	>>>  hstring "<write>"
  81 0280 07       	>>>>  .byte lex+9f-(.+1)
  81 0281 3C777269 	>>>>  .ascii "<write>"
  81      74653E
  81              	>>>> 9:
  81              	>>>>  .balign 4,0
  81              	>>>  .set lex,0
  81 0288 58040000 	>>>  .int sys_write
  81              	>>>  .previous
  81              	>>  .balign 4,0
  81 0454 80020000 	>>  .int _thread
  81              	> sys_write:
  81              	>  rpush lr
  81 0458 4CF804ED 	>>  str lr,[rp,#-4]!
  81 045c FFF7D8FF 	>  bl do_syscall
  81 0460 0400     	>  .hword 4
  81 0462 0300     	>  .hword 3
  82              	 _syscall_ "<open>",   sys_open,   5,    2
  82              	>  header "<open>",sys_open
  82              	>>  _header_ "<open>",sys_open
  82              	>>>  .section .data
  82 028c 80020000 	>>>  .int _thread
  82              	>>>  .set _thread,.
  82              	>>> 8:
  82              	>>>  hstring "<open>"
  82 0290 06       	>>>>  .byte lex+9f-(.+1)
  82 0291 3C6F7065 	>>>>  .ascii "<open>"
  82      6E3E
  82              	>>>> 9:
  82 0297 00       	>>>>  .balign 4,0
  82              	>>>  .set lex,0
  82 0298 68040000 	>>>  .int sys_open
  82              	>>>  .previous
  82              	>>  .balign 4,0
  82 0464 90020000 	>>  .int _thread
  82              	> sys_open:
  82              	>  rpush lr
  82 0468 4CF804ED 	>>  str lr,[rp,#-4]!
  82 046c FFF7D0FF 	>  bl do_syscall
  82 0470 0500     	>  .hword 5
  82 0472 0200     	>  .hword 2
  83              	 _syscall_ "<open3>",  sys_open3,  5,    3
  83              	>  header "<open3>",sys_open3
  83              	>>  _header_ "<open3>",sys_open3
  83              	>>>  .section .data
  83 029c 90020000 	>>>  .int _thread
  83              	>>>  .set _thread,.
  83              	>>> 8:
  83              	>>>  hstring "<open3>"
  83 02a0 07       	>>>>  .byte lex+9f-(.+1)
  83 02a1 3C6F7065 	>>>>  .ascii "<open3>"
  83      6E333E
  83              	>>>> 9:
  83              	>>>>  .balign 4,0
  83              	>>>  .set lex,0
  83 02a8 78040000 	>>>  .int sys_open3
  83              	>>>  .previous
  83              	>>  .balign 4,0
  83 0474 A0020000 	>>  .int _thread
  83              	> sys_open3:
  83              	>  rpush lr
  83 0478 4CF804ED 	>>  str lr,[rp,#-4]!
  83 047c FFF7C8FF 	>  bl do_syscall
  83 0480 0500     	>  .hword 5
  83 0482 0300     	>  .hword 3
  84              	 _syscall_ "<close>",  sys_close,  6,    1
  84              	>  header "<close>",sys_close
  84              	>>  _header_ "<close>",sys_close
  84              	>>>  .section .data
  84 02ac A0020000 	>>>  .int _thread
  84              	>>>  .set _thread,.
  84              	>>> 8:
  84              	>>>  hstring "<close>"
  84 02b0 07       	>>>>  .byte lex+9f-(.+1)
  84 02b1 3C636C6F 	>>>>  .ascii "<close>"
  84      73653E
  84              	>>>> 9:
  84              	>>>>  .balign 4,0
  84              	>>>  .set lex,0
  84 02b8 88040000 	>>>  .int sys_close
  84              	>>>  .previous
  84              	>>  .balign 4,0
  84 0484 B0020000 	>>  .int _thread
  84              	> sys_close:
  84              	>  rpush lr
  84 0488 4CF804ED 	>>  str lr,[rp,#-4]!
  84 048c FFF7C0FF 	>  bl do_syscall
  84 0490 0600     	>  .hword 6
  84 0492 0100     	>  .hword 1
  85              	@ _syscall_ "<creat>",  sys_creat,  8,    2
  86              	 _syscall_ "<lseek>",  sys_lseek,  0x13, 3
  86              	>  header "<lseek>",sys_lseek
  86              	>>  _header_ "<lseek>",sys_lseek
  86              	>>>  .section .data
  86 02bc B0020000 	>>>  .int _thread
  86              	>>>  .set _thread,.
  86              	>>> 8:
  86              	>>>  hstring "<lseek>"
  86 02c0 07       	>>>>  .byte lex+9f-(.+1)
  86 02c1 3C6C7365 	>>>>  .ascii "<lseek>"
  86      656B3E
  86              	>>>> 9:
  86              	>>>>  .balign 4,0
  86              	>>>  .set lex,0
  86 02c8 98040000 	>>>  .int sys_lseek
  86              	>>>  .previous
  86              	>>  .balign 4,0
  86 0494 C0020000 	>>  .int _thread
  86              	> sys_lseek:
  86              	>  rpush lr
  86 0498 4CF804ED 	>>  str lr,[rp,#-4]!
  86 049c FFF7B8FF 	>  bl do_syscall
  86 04a0 1300     	>  .hword 0x13
  86 04a2 0300     	>  .hword 3
  87              	@ _syscall_ "<signal>", sys_signal, 0x30, 2
  88              	@ _syscall_ "<ioctl>",  sys_ioctl,  0x36, 3
  89              	 _syscall_ "<mmap2>",  sys_mmap2,  0xc0, 6
  89              	>  header "<mmap2>",sys_mmap2
  89              	>>  _header_ "<mmap2>",sys_mmap2
  89              	>>>  .section .data
  89 02cc C0020000 	>>>  .int _thread
  89              	>>>  .set _thread,.
  89              	>>> 8:
  89              	>>>  hstring "<mmap2>"
  89 02d0 07       	>>>>  .byte lex+9f-(.+1)
  89 02d1 3C6D6D61 	>>>>  .ascii "<mmap2>"
  89      70323E
  89              	>>>> 9:
  89              	>>>>  .balign 4,0
  89              	>>>  .set lex,0
  89 02d8 A8040000 	>>>  .int sys_mmap2
  89              	>>>  .previous
  89              	>>  .balign 4,0
  89 04a4 D0020000 	>>  .int _thread
  89              	> sys_mmap2:
  89              	>  rpush lr
  89 04a8 4CF804ED 	>>  str lr,[rp,#-4]!
  89 04ac FFF7B0FF 	>  bl do_syscall
  89 04b0 C000     	>  .hword 0xc0
  89 04b2 0600     	>  .hword 6
  90              	 _syscall_ "<munmap>", sys_munmap, 0x5b, 2
  90              	>  header "<munmap>",sys_munmap
  90              	>>  _header_ "<munmap>",sys_munmap
  90              	>>>  .section .data
  90 02dc D0020000 	>>>  .int _thread
  90              	>>>  .set _thread,.
  90              	>>> 8:
  90              	>>>  hstring "<munmap>"
  90 02e0 08       	>>>>  .byte lex+9f-(.+1)
  90 02e1 3C6D756E 	>>>>  .ascii "<munmap>"
  90      6D61703E 
  90              	>>>> 9:
  90 02e9 000000   	>>>>  .balign 4,0
  90              	>>>  .set lex,0
  90 02ec B8040000 	>>>  .int sys_munmap
  90              	>>>  .previous
  90              	>>  .balign 4,0
  90 04b4 E0020000 	>>  .int _thread
  90              	> sys_munmap:
  90              	>  rpush lr
  90 04b8 4CF804ED 	>>  str lr,[rp,#-4]!
  90 04bc FFF7A8FF 	>  bl do_syscall
  90 04c0 5B00     	>  .hword 0x5b
  90 04c2 0200     	>  .hword 2
  91              	 _syscall_ "<poll>",   sys_poll,   0xa8, 3
  91              	>  header "<poll>",sys_poll
  91              	>>  _header_ "<poll>",sys_poll
  91              	>>>  .section .data
  91 02f0 E0020000 	>>>  .int _thread
  91              	>>>  .set _thread,.
  91              	>>> 8:
  91              	>>>  hstring "<poll>"
  91 02f4 06       	>>>>  .byte lex+9f-(.+1)
  91 02f5 3C706F6C 	>>>>  .ascii "<poll>"
  91      6C3E
  91              	>>>> 9:
  91 02fb 00       	>>>>  .balign 4,0
  91              	>>>  .set lex,0
  91 02fc C8040000 	>>>  .int sys_poll
  91              	>>>  .previous
  91              	>>  .balign 4,0
  91 04c4 F4020000 	>>  .int _thread
  91              	> sys_poll:
  91              	>  rpush lr
  91 04c8 4CF804ED 	>>  str lr,[rp,#-4]!
  91 04cc FFF7A0FF 	>  bl do_syscall
  91 04d0 A800     	>  .hword 0xa8
  91 04d2 0300     	>  .hword 3
  92              	
  93              	@ ========================================================================
 312              	  .include "stacks.s"       @ stack manipulation words
   1              	@ stacks.s    - stack manipulation words
   2              	@ ------------------------------------------------------------------------
   3              	
   4              	@ ------------------------------------------------------------------------
   5              	
   6              	  _var_ "sp0", sp0, 0
   6              	>  header "sp0",sp0
   6              	>>  _header_ "sp0",sp0
   6              	>>>  .section .data
   6 0300 F4020000 	>>>  .int _thread
   6              	>>>  .set _thread,.
   6              	>>> 8:
   6              	>>>  hstring "sp0"
   6 0304 03       	>>>>  .byte lex+9f-(.+1)
   6 0305 737030   	>>>>  .ascii "sp0"
   6              	>>>> 9:
   6              	>>>>  .balign 4,0
   6              	>>>  .set lex,0
   6 0308 D8040000 	>>>  .int sp0
   6              	>>>  .previous
   6              	>>  .balign 4,0
   6 04d4 04030000 	>>  .int _thread
   6              	> sp0:
   6              	>  rpush lr
   6 04d8 4CF804ED 	>>  str lr,[rp,#-4]!
   6 04dc FFF74CFF 	>  bl dovar
   6 04e0 00000000 	>  .int 0
   7              	  _var_ "rp0", rp0, 0
   7              	>  header "rp0",rp0
   7              	>>  _header_ "rp0",rp0
   7              	>>>  .section .data
   7 030c 04030000 	>>>  .int _thread
   7              	>>>  .set _thread,.
   7              	>>> 8:
   7              	>>>  hstring "rp0"
   7 0310 03       	>>>>  .byte lex+9f-(.+1)
   7 0311 727030   	>>>>  .ascii "rp0"
   7              	>>>> 9:
   7              	>>>>  .balign 4,0
   7              	>>>  .set lex,0
   7 0314 E8040000 	>>>  .int rp0
   7              	>>>  .previous
   7              	>>  .balign 4,0
   7 04e4 10030000 	>>  .int _thread
   7              	> rp0:
   7              	>  rpush lr
   7 04e8 4CF804ED 	>>  str lr,[rp,#-4]!
   7 04ec FFF744FF 	>  bl dovar
   7 04f0 00000000 	>  .int 0
   8              	
   9              	@ ------------------------------------------------------------------------
  10              	@ duplicate top of stack unless it is zero
  11              	
  12              	@     ( n1 --- n1 n1 | n1 )
  13              	
  14              	code "?dup", qdup
  14              	>  header "?dup",qdup
  14              	>>  _header_ "?dup",qdup
  14              	>>>  .section .data
  14 0318 10030000 	>>>  .int _thread
  14              	>>>  .set _thread,.
  14              	>>> 8:
  14              	>>>  hstring "?dup"
  14 031c 04       	>>>>  .byte lex+9f-(.+1)
  14 031d 3F647570 	>>>>  .ascii "?dup"
  14              	>>>> 9:
  14 0321 000000   	>>>>  .balign 4,0
  14              	>>>  .set lex,0
  14 0324 F8040000 	>>>  .int qdup
  14              	>>>  .previous
  14              	>>  .balign 4,0
  14 04f4 1C030000 	>>  .int _thread
  14              	> qdup:
  15 04f8 0028     	  cmp r0, #0
  16 04fa 18BF     	  it ne
  17 04fc 01B4     	  pushne { r0 }
  18              	  next
  18 04fe 7047     	>  bx lr
  19              	
  20              	@ ------------------------------------------------------------------------
  21              	@ duplicate top of stack
  22              	
  23              	@     ( n1 --- n1 n1 )
  24              	
  25              	code "dup", dup
  25              	>  header "dup",dup
  25              	>>  _header_ "dup",dup
  25              	>>>  .section .data
  25 0328 1C030000 	>>>  .int _thread
  25              	>>>  .set _thread,.
  25              	>>> 8:
  25              	>>>  hstring "dup"
  25 032c 03       	>>>>  .byte lex+9f-(.+1)
  25 032d 647570   	>>>>  .ascii "dup"
  25              	>>>> 9:
  25              	>>>>  .balign 4,0
  25              	>>>  .set lex,0
  25 0330 04050000 	>>>  .int dup
  25              	>>>  .previous
  25              	>>  .balign 4,0
  25 0500 2C030000 	>>  .int _thread
  25              	> dup:
  26 0504 01B4     	  push { r0 }
  27              	  next
  27 0506 7047     	>  bx lr
  28              	
  29              	@ ------------------------------------------------------------------------
  30              	@ duplicate top two items of stack
  31              	
  32              	@     ( n1 n2 --- n1 n2 n1 n2 )
  33              	
  34              	code "2dup", twodup
  34              	>  header "2dup",twodup
  34              	>>  _header_ "2dup",twodup
  34              	>>>  .section .data
  34 0334 2C030000 	>>>  .int _thread
  34              	>>>  .set _thread,.
  34              	>>> 8:
  34              	>>>  hstring "2dup"
  34 0338 04       	>>>>  .byte lex+9f-(.+1)
  34 0339 32647570 	>>>>  .ascii "2dup"
  34              	>>>> 9:
  34 033d 000000   	>>>>  .balign 4,0
  34              	>>>  .set lex,0
  34 0340 0C050000 	>>>  .int twodup
  34              	>>>  .previous
  34              	>>  .balign 4,0
  34 0508 38030000 	>>  .int _thread
  34              	> twodup:
  35 050c 6946     	  mov r1, sp
  36 050e 0968     	  ldr r1, [r1]
  37 0510 01B4     	  push { r0 }
  38 0512 02B4     	  push { r1 }
  39              	  next
  39 0514 7047     	>  bx lr
  40              	
  41              	@ ------------------------------------------------------------------------
  42              	@ duplicate top three items of stack
  43              	
  44              	@     ( n1 n2 n3 --- n1 n2 n3 n1 n2 n3 )
  45              	
  46              	code "3dup", threedup
  46              	>  header "3dup",threedup
  46              	>>  _header_ "3dup",threedup
  46              	>>>  .section .data
  46 0344 38030000 	>>>  .int _thread
  46              	>>>  .set _thread,.
  46              	>>> 8:
  46              	>>>  hstring "3dup"
  46 0348 04       	>>>>  .byte lex+9f-(.+1)
  46 0349 33647570 	>>>>  .ascii "3dup"
  46              	>>>> 9:
  46 034d 000000   	>>>>  .balign 4,0
  46              	>>>  .set lex,0
  46 0350 1C050000 	>>>  .int threedup
  46              	>>>  .previous
  46 0516 0000     	>>  .balign 4,0
  46 0518 48030000 	>>  .int _thread
  46              	> threedup:
  47 051c 06BC     	  pop { r1, r2 }
  48 051e 07B4     	  push { r0, r1, r2 }
  49 0520 06B4     	  push { r1, r2 }
  50              	  next
  50 0522 7047     	>  bx lr
  51              	
  52              	@ ------------------------------------------------------------------------
  53              	@ swap order of top two items of stack
  54              	
  55              	@     ( n1 n2 --- n2 n1 )
  56              	
  57              	code "swap", swap
  57              	>  header "swap",swap
  57              	>>  _header_ "swap",swap
  57              	>>>  .section .data
  57 0354 48030000 	>>>  .int _thread
  57              	>>>  .set _thread,.
  57              	>>> 8:
  57              	>>>  hstring "swap"
  57 0358 04       	>>>>  .byte lex+9f-(.+1)
  57 0359 73776170 	>>>>  .ascii "swap"
  57              	>>>> 9:
  57 035d 000000   	>>>>  .balign 4,0
  57              	>>>  .set lex,0
  57 0360 28050000 	>>>  .int swap
  57              	>>>  .previous
  57              	>>  .balign 4,0
  57 0524 58030000 	>>  .int _thread
  57              	> swap:
  58 0528 02BC     	  pop { r1 }
  59 052a 01B4     	  push { r0 }
  60 052c 0846     	  mov r0, r1
  61              	  next
  61 052e 7047     	>  bx lr
  62              	
  63              	@ ------------------------------------------------------------------------
  64              	@ swap order of top two pairs of items on stack
  65              	
  66              	@   ( n1 n2 n3 n4 --- n3 n4 n1 n2 )
  67              	
  68              	code "2swap", twoswap
  68              	>  header "2swap",twoswap
  68              	>>  _header_ "2swap",twoswap
  68              	>>>  .section .data
  68 0364 58030000 	>>>  .int _thread
  68              	>>>  .set _thread,.
  68              	>>> 8:
  68              	>>>  hstring "2swap"
  68 0368 05       	>>>>  .byte lex+9f-(.+1)
  68 0369 32737761 	>>>>  .ascii "2swap"
  68      70
  68              	>>>> 9:
  68 036e 0000     	>>>>  .balign 4,0
  68              	>>>  .set lex,0
  68 0370 34050000 	>>>  .int twoswap
  68              	>>>  .previous
  68              	>>  .balign 4,0
  68 0530 68030000 	>>  .int _thread
  68              	> twoswap:
  69 0534 0EBC     	  pop { r1, r2, r3 }
  70 0536 03B4     	  push { r0, r1 }
  71 0538 08B4     	  push { r3 }
  72 053a 1000     	  movs r0, r2
  73              	  next
  73 053c 7047     	>  bx lr
  74              	
  75              	@ ------------------------------------------------------------------------
  76              	@ discard top item of stack
  77              	
  78              	@     ( n1 --- )
  79              	
  80              	code "drop", drop
  80              	>  header "drop",drop
  80              	>>  _header_ "drop",drop
  80              	>>>  .section .data
  80 0374 68030000 	>>>  .int _thread
  80              	>>>  .set _thread,.
  80              	>>> 8:
  80              	>>>  hstring "drop"
  80 0378 04       	>>>>  .byte lex+9f-(.+1)
  80 0379 64726F70 	>>>>  .ascii "drop"
  80              	>>>> 9:
  80 037d 000000   	>>>>  .balign 4,0
  80              	>>>  .set lex,0
  80 0380 44050000 	>>>  .int drop
  80              	>>>  .previous
  80 053e 0000     	>>  .balign 4,0
  80 0540 78030000 	>>  .int _thread
  80              	> drop:
  81 0544 01BC     	  pop { r0 }
  82              	  next
  82 0546 7047     	>  bx lr
  83              	
  84              	@ ------------------------------------------------------------------------
  85              	@ discard top two items of stack
  86              	
  87              	@     ( n1 n2 --- )
  88              	
  89              	code "2drop", twodrop
  89              	>  header "2drop",twodrop
  89              	>>  _header_ "2drop",twodrop
  89              	>>>  .section .data
  89 0384 78030000 	>>>  .int _thread
  89              	>>>  .set _thread,.
  89              	>>> 8:
  89              	>>>  hstring "2drop"
  89 0388 05       	>>>>  .byte lex+9f-(.+1)
  89 0389 3264726F 	>>>>  .ascii "2drop"
  89      70
  89              	>>>> 9:
  89 038e 0000     	>>>>  .balign 4,0
  89              	>>>  .set lex,0
  89 0390 4C050000 	>>>  .int twodrop
  89              	>>>  .previous
  89              	>>  .balign 4,0
  89 0548 88030000 	>>  .int _thread
  89              	> twodrop:
  90 054c 01B0     	  add sp, sp, #4
  91 054e 01BC     	  pop { r0 }
  92              	  next
  92 0550 7047     	>  bx lr
  93              	
  94              	@ ------------------------------------------------------------------------
  95              	@ discard top three items of stacl
  96              	
  97              	@     ( n1 n2 n3 --- )
  98              	
  99              	code "3drop", threedrop
  99              	>  header "3drop",threedrop
  99              	>>  _header_ "3drop",threedrop
  99              	>>>  .section .data
  99 0394 88030000 	>>>  .int _thread
  99              	>>>  .set _thread,.
  99              	>>> 8:
  99              	>>>  hstring "3drop"
  99 0398 05       	>>>>  .byte lex+9f-(.+1)
  99 0399 3364726F 	>>>>  .ascii "3drop"
  99      70
  99              	>>>> 9:
  99 039e 0000     	>>>>  .balign 4,0
  99              	>>>  .set lex,0
  99 03a0 58050000 	>>>  .int threedrop
  99              	>>>  .previous
  99 0552 0000     	>>  .balign 4,0
  99 0554 98030000 	>>  .int _thread
  99              	> threedrop:
 100 0558 02B0     	  add sp, sp, #8
 101 055a 01BC     	  pop { r0 }
 102              	  next
 102 055c 7047     	>  bx lr
 103              	
 104              	@ ------------------------------------------------------------------------
 105              	@ copy second item on stack over top of top item
 106              	
 107              	@     ( n1 n2 --- n1 n2 n1 )
 108              	
 109              	code "over", over
 109              	>  header "over",over
 109              	>>  _header_ "over",over
 109              	>>>  .section .data
 109 03a4 98030000 	>>>  .int _thread
 109              	>>>  .set _thread,.
 109              	>>> 8:
 109              	>>>  hstring "over"
 109 03a8 04       	>>>>  .byte lex+9f-(.+1)
 109 03a9 6F766572 	>>>>  .ascii "over"
 109              	>>>> 9:
 109 03ad 000000   	>>>>  .balign 4,0
 109              	>>>  .set lex,0
 109 03b0 64050000 	>>>  .int over
 109              	>>>  .previous
 109 055e 0000     	>>  .balign 4,0
 109 0560 A8030000 	>>  .int _thread
 109              	> over:
 110 0564 01B4     	  push { r0 }
 111 0566 0198     	  ldr r0, [sp, #4]
 112              	  next
 112 0568 7047     	>  bx lr
 113              	
 114              	@ ------------------------------------------------------------------------
 115              	@ discard second item on stack
 116              	
 117              	@     ( n1 n2 --- n2 )
 118              	
 119              	code "nip", nip
 119              	>  header "nip",nip
 119              	>>  _header_ "nip",nip
 119              	>>>  .section .data
 119 03b4 A8030000 	>>>  .int _thread
 119              	>>>  .set _thread,.
 119              	>>> 8:
 119              	>>>  hstring "nip"
 119 03b8 03       	>>>>  .byte lex+9f-(.+1)
 119 03b9 6E6970   	>>>>  .ascii "nip"
 119              	>>>> 9:
 119              	>>>>  .balign 4,0
 119              	>>>  .set lex,0
 119 03bc 70050000 	>>>  .int nip
 119              	>>>  .previous
 119 056a 0000     	>>  .balign 4,0
 119 056c B8030000 	>>  .int _thread
 119              	> nip:
 120 0570 01B0     	  add sp, sp, #4
 121              	  next
 121 0572 7047     	>  bx lr
 122              	
 123              	@ ------------------------------------------------------------------------
 124              	@ copy top item of stack under second item
 125              	
 126              	@     ( n1 n2 --- n2 n1 n2 )
 127              	
 128              	code "tuck", tuck
 128              	>  header "tuck",tuck
 128              	>>  _header_ "tuck",tuck
 128              	>>>  .section .data
 128 03c0 B8030000 	>>>  .int _thread
 128              	>>>  .set _thread,.
 128              	>>> 8:
 128              	>>>  hstring "tuck"
 128 03c4 04       	>>>>  .byte lex+9f-(.+1)
 128 03c5 7475636B 	>>>>  .ascii "tuck"
 128              	>>>> 9:
 128 03c9 000000   	>>>>  .balign 4,0
 128              	>>>  .set lex,0
 128 03cc 78050000 	>>>  .int tuck
 128              	>>>  .previous
 128              	>>  .balign 4,0
 128 0574 C4030000 	>>  .int _thread
 128              	> tuck:
 129 0578 0099     	  ldr r1, [sp]
 130 057a 0090     	  str r0, [sp]
 131 057c 02B4     	  push { r1 }
 132              	  next
 132 057e 7047     	>  bx lr
 133              	
 134              	@ ------------------------------------------------------------------------
 135              	@ copy third item of stack out to top
 136              	
 137              	@     ( n1 n2 n3 --- n1 n2 n3 n1 )
 138              	
 139              	code "pluck", pluck
 139              	>  header "pluck",pluck
 139              	>>  _header_ "pluck",pluck
 139              	>>>  .section .data
 139 03d0 C4030000 	>>>  .int _thread
 139              	>>>  .set _thread,.
 139              	>>> 8:
 139              	>>>  hstring "pluck"
 139 03d4 05       	>>>>  .byte lex+9f-(.+1)
 139 03d5 706C7563 	>>>>  .ascii "pluck"
 139      6B
 139              	>>>> 9:
 139 03da 0000     	>>>>  .balign 4,0
 139              	>>>  .set lex,0
 139 03dc 84050000 	>>>  .int pluck
 139              	>>>  .previous
 139              	>>  .balign 4,0
 139 0580 D4030000 	>>  .int _thread
 139              	> pluck:
 140 0584 01B4     	  push { r0 }
 141 0586 0298     	  ldr r0, [sp, #8]
 142              	  next
 142 0588 7047     	>  bx lr
 143              	
 144              	@ ------------------------------------------------------------------------
 145              	@ copy n1th item of stack
 146              	
 147              	@     ( ... n1 --- n2 )
 148              	
 149              	code "pick", pick
 149              	>  header "pick",pick
 149              	>>  _header_ "pick",pick
 149              	>>>  .section .data
 149 03e0 D4030000 	>>>  .int _thread
 149              	>>>  .set _thread,.
 149              	>>> 8:
 149              	>>>  hstring "pick"
 149 03e4 04       	>>>>  .byte lex+9f-(.+1)
 149 03e5 7069636B 	>>>>  .ascii "pick"
 149              	>>>> 9:
 149 03e9 000000   	>>>>  .balign 4,0
 149              	>>>  .set lex,0
 149 03ec 90050000 	>>>  .int pick
 149              	>>>  .previous
 149 058a 0000     	>>  .balign 4,0
 149 058c E4030000 	>>  .int _thread
 149              	> pick:
 150 0590 5DF82000 	  ldr r0, [sp, r0, lsl #2]
 151              	  next
 151 0594 7047     	>  bx lr
 152              	
 153              	@ ------------------------------------------------------------------------
 154              	@ rotate third item of stack out to top
 155              	
 156              	@     ( n1 n2 n3 --- n2 n3 n1 )
 157              	
 158              	code "rot", rot
 158              	>  header "rot",rot
 158              	>>  _header_ "rot",rot
 158              	>>>  .section .data
 158 03f0 E4030000 	>>>  .int _thread
 158              	>>>  .set _thread,.
 158              	>>> 8:
 158              	>>>  hstring "rot"
 158 03f4 03       	>>>>  .byte lex+9f-(.+1)
 158 03f5 726F74   	>>>>  .ascii "rot"
 158              	>>>> 9:
 158              	>>>>  .balign 4,0
 158              	>>>  .set lex,0
 158 03f8 9C050000 	>>>  .int rot
 158              	>>>  .previous
 158 0596 0000     	>>  .balign 4,0
 158 0598 F4030000 	>>  .int _thread
 158              	> rot:
 159 059c 06BC     	  pop { r1, r2 }
 160 059e 03B4     	  push { r0, r1 }
 161 05a0 1000     	  movs r0, r2
 162              	  next
 162 05a2 7047     	>  bx lr
 163              	
 164              	@ ------------------------------------------------------------------------
 165              	@ rotate top item of stack down to third slot
 166              	
 167              	@     ( n1 n2 n3 --- n3 n1 n2 )
 168              	
 169              	code "-rot", drot
 169              	>  header "-rot",drot
 169              	>>  _header_ "-rot",drot
 169              	>>>  .section .data
 169 03fc F4030000 	>>>  .int _thread
 169              	>>>  .set _thread,.
 169              	>>> 8:
 169              	>>>  hstring "-rot"
 169 0400 04       	>>>>  .byte lex+9f-(.+1)
 169 0401 2D726F74 	>>>>  .ascii "-rot"
 169              	>>>> 9:
 169 0405 000000   	>>>>  .balign 4,0
 169              	>>>  .set lex,0
 169 0408 A8050000 	>>>  .int drot
 169              	>>>  .previous
 169              	>>  .balign 4,0
 169 05a4 00040000 	>>  .int _thread
 169              	> drot:
 170 05a8 0200     	  movs r2, r0
 171 05aa 03BC     	  pop { r0, r1 }
 172 05ac 06B4     	  push { r1, r2 }
 173              	  next
 173 05ae 7047     	>  bx lr
 174              	
 175              	@ ------------------------------------------------------------------------
 176              	@ move top item of parameter stack to the return stack
 177              	
 178              	@     ( n1 --- )
 179              	
 180              	code ">r", tor
 180              	>  header ">r",tor
 180              	>>  _header_ ">r",tor
 180              	>>>  .section .data
 180 040c 00040000 	>>>  .int _thread
 180              	>>>  .set _thread,.
 180              	>>> 8:
 180              	>>>  hstring ">r"
 180 0410 02       	>>>>  .byte lex+9f-(.+1)
 180 0411 3E72     	>>>>  .ascii ">r"
 180              	>>>> 9:
 180 0413 00       	>>>>  .balign 4,0
 180              	>>>  .set lex,0
 180 0414 B4050000 	>>>  .int tor
 180              	>>>  .previous
 180              	>>  .balign 4,0
 180 05b0 10040000 	>>  .int _thread
 180              	> tor:
 181              	  rpush r0
 181 05b4 4CF8040D 	>  str r0,[rp,#-4]!
 182 05b8 01BC     	  pop { r0 }
 183              	  next
 183 05ba 7047     	>  bx lr
 184              	
 185              	@ ------------------------------------------------------------------------
 186              	@ move top two items of stack to return stack
 187              	
 188              	@     ( n1 n2 --- )
 189              	
 190              	code "2>r", twotor
 190              	>  header "2>r",twotor
 190              	>>  _header_ "2>r",twotor
 190              	>>>  .section .data
 190 0418 10040000 	>>>  .int _thread
 190              	>>>  .set _thread,.
 190              	>>> 8:
 190              	>>>  hstring "2>r"
 190 041c 03       	>>>>  .byte lex+9f-(.+1)
 190 041d 323E72   	>>>>  .ascii "2>r"
 190              	>>>> 9:
 190              	>>>>  .balign 4,0
 190              	>>>  .set lex,0
 190 0420 C0050000 	>>>  .int twotor
 190              	>>>  .previous
 190              	>>  .balign 4,0
 190 05bc 1C040000 	>>  .int _thread
 190              	> twotor:
 191 05c0 06BC     	  pop { r1, r2 }
 192              	  rpush r0
 192 05c2 4CF8040D 	>  str r0,[rp,#-4]!
 193              	  rpush r1
 193 05c6 4CF8041D 	>  str r1,[rp,#-4]!
 194 05ca 1000     	  movs r0, r2
 195              	  next
 195 05cc 7047     	>  bx lr
 196              	
 197              	@ ------------------------------------------------------------------------
 198              	@ move top item of return stack to the parameter stack
 199              	
 200              	@     ( --- n1 )
 201              	
 202              	code "r>", rto
 202              	>  header "r>",rto
 202              	>>  _header_ "r>",rto
 202              	>>>  .section .data
 202 0424 1C040000 	>>>  .int _thread
 202              	>>>  .set _thread,.
 202              	>>> 8:
 202              	>>>  hstring "r>"
 202 0428 02       	>>>>  .byte lex+9f-(.+1)
 202 0429 723E     	>>>>  .ascii "r>"
 202              	>>>> 9:
 202 042b 00       	>>>>  .balign 4,0
 202              	>>>  .set lex,0
 202 042c D4050000 	>>>  .int rto
 202              	>>>  .previous
 202 05ce 0000     	>>  .balign 4,0
 202 05d0 28040000 	>>  .int _thread
 202              	> rto:
 203 05d4 01B4     	  push { r0 }
 204              	  rpop r0
 204 05d6 5CF8040B 	>  ldr r0,[rp],#4
 205              	  next
 205 05da 7047     	>  bx lr
 206              	
 207              	@ ------------------------------------------------------------------------
 208              	@ move top two items of return stack to the parameter stack
 209              	
 210              	@     ( --- n1 n2 )
 211              	
 212              	code "2r>", tworto
 212              	>  header "2r>",tworto
 212              	>>  _header_ "2r>",tworto
 212              	>>>  .section .data
 212 0430 28040000 	>>>  .int _thread
 212              	>>>  .set _thread,.
 212              	>>> 8:
 212              	>>>  hstring "2r>"
 212 0434 03       	>>>>  .byte lex+9f-(.+1)
 212 0435 32723E   	>>>>  .ascii "2r>"
 212              	>>>> 9:
 212              	>>>>  .balign 4,0
 212              	>>>  .set lex,0
 212 0438 E0050000 	>>>  .int tworto
 212              	>>>  .previous
 212              	>>  .balign 4,0
 212 05dc 34040000 	>>  .int _thread
 212              	> tworto:
 213 05e0 01B4     	  push { r0 }
 214 05e2 BCE80300 	  ldmia rp!, { r0, r1 }
 215 05e6 01B4     	  push { r0 }
 216 05e8 0846     	  mov r0, r1
 217              	  next
 217 05ea 7047     	>  bx lr
 218              	
 219              	@ ------------------------------------------------------------------------
 220              	@ copy top item of parameter stack to the return stack
 221              	
 222              	@     ( n1 --- n1 )
 223              	
 224              	code "dup>r", duptor
 224              	>  header "dup>r",duptor
 224              	>>  _header_ "dup>r",duptor
 224              	>>>  .section .data
 224 043c 34040000 	>>>  .int _thread
 224              	>>>  .set _thread,.
 224              	>>> 8:
 224              	>>>  hstring "dup>r"
 224 0440 05       	>>>>  .byte lex+9f-(.+1)
 224 0441 6475703E 	>>>>  .ascii "dup>r"
 224      72
 224              	>>>> 9:
 224 0446 0000     	>>>>  .balign 4,0
 224              	>>>  .set lex,0
 224 0448 F0050000 	>>>  .int duptor
 224              	>>>  .previous
 224              	>>  .balign 4,0
 224 05ec 40040000 	>>  .int _thread
 224              	> duptor:
 225              	  rpush r0
 225 05f0 4CF8040D 	>  str r0,[rp,#-4]!
 226              	  next
 226 05f4 7047     	>  bx lr
 227              	
 228              	@ ------------------------------------------------------------------------
 229              	
 230              	code "r>drop", rdrop
 230              	>  header "r>drop",rdrop
 230              	>>  _header_ "r>drop",rdrop
 230              	>>>  .section .data
 230 044c 40040000 	>>>  .int _thread
 230              	>>>  .set _thread,.
 230              	>>> 8:
 230              	>>>  hstring "r>drop"
 230 0450 06       	>>>>  .byte lex+9f-(.+1)
 230 0451 723E6472 	>>>>  .ascii "r>drop"
 230      6F70
 230              	>>>> 9:
 230 0457 00       	>>>>  .balign 4,0
 230              	>>>  .set lex,0
 230 0458 FC050000 	>>>  .int rdrop
 230              	>>>  .previous
 230 05f6 0000     	>>  .balign 4,0
 230 05f8 50040000 	>>  .int _thread
 230              	> rdrop:
 231 05fc 0CF1040C 	  add rp, rp, #4
 232              	  next
 232 0600 7047     	>  bx lr
 233              	
 234              	@ ------------------------------------------------------------------------
 235              	@ copy top item of return stack to the parameter stack
 236              	
 237              	@   ( --- n1 )
 238              	
 239              	code "r@", rfetch
 239              	>  header "r@",rfetch
 239              	>>  _header_ "r@",rfetch
 239              	>>>  .section .data
 239 045c 50040000 	>>>  .int _thread
 239              	>>>  .set _thread,.
 239              	>>> 8:
 239              	>>>  hstring "r@"
 239 0460 02       	>>>>  .byte lex+9f-(.+1)
 239 0461 7240     	>>>>  .ascii "r@"
 239              	>>>> 9:
 239 0463 00       	>>>>  .balign 4,0
 239              	>>>  .set lex,0
 239 0464 08060000 	>>>  .int rfetch
 239              	>>>  .previous
 239 0602 0000     	>>  .balign 4,0
 239 0604 60040000 	>>  .int _thread
 239              	> rfetch:
 240 0608 01B4     	  push { r0 }
 241 060a DCF80000 	  ldr r0, [rp]
 242              	  next
 242 060e 7047     	>  bx lr
 243              	
 244              	@ ------------------------------------------------------------------------
 245              	@ get address of parameter stack
 246              	
 247              	@     ( --- a1 )
 248              	
 249              	code "sp@", spfetch
 249              	>  header "sp@",spfetch
 249              	>>  _header_ "sp@",spfetch
 249              	>>>  .section .data
 249 0468 60040000 	>>>  .int _thread
 249              	>>>  .set _thread,.
 249              	>>> 8:
 249              	>>>  hstring "sp@"
 249 046c 03       	>>>>  .byte lex+9f-(.+1)
 249 046d 737040   	>>>>  .ascii "sp@"
 249              	>>>> 9:
 249              	>>>>  .balign 4,0
 249              	>>>  .set lex,0
 249 0470 14060000 	>>>  .int spfetch
 249              	>>>  .previous
 249              	>>  .balign 4,0
 249 0610 6C040000 	>>  .int _thread
 249              	> spfetch:
 250 0614 01B4     	  push { r0 }
 251 0616 6846     	  mov r0, sp
 252              	  next
 252 0618 7047     	>  bx lr
 253              	
 254              	@ ------------------------------------------------------------------------
 255              	@ set address of parameter stack
 256              	
 257              	@     ( a1 --- )
 258              	
 259              	code "sp!", spstore
 259              	>  header "sp!",spstore
 259              	>>  _header_ "sp!",spstore
 259              	>>>  .section .data
 259 0474 6C040000 	>>>  .int _thread
 259              	>>>  .set _thread,.
 259              	>>> 8:
 259              	>>>  hstring "sp!"
 259 0478 03       	>>>>  .byte lex+9f-(.+1)
 259 0479 737021   	>>>>  .ascii "sp!"
 259              	>>>> 9:
 259              	>>>>  .balign 4,0
 259              	>>>  .set lex,0
 259 047c 20060000 	>>>  .int spstore
 259              	>>>  .previous
 259 061a 0000     	>>  .balign 4,0
 259 061c 78040000 	>>  .int _thread
 259              	> spstore:
 260 0620 8546     	  mov sp, r0
 261 0622 01BC     	  pop { r0 }
 262              	  next
 262 0624 7047     	>  bx lr
 263              	
 264              	@ ------------------------------------------------------------------------
 265              	@ get address of return stack
 266              	
 267              	@     ( --- a1 )
 268              	
 269              	code "rp@", rpfetch
 269              	>  header "rp@",rpfetch
 269              	>>  _header_ "rp@",rpfetch
 269              	>>>  .section .data
 269 0480 78040000 	>>>  .int _thread
 269              	>>>  .set _thread,.
 269              	>>> 8:
 269              	>>>  hstring "rp@"
 269 0484 03       	>>>>  .byte lex+9f-(.+1)
 269 0485 727040   	>>>>  .ascii "rp@"
 269              	>>>> 9:
 269              	>>>>  .balign 4,0
 269              	>>>  .set lex,0
 269 0488 2C060000 	>>>  .int rpfetch
 269              	>>>  .previous
 269 0626 0000     	>>  .balign 4,0
 269 0628 84040000 	>>  .int _thread
 269              	> rpfetch:
 270 062c 01B4     	  push { r0 }
 271 062e 6046     	  mov r0, rp
 272              	  next
 272 0630 7047     	>  bx lr
 273              	
 274              	@ ------------------------------------------------------------------------
 275              	@ set address of return stack
 276              	
 277              	@     ( a1 --- )
 278              	
 279              	code "rp!", rpstore
 279              	>  header "rp!",rpstore
 279              	>>  _header_ "rp!",rpstore
 279              	>>>  .section .data
 279 048c 84040000 	>>>  .int _thread
 279              	>>>  .set _thread,.
 279              	>>> 8:
 279              	>>>  hstring "rp!"
 279 0490 03       	>>>>  .byte lex+9f-(.+1)
 279 0491 727021   	>>>>  .ascii "rp!"
 279              	>>>> 9:
 279              	>>>>  .balign 4,0
 279              	>>>  .set lex,0
 279 0494 38060000 	>>>  .int rpstore
 279              	>>>  .previous
 279 0632 0000     	>>  .balign 4,0
 279 0634 90040000 	>>  .int _thread
 279              	> rpstore:
 280 0638 8446     	  mov rp, r0
 281 063a 01BC     	  pop { r0 }
 282              	  next
 282 063c 7047     	>  bx lr
 283              	
 284              	@ ------------------------------------------------------------------------
 285              	@ not sure where this really belongs (math.s ?)
 286              	
 287              	@     ( n1 --- lo hi )
 288              	
 289              	code "split", split
 289              	>  header "split",split
 289              	>>  _header_ "split",split
 289              	>>>  .section .data
 289 0498 90040000 	>>>  .int _thread
 289              	>>>  .set _thread,.
 289              	>>> 8:
 289              	>>>  hstring "split"
 289 049c 05       	>>>>  .byte lex+9f-(.+1)
 289 049d 73706C69 	>>>>  .ascii "split"
 289      74
 289              	>>>> 9:
 289 04a2 0000     	>>>>  .balign 4,0
 289              	>>>  .set lex,0
 289 04a4 44060000 	>>>  .int split
 289              	>>>  .previous
 289 063e 0000     	>>  .balign 4,0
 289 0640 9C040000 	>>  .int _thread
 289              	> split:
 290 0644 C0F30F41 	  ubfx r1, r0, #16, #16
 291 0648 C0F30F00 	  ubfx r0, r0, #0, #16
 292 064c 02B4     	  push { r1 }
 293              	  next
 293 064e 7047     	>  bx lr
 294              	
 295              	@ ------------------------------------------------------------------------
 296              	
 297              	@     ( lo hi --- n1 )
 298              	
 299              	code "join", join
 299              	>  header "join",join
 299              	>>  _header_ "join",join
 299              	>>>  .section .data
 299 04a8 9C040000 	>>>  .int _thread
 299              	>>>  .set _thread,.
 299              	>>> 8:
 299              	>>>  hstring "join"
 299 04ac 04       	>>>>  .byte lex+9f-(.+1)
 299 04ad 6A6F696E 	>>>>  .ascii "join"
 299              	>>>> 9:
 299 04b1 000000   	>>>>  .balign 4,0
 299              	>>>  .set lex,0
 299 04b4 54060000 	>>>  .int join
 299              	>>>  .previous
 299              	>>  .balign 4,0
 299 0650 AC040000 	>>  .int _thread
 299              	> join:
 300 0654 02BC     	  pop { r1 }
 301 0656 01EB0040 	  add r0, r1, r0, lsl #16
 302              	  next
 302 065a 7047     	>  bx lr
 303              	
 304              	@ ------------------------------------------------------------------------
 305              	@ get number of items on parameter stack
 306              	
 307              	colon "depth", depth
 307              	>  header "depth",depth
 307              	>>  _header_ "depth",depth
 307              	>>>  .section .data
 307 04b8 AC040000 	>>>  .int _thread
 307              	>>>  .set _thread,.
 307              	>>> 8:
 307              	>>>  hstring "depth"
 307 04bc 05       	>>>>  .byte lex+9f-(.+1)
 307 04bd 64657074 	>>>>  .ascii "depth"
 307      68
 307              	>>>> 9:
 307 04c2 0000     	>>>>  .balign 4,0
 307              	>>>  .set lex,0
 307 04c4 60060000 	>>>  .int depth
 307              	>>>  .previous
 307              	>>  .balign 4,0
 307 065c BC040000 	>>  .int _thread
 307              	> depth:
 307 0660 AFF30080 	>  nop.w
 307              	>  rpush lr
 307 0664 4CF804ED 	>>  str lr,[rp,#-4]!
 308 0668 FFF7D4FF 	  bl spfetch
 309 066c FFF734FF 	  bl sp0
 310 0670 FFF75AFF 	  bl swap
 311 0674 00F086FA 	  bl minus
 312 0678 8010     	  asrs r0, #2
 313              	  exit
 313              	>  rpop pc
 313 067a 5CF804FB 	>>  ldr pc,[rp],#4
 314              	
 315              	@ ------------------------------------------------------------------------
 316              	
 317              	colon ".under", dotunder
 317              	>  header ".under",dotunder
 317              	>>  _header_ ".under",dotunder
 317              	>>>  .section .data
 317 04c8 BC040000 	>>>  .int _thread
 317              	>>>  .set _thread,.
 317              	>>> 8:
 317              	>>>  hstring ".under"
 317 04cc 06       	>>>>  .byte lex+9f-(.+1)
 317 04cd 2E756E64 	>>>>  .ascii ".under"
 317      6572
 317              	>>>> 9:
 317 04d3 00       	>>>>  .balign 4,0
 317              	>>>  .set lex,0
 317 04d4 84060000 	>>>  .int dotunder
 317              	>>>  .previous
 317 067e 0000     	>>  .balign 4,0
 317 0680 CC040000 	>>  .int _thread
 317              	> dotunder:
 317 0684 AFF30080 	>  nop.w
 317              	>  rpush lr
 317 0688 4CF804ED 	>>  str lr,[rp,#-4]!
 318 068c 00F0FEFD 	  bl pdotq
 319              	  hstring "Stack Underflow!"
 319 0690 10       	>  .byte lex+9f-(.+1)
 319 0691 53746163 	>  .ascii "Stack Underflow!"
 319      6B20556E 
 319      64657266 
 319      6C6F7721 
 319              	> 9:
 319 06a1 000000   	>  .balign 4,0
 320 06a4 01F04EF8 	  bl abort
 321              	
 322              	@ ------------------------------------------------------------------------
 323              	
 324              	colon ".over", dotover
 324              	>  header ".over",dotover
 324              	>>  _header_ ".over",dotover
 324              	>>>  .section .data
 324 04d8 CC040000 	>>>  .int _thread
 324              	>>>  .set _thread,.
 324              	>>> 8:
 324              	>>>  hstring ".over"
 324 04dc 05       	>>>>  .byte lex+9f-(.+1)
 324 04dd 2E6F7665 	>>>>  .ascii ".over"
 324      72
 324              	>>>> 9:
 324 04e2 0000     	>>>>  .balign 4,0
 324              	>>>  .set lex,0
 324 04e4 AC060000 	>>>  .int dotover
 324              	>>>  .previous
 324              	>>  .balign 4,0
 324 06a8 DC040000 	>>  .int _thread
 324              	> dotover:
 324 06ac AFF30080 	>  nop.w
 324              	>  rpush lr
 324 06b0 4CF804ED 	>>  str lr,[rp,#-4]!
 325 06b4 00F0EAFD 	  bl pdotq
 326              	  hstring "Stack Overflow!"
 326 06b8 0F       	>  .byte lex+9f-(.+1)
 326 06b9 53746163 	>  .ascii "Stack Overflow!"
 326      6B204F76 
 326      6572666C 
 326      6F7721
 326              	> 9:
 326              	>  .balign 4,0
 327 06c8 01F03CF8 	  bl abort
 328              	
 329              	@ ------------------------------------------------------------------------
 330              	
 331              	colon "?stack", qstack
 331              	>  header "?stack",qstack
 331              	>>  _header_ "?stack",qstack
 331              	>>>  .section .data
 331 04e8 DC040000 	>>>  .int _thread
 331              	>>>  .set _thread,.
 331              	>>> 8:
 331              	>>>  hstring "?stack"
 331 04ec 06       	>>>>  .byte lex+9f-(.+1)
 331 04ed 3F737461 	>>>>  .ascii "?stack"
 331      636B
 331              	>>>> 9:
 331 04f3 00       	>>>>  .balign 4,0
 331              	>>>  .set lex,0
 331 04f4 D0060000 	>>>  .int qstack
 331              	>>>  .previous
 331              	>>  .balign 4,0
 331 06cc EC040000 	>>  .int _thread
 331              	> qstack:
 331 06d0 AFF30080 	>  nop.w
 331              	>  rpush lr
 331 06d4 4CF804ED 	>>  str lr,[rp,#-4]!
 332 06d8 FFF79CFF 	  bl spfetch                @ get current stack pointer address
 333 06dc FFF7FCFE 	  bl sp0                    @ get address of bottom of stack
 334 06e0 00F038FC 	  bl ugreater               @ make sure we are below this address
 335 06e4 01F0C2FB 	  bl qbranch
 336 06e8 0700     	  .hword (1f - .) + 1
 337 06ea FFF7CBFF 	  bl dotunder
 338              	
 339              	1:
 340 06ee FFF79DFF 	  bl rpfetch                @ get current return stack pointer address
 341 06f2 FFF7F9FE 	  bl rp0                    @ get address of bottom of return stack
 342 06f6 00F02DFC 	  bl ugreater               @ make sure we are below this address
 343 06fa 01F0B7FB 	  bl qbranch
 344 06fe 0700     	  .hword (2f - .) + 1
 345 0700 FFF7C0FF 	  bl dotunder
 346              	
 347              	2:
 348 0704 FFF792FF 	  bl rpfetch                @ get currrent return stack pointer address
 349 0708 FFF7EEFE 	  bl rp0                    @ get address of top of return stack
 350              	  wliteral 0x1000           @ if you need more than 4k of return stack then
 350 070c 01B4     	>  push { r0 }
 350 070e 41F20000 	>  movw r0,#0x1000
 351 0712 00F037FA 	  bl minus                  @ what you really need is a different job! :)
 352 0716 00F01DFC 	  bl ugreater               @ make sure we are above this address
 353              	@bl not
 354 071a FFF715FE 	  bl qexit
 355 071e FFF7B1FF 	  bl dotunder
 356              	
 357              	  exit
 357              	>  rpop pc
 357 0722 5CF804FB 	>>  ldr pc,[rp],#4
 358              	
 359              	@ ========================================================================
 313              	  .include "memory.s"       @ fetch, store etc
   1              	@ memory.s
   2              	@ ------------------------------------------------------------------------
   3              	
   4              	@ ------------------------------------------------------------------------
   5              	
   6              	  _constant_ "cell", cell, 4
   6              	>  header "cell",cell
   6              	>>  _header_ "cell",cell
   6              	>>>  .section .data
   6 04f8 EC040000 	>>>  .int _thread
   6              	>>>  .set _thread,.
   6              	>>> 8:
   6              	>>>  hstring "cell"
   6 04fc 04       	>>>>  .byte lex+9f-(.+1)
   6 04fd 63656C6C 	>>>>  .ascii "cell"
   6              	>>>> 9:
   6 0501 000000   	>>>>  .balign 4,0
   6              	>>>  .set lex,0
   6 0504 2C070000 	>>>  .int cell
   6              	>>>  .previous
   6 0726 0000     	>>  .balign 4,0
   6 0728 FC040000 	>>  .int _thread
   6              	> cell:
   6              	>  rpush lr
   6 072c 4CF804ED 	>>  str lr,[rp,#-4]!
   6 0730 FFF722FE 	>  bl dovar
   6 0734 04000000 	>  .int 4
   7              	
   8              	@ ------------------------------------------------------------------------
   9              	
  10              	  _alias_ "cell+", fourplus,  cellplus
  10              	>  .set lex,ALIAS
  10              	>  _header_ "cell+",fourplus
  10              	>>  .section .data
  10 0508 FC040000 	>>  .int _thread
  10              	>>  .set _thread,.
  10              	>> 8:
  10              	>>  hstring "cell+"
  10 050c 45       	>>>  .byte lex+9f-(.+1)
  10 050d 63656C6C 	>>>  .ascii "cell+"
  10      2B
  10              	>>> 9:
  10 0512 0000     	>>>  .balign 4,0
  10              	>>  .set lex,0
  10 0514 240C0000 	>>  .int fourplus
  10              	>>  .previous
  10              	>  .set cellplus,fourplus
  11              	  _alias_ "cell-", fourminus, cellminus
  11              	>  .set lex,ALIAS
  11              	>  _header_ "cell-",fourminus
  11              	>>  .section .data
  11 0518 0C050000 	>>  .int _thread
  11              	>>  .set _thread,.
  11              	>> 8:
  11              	>>  hstring "cell-"
  11 051c 45       	>>>  .byte lex+9f-(.+1)
  11 051d 63656C6C 	>>>  .ascii "cell-"
  11      2D
  11              	>>> 9:
  11 0522 0000     	>>>  .balign 4,0
  11              	>>  .set lex,0
  11 0524 2C0C0000 	>>  .int fourminus
  11              	>>  .previous
  11              	>  .set cellminus,fourminus
  12              	  _alias_ "cells", fourstar,  cells
  12              	>  .set lex,ALIAS
  12              	>  _header_ "cells",fourstar
  12              	>>  .section .data
  12 0528 1C050000 	>>  .int _thread
  12              	>>  .set _thread,.
  12              	>> 8:
  12              	>>  hstring "cells"
  12 052c 45       	>>>  .byte lex+9f-(.+1)
  12 052d 63656C6C 	>>>  .ascii "cells"
  12      73
  12              	>>> 9:
  12 0532 0000     	>>>  .balign 4,0
  12              	>>  .set lex,0
  12 0534 D40B0000 	>>  .int fourstar
  12              	>>  .previous
  12              	>  .set cells,fourstar
  13              	
  14              	@ ------------------------------------------------------------------------
  15              	
  16              	code "cell/", cellslash
  16              	>  header "cell/",cellslash
  16              	>>  _header_ "cell/",cellslash
  16              	>>>  .section .data
  16 0538 2C050000 	>>>  .int _thread
  16              	>>>  .set _thread,.
  16              	>>> 8:
  16              	>>>  hstring "cell/"
  16 053c 05       	>>>>  .byte lex+9f-(.+1)
  16 053d 63656C6C 	>>>>  .ascii "cell/"
  16      2F
  16              	>>>> 9:
  16 0542 0000     	>>>>  .balign 4,0
  16              	>>>  .set lex,0
  16 0544 3C070000 	>>>  .int cellslash
  16              	>>>  .previous
  16              	>>  .balign 4,0
  16 0738 3C050000 	>>  .int _thread
  16              	> cellslash:
  17 073c 8008     	  lsrs r0, #2
  18              	  next
  18 073e 7047     	>  bx lr
  19              	
  20              	@ ------------------------------------------------------------------------
  21              	@ compute address of cell indexed into array
  22              	
  23              	@     ( array index --- a1 )
  24              	
  25              	code "[]", cells_plus
  25              	>  header "[]",cells_plus
  25              	>>  _header_ "[]",cells_plus
  25              	>>>  .section .data
  25 0548 3C050000 	>>>  .int _thread
  25              	>>>  .set _thread,.
  25              	>>> 8:
  25              	>>>  hstring "[]"
  25 054c 02       	>>>>  .byte lex+9f-(.+1)
  25 054d 5B5D     	>>>>  .ascii "[]"
  25              	>>>> 9:
  25 054f 00       	>>>>  .balign 4,0
  25              	>>>  .set lex,0
  25 0550 44070000 	>>>  .int cells_plus
  25              	>>>  .previous
  25              	>>  .balign 4,0
  25 0740 4C050000 	>>  .int _thread
  25              	> cells_plus:
  26 0744 02BC     	  pop { r1 }
  27 0746 01EB8000 	  add r0, r1, r0, lsl #2
  28              	  next
  28 074a 7047     	>  bx lr
  29              	
  30              	@ ------------------------------------------------------------------------
  31              	
  32              	code "[w]", wplus
  32              	>  header "[w]",wplus
  32              	>>  _header_ "[w]",wplus
  32              	>>>  .section .data
  32 0554 4C050000 	>>>  .int _thread
  32              	>>>  .set _thread,.
  32              	>>> 8:
  32              	>>>  hstring "[w]"
  32 0558 03       	>>>>  .byte lex+9f-(.+1)
  32 0559 5B775D   	>>>>  .ascii "[w]"
  32              	>>>> 9:
  32              	>>>>  .balign 4,0
  32              	>>>  .set lex,0
  32 055c 50070000 	>>>  .int wplus
  32              	>>>  .previous
  32              	>>  .balign 4,0
  32 074c 58050000 	>>  .int _thread
  32              	> wplus:
  33 0750 02BC     	  pop { r1 }
  34 0752 01EB4000 	  add r0, r1, r0, lsl #1
  35              	  next
  35 0756 7047     	>  bx lr
  36              	
  37              	@ ------------------------------------------------------------------------
  38              	@ fetch indexed cell of specified array
  39              	
  40              	@     ( array index --- n1 )
  41              	
  42              	code "[]@", cells_fetch
  42              	>  header "[]@",cells_fetch
  42              	>>  _header_ "[]@",cells_fetch
  42              	>>>  .section .data
  42 0560 58050000 	>>>  .int _thread
  42              	>>>  .set _thread,.
  42              	>>> 8:
  42              	>>>  hstring "[]@"
  42 0564 03       	>>>>  .byte lex+9f-(.+1)
  42 0565 5B5D40   	>>>>  .ascii "[]@"
  42              	>>>> 9:
  42              	>>>>  .balign 4,0
  42              	>>>  .set lex,0
  42 0568 5C070000 	>>>  .int cells_fetch
  42              	>>>  .previous
  42              	>>  .balign 4,0
  42 0758 64050000 	>>  .int _thread
  42              	> cells_fetch:
  43 075c 02BC     	  pop { r1 }
  44 075e 01EB8001 	  add r1, r1, r0, lsl #2
  45 0762 0888     	  ldrh r0, [r1]
  46 0764 4988     	  ldrh r1, [r1, #2]
  47 0766 00EB0140 	  add r0, r0, r1, lsl #16
  48              	  next
  48 076a 7047     	>  bx lr
  49              	
  50              	@ ------------------------------------------------------------------------
  51              	@ store data at indexed cell of array
  52              	
  53              	@     ( n1 array index --- )
  54              	
  55              	code "[]!", cells_store
  55              	>  header "[]!",cells_store
  55              	>>  _header_ "[]!",cells_store
  55              	>>>  .section .data
  55 056c 64050000 	>>>  .int _thread
  55              	>>>  .set _thread,.
  55              	>>> 8:
  55              	>>>  hstring "[]!"
  55 0570 03       	>>>>  .byte lex+9f-(.+1)
  55 0571 5B5D21   	>>>>  .ascii "[]!"
  55              	>>>> 9:
  55              	>>>>  .balign 4,0
  55              	>>>  .set lex,0
  55 0574 70070000 	>>>  .int cells_store
  55              	>>>  .previous
  55              	>>  .balign 4,0
  55 076c 70050000 	>>  .int _thread
  55              	> cells_store:
  56 0770 0EBC     	  pop { r1, r2, r3 }
  57 0772 01EB8001 	  add r1, r1, r0, lsl #2
  58 0776 0A80     	  strh r2, [r1]
  59 0778 120C     	  lsrs r2, #16
  60 077a 4A80     	  strh r2, [r1, #2]
  61 077c 1846     	  mov r0, r3
  62              	  next
  62 077e 7047     	>  bx lr
  63              	
  64              	@ ------------------------------------------------------------------------
  65              	
  66              	@     ( array index --- w1 )
  67              	
  68              	code "[w]@", wxfetch
  68              	>  header "[w]@",wxfetch
  68              	>>  _header_ "[w]@",wxfetch
  68              	>>>  .section .data
  68 0578 70050000 	>>>  .int _thread
  68              	>>>  .set _thread,.
  68              	>>> 8:
  68              	>>>  hstring "[w]@"
  68 057c 04       	>>>>  .byte lex+9f-(.+1)
  68 057d 5B775D40 	>>>>  .ascii "[w]@"
  68              	>>>> 9:
  68 0581 000000   	>>>>  .balign 4,0
  68              	>>>  .set lex,0
  68 0584 84070000 	>>>  .int wxfetch
  68              	>>>  .previous
  68              	>>  .balign 4,0
  68 0780 7C050000 	>>  .int _thread
  68              	> wxfetch:
  69 0784 02BC     	  pop { r1 }
  70 0786 31F81000 	  ldrh r0, [r1, r0, lsl #1]
  71              	  next
  71 078a 7047     	>  bx lr
  72              	
  73              	@ ------------------------------------------------------------------------
  74              	
  75              	@   ( w1 array index --- )
  76              	
  77              	code "[w]!", wxstore
  77              	>  header "[w]!",wxstore
  77              	>>  _header_ "[w]!",wxstore
  77              	>>>  .section .data
  77 0588 7C050000 	>>>  .int _thread
  77              	>>>  .set _thread,.
  77              	>>> 8:
  77              	>>>  hstring "[w]!"
  77 058c 04       	>>>>  .byte lex+9f-(.+1)
  77 058d 5B775D21 	>>>>  .ascii "[w]!"
  77              	>>>> 9:
  77 0591 000000   	>>>>  .balign 4,0
  77              	>>>  .set lex,0
  77 0594 90070000 	>>>  .int wxstore
  77              	>>>  .previous
  77              	>>  .balign 4,0
  77 078c 8C050000 	>>  .int _thread
  77              	> wxstore:
  78 0790 0EBC     	  pop { r1, r2, r3 }
  79 0792 21F81020 	  strh r2, [r1, r0, lsl #1]
  80 0796 1846     	  mov r0, r3
  81              	  next
  81 0798 7047     	>  bx lr
  82              	
  83              	@ ------------------------------------------------------------------------
  84              	
  85              	code "[c]@", cxfetch
  85              	>  header "[c]@",cxfetch
  85              	>>  _header_ "[c]@",cxfetch
  85              	>>>  .section .data
  85 0598 8C050000 	>>>  .int _thread
  85              	>>>  .set _thread,.
  85              	>>> 8:
  85              	>>>  hstring "[c]@"
  85 059c 04       	>>>>  .byte lex+9f-(.+1)
  85 059d 5B635D40 	>>>>  .ascii "[c]@"
  85              	>>>> 9:
  85 05a1 000000   	>>>>  .balign 4,0
  85              	>>>  .set lex,0
  85 05a4 A0070000 	>>>  .int cxfetch
  85              	>>>  .previous
  85 079a 0000     	>>  .balign 4,0
  85 079c 9C050000 	>>  .int _thread
  85              	> cxfetch:
  86 07a0 02BC     	  pop { r1 }
  87 07a2 405C     	  ldrb r0, [r0, r1]
  88              	  next
  88 07a4 7047     	>  bx lr
  89              	
  90              	@ ------------------------------------------------------------------------
  91              	
  92              	code "[c]!", cxstore
  92              	>  header "[c]!",cxstore
  92              	>>  _header_ "[c]!",cxstore
  92              	>>>  .section .data
  92 05a8 9C050000 	>>>  .int _thread
  92              	>>>  .set _thread,.
  92              	>>> 8:
  92              	>>>  hstring "[c]!"
  92 05ac 04       	>>>>  .byte lex+9f-(.+1)
  92 05ad 5B635D21 	>>>>  .ascii "[c]!"
  92              	>>>> 9:
  92 05b1 000000   	>>>>  .balign 4,0
  92              	>>>  .set lex,0
  92 05b4 AC070000 	>>>  .int cxstore
  92              	>>>  .previous
  92 07a6 0000     	>>  .balign 4,0
  92 07a8 AC050000 	>>  .int _thread
  92              	> cxstore:
  93 07ac 0EBC     	  pop { r1, r2, r3 }
  94 07ae 4254     	  strb r2, [r0, r1]
  95 07b0 1846     	  mov r0, r3
  96              	  next
  96 07b2 7047     	>  bx lr
  97              	
  98              	@ ------------------------------------------------------------------------
  99              	@ part of the memory manager extension
 100              	
 101              	@ returns contents of specified address then increments contents for
 102              	@ next read ... dup @ swap incr
 103              	
 104              	@     ( a1 --- n1 )
 105              	
 106              	code "@^", fetch_up
 106              	>  header "@^",fetch_up
 106              	>>  _header_ "@^",fetch_up
 106              	>>>  .section .data
 106 05b8 AC050000 	>>>  .int _thread
 106              	>>>  .set _thread,.
 106              	>>> 8:
 106              	>>>  hstring "@^"
 106 05bc 02       	>>>>  .byte lex+9f-(.+1)
 106 05bd 405E     	>>>>  .ascii "@^"
 106              	>>>> 9:
 106 05bf 00       	>>>>  .balign 4,0
 106              	>>>  .set lex,0
 106 05c0 B8070000 	>>>  .int fetch_up
 106              	>>>  .previous
 106              	>>  .balign 4,0
 106 07b4 BC050000 	>>  .int _thread
 106              	> fetch_up:
 107 07b8 0168     	  ldr r1, [r0]                  @ r1 = variable contents
 108 07ba 4B1C     	  adds r3, r1, #1               @ r1 = var + 1
 109 07bc 0360     	  str r3, [r0]                  @ var = var + 1
 110 07be 0846     	  mov r0, r1                    @ return unincremented value of var
 111              	  next
 111 07c0 7047     	>  bx lr
 112              	
 113              	@ ------------------------------------------------------------------------
 114              	
 115              	@     ( a1 --- n1 )
 116              	
 117              	code "@", fetch
 117              	>  header "@",fetch
 117              	>>  _header_ "@",fetch
 117              	>>>  .section .data
 117 05c4 BC050000 	>>>  .int _thread
 117              	>>>  .set _thread,.
 117              	>>> 8:
 117              	>>>  hstring "@"
 117 05c8 01       	>>>>  .byte lex+9f-(.+1)
 117 05c9 40       	>>>>  .ascii "@"
 117              	>>>> 9:
 117 05ca 0000     	>>>>  .balign 4,0
 117              	>>>  .set lex,0
 117 05cc C8070000 	>>>  .int fetch
 117              	>>>  .previous
 117 07c2 0000     	>>  .balign 4,0
 117 07c4 C8050000 	>>  .int _thread
 117              	> fetch:
 118 07c8 0188     	  ldrh r1, [r0]
 119 07ca 4088     	  ldrh r0, [r0, #2]
 120 07cc 01EB0040 	  add r0, r1, r0, lsl #16
 121              	  next
 121 07d0 7047     	>  bx lr
 122              	
 123              	@ ------------------------------------------------------------------------
 124              	
 125              	@     ( n1 a1 --- )
 126              	
 127              	code "!", store
 127              	>  header "!",store
 127              	>>  _header_ "!",store
 127              	>>>  .section .data
 127 05d0 C8050000 	>>>  .int _thread
 127              	>>>  .set _thread,.
 127              	>>> 8:
 127              	>>>  hstring "!"
 127 05d4 01       	>>>>  .byte lex+9f-(.+1)
 127 05d5 21       	>>>>  .ascii "!"
 127              	>>>> 9:
 127 05d6 0000     	>>>>  .balign 4,0
 127              	>>>  .set lex,0
 127 05d8 D8070000 	>>>  .int store
 127              	>>>  .previous
 127 07d2 0000     	>>  .balign 4,0
 127 07d4 D4050000 	>>  .int _thread
 127              	> store:
 128 07d8 06BC     	  pop { r1, r2 }
 129 07da 0180     	  strh r1, [r0]
 130 07dc 090C     	  lsrs r1, #16
 131 07de 4180     	  strh r1, [r0, #2]
 132 07e0 1000     	  movs r0, r2
 133              	  next
 133 07e2 7047     	>  bx lr
 134              	
 135              	@ ------------------------------------------------------------------------
 136              	
 137              	@     ( a1 --- c1 )
 138              	
 139              	code "c@", cfetch
 139              	>  header "c@",cfetch
 139              	>>  _header_ "c@",cfetch
 139              	>>>  .section .data
 139 05dc D4050000 	>>>  .int _thread
 139              	>>>  .set _thread,.
 139              	>>> 8:
 139              	>>>  hstring "c@"
 139 05e0 02       	>>>>  .byte lex+9f-(.+1)
 139 05e1 6340     	>>>>  .ascii "c@"
 139              	>>>> 9:
 139 05e3 00       	>>>>  .balign 4,0
 139              	>>>  .set lex,0
 139 05e4 E8070000 	>>>  .int cfetch
 139              	>>>  .previous
 139              	>>  .balign 4,0
 139 07e4 E0050000 	>>  .int _thread
 139              	> cfetch:
 140 07e8 0078     	  ldrb r0, [r0]
 141              	  next
 141 07ea 7047     	>  bx lr
 142              	
 143              	@ ------------------------------------------------------------------------
 144              	
 145              	@     ( c1 a1 --- )
 146              	
 147              	code "c!", cstore
 147              	>  header "c!",cstore
 147              	>>  _header_ "c!",cstore
 147              	>>>  .section .data
 147 05e8 E0050000 	>>>  .int _thread
 147              	>>>  .set _thread,.
 147              	>>> 8:
 147              	>>>  hstring "c!"
 147 05ec 02       	>>>>  .byte lex+9f-(.+1)
 147 05ed 6321     	>>>>  .ascii "c!"
 147              	>>>> 9:
 147 05ef 00       	>>>>  .balign 4,0
 147              	>>>  .set lex,0
 147 05f0 F0070000 	>>>  .int cstore
 147              	>>>  .previous
 147              	>>  .balign 4,0
 147 07ec EC050000 	>>  .int _thread
 147              	> cstore:
 148 07f0 06BC     	  pop { r1, r2 }
 149 07f2 0170     	  strb r1, [r0]
 150 07f4 1046     	  mov r0, r2
 151              	  next
 151 07f6 7047     	>  bx lr
 152              	
 153              	@ ------------------------------------------------------------------------
 154              	
 155              	@     ( a1 --- w1 )
 156              	
 157              	code "w@", wfetch
 157              	>  header "w@",wfetch
 157              	>>  _header_ "w@",wfetch
 157              	>>>  .section .data
 157 05f4 EC050000 	>>>  .int _thread
 157              	>>>  .set _thread,.
 157              	>>> 8:
 157              	>>>  hstring "w@"
 157 05f8 02       	>>>>  .byte lex+9f-(.+1)
 157 05f9 7740     	>>>>  .ascii "w@"
 157              	>>>> 9:
 157 05fb 00       	>>>>  .balign 4,0
 157              	>>>  .set lex,0
 157 05fc FC070000 	>>>  .int wfetch
 157              	>>>  .previous
 157              	>>  .balign 4,0
 157 07f8 F8050000 	>>  .int _thread
 157              	> wfetch:
 158 07fc 0088     	  ldrh r0, [r0]
 159              	  next
 159 07fe 7047     	>  bx lr
 160              	
 161              	@ ------------------------------------------------------------------------
 162              	
 163              	@     ( w1 a1 --- )
 164              	
 165              	code "w!", wstore
 165              	>  header "w!",wstore
 165              	>>  _header_ "w!",wstore
 165              	>>>  .section .data
 165 0600 F8050000 	>>>  .int _thread
 165              	>>>  .set _thread,.
 165              	>>> 8:
 165              	>>>  hstring "w!"
 165 0604 02       	>>>>  .byte lex+9f-(.+1)
 165 0605 7721     	>>>>  .ascii "w!"
 165              	>>>> 9:
 165 0607 00       	>>>>  .balign 4,0
 165              	>>>  .set lex,0
 165 0608 04080000 	>>>  .int wstore
 165              	>>>  .previous
 165              	>>  .balign 4,0
 165 0800 04060000 	>>  .int _thread
 165              	> wstore:
 166 0804 06BC     	  pop { r1, r2 }
 167 0806 0180     	  strh r1, [r0]
 168 0808 1046     	  mov r0, r2
 169              	  next
 169 080a 7047     	>  bx lr
 170              	
 171              	@ ------------------------------------------------------------------------
 172              	
 173              	@       ( n1 --- )
 174              	
 175              	code "\%!>", zstoreto
 175              	>  header "\%!>",zstoreto
 175              	>>  _header_ "\%!>",zstoreto
 175              	>>>  .section .data
 175 060c 04060000 	>>>  .int _thread
 175              	>>>  .set _thread,.
 175              	>>> 8:
 175              	>>>  hstring "\%!>"
 175 0610 03       	>>>>  .byte lex+9f-(.+1)
 175 0611 25213E   	>>>>  .ascii "\%!>"
 175              	>>>> 9:
 175              	>>>>  .balign 4,0
 175              	>>>  .set lex,0
 175 0614 10080000 	>>>  .int zstoreto
 175              	>>>  .previous
 175              	>>  .balign 4,0
 175 080c 10060000 	>>  .int _thread
 175              	> zstoreto:
 176 0810 2EF0010E 	  bic lr, #1
 177 0814 8046     	  mov r8, r0                @ save n1
 178 0816 F146     	  mov r9, lr                @ save lr
 179 0818 7046     	  mov r0, lr                @ xt@ needs r0 = address of bl opcode
 180 081a 01F097F9 	  bl xtfetch
 181 081e C0F80780 	  str r8, [r0, #BODY - 1]   @ store n1 in body of xt target
 182 0822 01BC     	  pop { r0 }
 183 0824 09F1050E 	  add lr, r9, #5            @ advance lr past xt
 184              	  next
 184 0828 7047     	>  bx lr
 185              	
 186              	@ ------------------------------------------------------------------------
 187              	
 188              	@       ( n1 --- )
 189              	
 190              	code "\%+!>", zplusstoreto
 190              	>  header "\%+!>",zplusstoreto
 190              	>>  _header_ "\%+!>",zplusstoreto
 190              	>>>  .section .data
 190 0618 10060000 	>>>  .int _thread
 190              	>>>  .set _thread,.
 190              	>>> 8:
 190              	>>>  hstring "\%+!>"
 190 061c 04       	>>>>  .byte lex+9f-(.+1)
 190 061d 252B213E 	>>>>  .ascii "\%+!>"
 190              	>>>> 9:
 190 0621 000000   	>>>>  .balign 4,0
 190              	>>>  .set lex,0
 190 0624 30080000 	>>>  .int zplusstoreto
 190              	>>>  .previous
 190 082a 0000     	>>  .balign 4,0
 190 082c 1C060000 	>>  .int _thread
 190              	> zplusstoreto:
 191 0830 2EF0010E 	  bic lr, #1                @ de-thumbficate lr adedress
 192 0834 8046     	  mov r8, r0                @ save n1
 193 0836 F146     	  mov r9, lr                @ save link address
 194 0838 7046     	  mov r0, lr                @ xt@ wants opcode address in r0
 195 083a 01F087F9 	  bl xtfetch                @ calculate target address of bl opcode at r0
 196 083e D0F80710 	  ldr r1, [r0, #BODY - 1]   @ fetch contents of variable body
 197 0842 4144     	  add r1, r1, r8            @ add n1
 198 0844 C0F80710 	  str r1, [r0, #BODY - 1]   @ store result back in variable bodu
 199 0848 01BC     	  pop { r0 }                @ pop new top of stack
 200 084a 09F1050E 	  add lr, r9, #5            @ advance lr past item we updated
 201              	  next
 201 084e 7047     	>  bx lr
 202              	
 203              	@ ------------------------------------------------------------------------
 204              	
 205              	@       ( --- )
 206              	
 207              	code "\%incr>", zincrto
 207              	>  header "\%incr>",zincrto
 207              	>>  _header_ "\%incr>",zincrto
 207              	>>>  .section .data
 207 0628 1C060000 	>>>  .int _thread
 207              	>>>  .set _thread,.
 207              	>>> 8:
 207              	>>>  hstring "\%incr>"
 207 062c 06       	>>>>  .byte lex+9f-(.+1)
 207 062d 25696E63 	>>>>  .ascii "\%incr>"
 207      723E
 207              	>>>> 9:
 207 0633 00       	>>>>  .balign 4,0
 207              	>>>  .set lex,0
 207 0634 54080000 	>>>  .int zincrto
 207              	>>>  .previous
 207              	>>  .balign 4,0
 207 0850 2C060000 	>>  .int _thread
 207              	> zincrto:
 208 0854 2EF0010E 	  bic lr, #1
 209 0858 8046     	  mov r8, r0
 210 085a F146     	  mov r9, lr
 211 085c 7046     	  mov r0, lr
 212 085e 01F075F9 	  bl xtfetch
 213 0862 D0F80710 	  ldr r1, [r0, #BODY - 1]
 214 0866 0131     	  adds r1, r1, #1
 215 0868 C0F80710 	  str r1, [r0, #BODY - 1]
 216 086c 4046     	  mov r0, r8
 217 086e 09F1050E 	  add lr, r9, #5
 218              	  next
 218 0872 7047     	>  bx lr
 219              	
 220              	@ ------------------------------------------------------------------------
 221              	
 222              	@       ( --- )
 223              	
 224              	code "\%decr>", zdecrto
 224              	>  header "\%decr>",zdecrto
 224              	>>  _header_ "\%decr>",zdecrto
 224              	>>>  .section .data
 224 0638 2C060000 	>>>  .int _thread
 224              	>>>  .set _thread,.
 224              	>>> 8:
 224              	>>>  hstring "\%decr>"
 224 063c 06       	>>>>  .byte lex+9f-(.+1)
 224 063d 25646563 	>>>>  .ascii "\%decr>"
 224      723E
 224              	>>>> 9:
 224 0643 00       	>>>>  .balign 4,0
 224              	>>>  .set lex,0
 224 0644 78080000 	>>>  .int zdecrto
 224              	>>>  .previous
 224              	>>  .balign 4,0
 224 0874 3C060000 	>>  .int _thread
 224              	> zdecrto:
 225 0878 2EF0010E 	  bic lr, #1
 226 087c 8046     	  mov r8, r0
 227 087e F146     	  mov r9, lr
 228 0880 7046     	  mov r0, lr
 229 0882 01F063F9 	  bl xtfetch
 230 0886 D0F80710 	  ldr r1, [r0, #BODY - 1]
 231 088a 0139     	  subs r1, r1, #1
 232 088c C0F80710 	  str r1, [r0, #BODY - 1]
 233 0890 4046     	  mov r0, r8
 234 0892 09F1050E 	  add lr, r9, #5
 235              	  next
 235 0896 7047     	>  bx lr
 236              	
 237              	@ ------------------------------------------------------------------------
 238              	
 239              	@       ( --- )
 240              	
 241              	code "\%on>", zonto
 241              	>  header "\%on>",zonto
 241              	>>  _header_ "\%on>",zonto
 241              	>>>  .section .data
 241 0648 3C060000 	>>>  .int _thread
 241              	>>>  .set _thread,.
 241              	>>> 8:
 241              	>>>  hstring "\%on>"
 241 064c 04       	>>>>  .byte lex+9f-(.+1)
 241 064d 256F6E3E 	>>>>  .ascii "\%on>"
 241              	>>>> 9:
 241 0651 000000   	>>>>  .balign 4,0
 241              	>>>  .set lex,0
 241 0654 9C080000 	>>>  .int zonto
 241              	>>>  .previous
 241              	>>  .balign 4,0
 241 0898 4C060000 	>>  .int _thread
 241              	> zonto:
 242 089c 2EF0010E 	  bic lr, #1
 243 08a0 8046     	  mov r8, r0
 244 08a2 F146     	  mov r9, lr
 245 08a4 7046     	  mov r0, lr
 246 08a6 01F051F9 	  bl xtfetch
 247 08aa 6FF00001 	  mvn r1, #0
 248 08ae C0F80710 	  str r1, [r0, #BODY - 1]
 249 08b2 4046     	  mov r0, r8
 250 08b4 09F1050E 	  add lr, r9, #5
 251              	  next
 251 08b8 7047     	>  bx lr
 252              	
 253              	@ ------------------------------------------------------------------------
 254              	
 255              	@       ( --- )
 256              	
 257              	code "\%off>", zoffto
 257              	>  header "\%off>",zoffto
 257              	>>  _header_ "\%off>",zoffto
 257              	>>>  .section .data
 257 0658 4C060000 	>>>  .int _thread
 257              	>>>  .set _thread,.
 257              	>>> 8:
 257              	>>>  hstring "\%off>"
 257 065c 05       	>>>>  .byte lex+9f-(.+1)
 257 065d 256F6666 	>>>>  .ascii "\%off>"
 257      3E
 257              	>>>> 9:
 257 0662 0000     	>>>>  .balign 4,0
 257              	>>>  .set lex,0
 257 0664 C0080000 	>>>  .int zoffto
 257              	>>>  .previous
 257 08ba 0000     	>>  .balign 4,0
 257 08bc 5C060000 	>>  .int _thread
 257              	> zoffto:
 258 08c0 2EF0010E 	  bic lr, #1
 259 08c4 8046     	  mov r8, r0
 260 08c6 F146     	  mov r9, lr
 261 08c8 7046     	  mov r0, lr
 262 08ca 01F03FF9 	  bl xtfetch
 263 08ce 0021     	  movs r1, #0
 264 08d0 C0F80710 	  str r1, [r0, #BODY - 1]
 265 08d4 4046     	  mov r0, r8
 266 08d6 09F1050E 	  add lr, r9, #5
 267              	  next
 267 08da 7047     	>  bx lr
 268              	
 269              	@ ------------------------------------------------------------------------
 270              	@ convert a counted string to an address and count
 271              	
 272              	@     ( a1 --- a2 c1 )
 273              	
 274              	code "count", count
 274              	>  header "count",count
 274              	>>  _header_ "count",count
 274              	>>>  .section .data
 274 0668 5C060000 	>>>  .int _thread
 274              	>>>  .set _thread,.
 274              	>>> 8:
 274              	>>>  hstring "count"
 274 066c 05       	>>>>  .byte lex+9f-(.+1)
 274 066d 636F756E 	>>>>  .ascii "count"
 274      74
 274              	>>>> 9:
 274 0672 0000     	>>>>  .balign 4,0
 274              	>>>  .set lex,0
 274 0674 E0080000 	>>>  .int count
 274              	>>>  .previous
 274              	>>  .balign 4,0
 274 08dc 6C060000 	>>  .int _thread
 274              	> count:
 275 08e0 0146     	  mov r1, r0
 276 08e2 11F8010B 	  ldrb r0, [r1], #1
 277 08e6 02B4     	  push { r1 }
 278              	  next
 278 08e8 7047     	>  bx lr
 279              	
 280              	@@ ------------------------------------------------------------------------
 281              	
 282              	@@     ( a1 --- a2 w1 )
 283              	
 284              	@code "wcount", wfetch_plus
 285              	@  mov r1, r0
 286              	@  ldrh r0, [r1], #2
 287              	@  push { r1 }
 288              	@  next
 289              	
 290              	@ ------------------------------------------------------------------------
 291              	
 292              	@     ( a1 --- a2 n1 )
 293              	
 294              	code "dcount", fetch_plus
 294              	>  header "dcount",fetch_plus
 294              	>>  _header_ "dcount",fetch_plus
 294              	>>>  .section .data
 294 0678 6C060000 	>>>  .int _thread
 294              	>>>  .set _thread,.
 294              	>>> 8:
 294              	>>>  hstring "dcount"
 294 067c 06       	>>>>  .byte lex+9f-(.+1)
 294 067d 64636F75 	>>>>  .ascii "dcount"
 294      6E74
 294              	>>>> 9:
 294 0683 00       	>>>>  .balign 4,0
 294              	>>>  .set lex,0
 294 0684 F0080000 	>>>  .int fetch_plus
 294              	>>>  .previous
 294 08ea 0000     	>>  .balign 4,0
 294 08ec 7C060000 	>>  .int _thread
 294              	> fetch_plus:
 295 08f0 0146     	  mov r1, r0
 296 08f2 0888     	  ldrh r0, [r1]
 297 08f4 4A88     	  ldrh r2, [r1, #2]
 298 08f6 0431     	  adds r1, #4
 299 08f8 00EB0240 	  add r0, r0, r2, lsl #16
 300 08fc 02B4     	  push { r1 }
 301              	  next
 301 08fe 7047     	>  bx lr
 302              	
 303              	@ ------------------------------------------------------------------------
 304              	@ move cell from address a1 to address a2
 305              	
 306              	@     ( a1 a2 --- )
 307              	
 308              	@code "dmove", dmove
 309              	@  pop { r1, r2 }
 310              	@  ldr r1, [r1]
 311              	@  str r1, [r0]
 312              	@  mov r0, r2
 313              	@  next
 314              	
 315              	@ ------------------------------------------------------------------------
 316              	@ swap contents of two memory cells
 317              	
 318              	@ note: requires aligned addresses
 319              	
 320              	@     ( a1 a2 --- )
 321              	
 322              	code "juggle", juggle
 322              	>  header "juggle",juggle
 322              	>>  _header_ "juggle",juggle
 322              	>>>  .section .data
 322 0688 7C060000 	>>>  .int _thread
 322              	>>>  .set _thread,.
 322              	>>> 8:
 322              	>>>  hstring "juggle"
 322 068c 06       	>>>>  .byte lex+9f-(.+1)
 322 068d 6A756767 	>>>>  .ascii "juggle"
 322      6C65
 322              	>>>> 9:
 322 0693 00       	>>>>  .balign 4,0
 322              	>>>  .set lex,0
 322 0694 04090000 	>>>  .int juggle
 322              	>>>  .previous
 322              	>>  .balign 4,0
 322 0900 8C060000 	>>  .int _thread
 322              	> juggle:
 323 0904 02BC     	  pop { r1 }
 324 0906 0268     	  ldr r2, [r0]
 325 0908 0B68     	  ldr r3, [r1]
 326 090a 0A60     	  str r2, [r1]
 327 090c 0360     	  str r3, [r0]
 328 090e 01BC     	  pop { r0 }
 329              	  next
 329 0910 7047     	>  bx lr
 330              	
 331              	@ ------------------------------------------------------------------------
 332              	@ get length of asciiz string
 333              	
 334              	@     ( a1 --- a2 n1 )
 335              	
 336              	code "strlen", strlen
 336              	>  header "strlen",strlen
 336              	>>  _header_ "strlen",strlen
 336              	>>>  .section .data
 336 0698 8C060000 	>>>  .int _thread
 336              	>>>  .set _thread,.
 336              	>>> 8:
 336              	>>>  hstring "strlen"
 336 069c 06       	>>>>  .byte lex+9f-(.+1)
 336 069d 7374726C 	>>>>  .ascii "strlen"
 336      656E
 336              	>>>> 9:
 336 06a3 00       	>>>>  .balign 4,0
 336              	>>>  .set lex,0
 336 06a4 18090000 	>>>  .int strlen
 336              	>>>  .previous
 336 0912 0000     	>>  .balign 4,0
 336 0914 9C060000 	>>  .int _thread
 336              	> strlen:
 337 0918 0021     	  movs r1, #0
 338              	0:
 339 091a 425C     	  ldrb r2, [r0, r1]
 340 091c 002A     	  cmp r2, #0
 341 091e 18BF     	  it ne
 342 0920 0131     	  addne r1, r1, #1
 343 0922 FAD1     	  bne 0b
 344 0924 01B4     	  push { r0 }
 345 0926 0846     	  mov r0, r1
 346              	  next
 346 0928 7047     	>  bx lr
 347              	
 348 092a 6FF00001 	  mvn r1, #0
 349              	0:
 350 092e 0131     	  adds r1, r1, #1
 351 0930 425C     	  ldrb r2, [r0, r1]
 352 0932 002A     	  cmp r2, #0
 353 0934 FBD1     	  bne 0b
 354 0936 01B4     	  push { r0 }
 355 0938 0846     	  mov r0, r1
 356              	  next
 356 093a 7047     	>  bx lr
 357              	
 358              	@ ------------------------------------------------------------------------
 359              	@ set bits of data at specified address
 360              	
 361              	@     ( n1 a1 --- )
 362              	
 363              	code "cset", cset
 363              	>  header "cset",cset
 363              	>>  _header_ "cset",cset
 363              	>>>  .section .data
 363 06a8 9C060000 	>>>  .int _thread
 363              	>>>  .set _thread,.
 363              	>>> 8:
 363              	>>>  hstring "cset"
 363 06ac 04       	>>>>  .byte lex+9f-(.+1)
 363 06ad 63736574 	>>>>  .ascii "cset"
 363              	>>>> 9:
 363 06b1 000000   	>>>>  .balign 4,0
 363              	>>>  .set lex,0
 363 06b4 40090000 	>>>  .int cset
 363              	>>>  .previous
 363              	>>  .balign 4,0
 363 093c AC060000 	>>  .int _thread
 363              	> cset:
 364 0940 06BC     	  pop { r1, r2 }
 365 0942 0368     	  ldr r3, [r0]
 366 0944 0B43     	  orrs r3, r3, r1
 367 0946 0360     	  str r3, [r0]
 368 0948 1046     	  mov r0, r2
 369              	  next
 369 094a 7047     	>  bx lr
 370              	
 371              	@ ------------------------------------------------------------------------
 372              	@ clear bits of data at specified address
 373              	
 374              	@     ( n1 a1 --- )
 375              	
 376              	@ code "cclr", cclr
 377              	@   pop { r1, r2 }
 378              	@   mvns r1, r1
 379              	@   ldr r3, [r0]
 380              	@   ands r3, r3, r1
 381              	@   str r3, [r0]
 382              	@   mov r0, r2
 383              	@   next
 384              	
 385              	@ ------------------------------------------------------------------------
 386              	@ set data at address to true
 387              	
 388              	@     ( a1 --- )
 389              	
 390              	code "on", on
 390              	>  header "on",on
 390              	>>  _header_ "on",on
 390              	>>>  .section .data
 390 06b8 AC060000 	>>>  .int _thread
 390              	>>>  .set _thread,.
 390              	>>> 8:
 390              	>>>  hstring "on"
 390 06bc 02       	>>>>  .byte lex+9f-(.+1)
 390 06bd 6F6E     	>>>>  .ascii "on"
 390              	>>>> 9:
 390 06bf 00       	>>>>  .balign 4,0
 390              	>>>  .set lex,0
 390 06c0 50090000 	>>>  .int on
 390              	>>>  .previous
 390              	>>  .balign 4,0
 390 094c BC060000 	>>  .int _thread
 390              	> on:
 391 0950 6FF00001 	  mvn r1, #0
 392 0954 0180     	  strh r1, [r0]
 393 0956 4180     	  strh r1, [r0, #2]
 394 0958 01BC     	  pop { r0 }
 395              	  next
 395 095a 7047     	>  bx lr
 396              	
 397              	@ ------------------------------------------------------------------------
 398              	@ set data at address to false
 399              	
 400              	@     ( a1 --- )
 401              	
 402              	code "off", off
 402              	>  header "off",off
 402              	>>  _header_ "off",off
 402              	>>>  .section .data
 402 06c4 BC060000 	>>>  .int _thread
 402              	>>>  .set _thread,.
 402              	>>> 8:
 402              	>>>  hstring "off"
 402 06c8 03       	>>>>  .byte lex+9f-(.+1)
 402 06c9 6F6666   	>>>>  .ascii "off"
 402              	>>>> 9:
 402              	>>>>  .balign 4,0
 402              	>>>  .set lex,0
 402 06cc 60090000 	>>>  .int off
 402              	>>>  .previous
 402              	>>  .balign 4,0
 402 095c C8060000 	>>  .int _thread
 402              	> off:
 403 0960 0021     	  movs r1, #0
 404 0962 0180     	  strh r1, [r0]
 405 0964 4180     	  strh r1, [r0, #2]
 406 0966 01BC     	  pop { r0 }
 407              	  next
 407 0968 7047     	>  bx lr
 408              	
 409              	@ ------------------------------------------------------------------------
 410              	@ increment data at specified address
 411              	
 412              	@     ( a1 --- )
 413              	
 414              	code "incr", incr
 414              	>  header "incr",incr
 414              	>>  _header_ "incr",incr
 414              	>>>  .section .data
 414 06d0 C8060000 	>>>  .int _thread
 414              	>>>  .set _thread,.
 414              	>>> 8:
 414              	>>>  hstring "incr"
 414 06d4 04       	>>>>  .byte lex+9f-(.+1)
 414 06d5 696E6372 	>>>>  .ascii "incr"
 414              	>>>> 9:
 414 06d9 000000   	>>>>  .balign 4,0
 414              	>>>  .set lex,0
 414 06dc 70090000 	>>>  .int incr
 414              	>>>  .previous
 414 096a 0000     	>>  .balign 4,0
 414 096c D4060000 	>>  .int _thread
 414              	> incr:
 415 0970 0188     	  ldrh r1, [r0]
 416 0972 4288     	  ldrh r2, [r0, #2]
 417 0974 01EB0241 	  add r1, r1, r2, lsl #16
 418 0978 0131     	  adds r1, r1, #1
 419 097a 0180     	  strh r1, [r0]
 420 097c 090C     	  lsrs r1, #16
 421 097e 4180     	  strh r1, [r0, #2]
 422 0980 01BC     	  pop { r0 }
 423              	  next
 423 0982 7047     	>  bx lr
 424              	
 425              	@ ------------------------------------------------------------------------
 426              	@ decrement data at specified address
 427              	
 428              	@     ( a1 --- )
 429              	
 430              	code "decr", decr
 430              	>  header "decr",decr
 430              	>>  _header_ "decr",decr
 430              	>>>  .section .data
 430 06e0 D4060000 	>>>  .int _thread
 430              	>>>  .set _thread,.
 430              	>>> 8:
 430              	>>>  hstring "decr"
 430 06e4 04       	>>>>  .byte lex+9f-(.+1)
 430 06e5 64656372 	>>>>  .ascii "decr"
 430              	>>>> 9:
 430 06e9 000000   	>>>>  .balign 4,0
 430              	>>>  .set lex,0
 430 06ec 88090000 	>>>  .int decr
 430              	>>>  .previous
 430              	>>  .balign 4,0
 430 0984 E4060000 	>>  .int _thread
 430              	> decr:
 431 0988 0188     	  ldrh r1, [r0]
 432 098a 4288     	  ldrh r2, [r0, #2]
 433 098c 01EB0241 	  add r1, r1, r2, lsl #16
 434              	1:
 435 0990 0139     	  subs r1, r1, #1
 436 0992 0180     	  strh r1, [r0]
 437 0994 090C     	  lsrs r1, #16
 438 0996 4180     	  strh r1, [r0, #2]
 439 0998 01BC     	  pop { r0 }
 440              	  next
 440 099a 7047     	>  bx lr
 441              	
 442              	@ ------------------------------------------------------------------------
 443              	@ decrement data at specified address but dont decrement below zero
 444              	
 445              	@     ( a1 --- )
 446              	
 447              	code "0decr", zdecr
 447              	>  header "0decr",zdecr
 447              	>>  _header_ "0decr",zdecr
 447              	>>>  .section .data
 447 06f0 E4060000 	>>>  .int _thread
 447              	>>>  .set _thread,.
 447              	>>> 8:
 447              	>>>  hstring "0decr"
 447 06f4 05       	>>>>  .byte lex+9f-(.+1)
 447 06f5 30646563 	>>>>  .ascii "0decr"
 447      72
 447              	>>>> 9:
 447 06fa 0000     	>>>>  .balign 4,0
 447              	>>>  .set lex,0
 447 06fc A0090000 	>>>  .int zdecr
 447              	>>>  .previous
 447              	>>  .balign 4,0
 447 099c F4060000 	>>  .int _thread
 447              	> zdecr:
 448 09a0 0188     	  ldrh r1, [r0]
 449 09a2 4288     	  ldrh r2, [r0, #2]
 450 09a4 01EB0241 	  add r1, r1, r2, lsl #16
 451 09a8 0029     	  cmp r1, #0
 452 09aa F1D1     	  bne 1b
 453 09ac 01BC     	  pop { r0 }
 454              	  next
 454 09ae 7047     	>  bx lr
 455              	
 456              	@ ------------------------------------------------------------------------
 457              	@ add n1 to data at a1
 458              	
 459              	@     ( n1 a1 --- )
 460              	
 461              	code "+!", plusstore
 461              	>  header "+!",plusstore
 461              	>>  _header_ "+!",plusstore
 461              	>>>  .section .data
 461 0700 F4060000 	>>>  .int _thread
 461              	>>>  .set _thread,.
 461              	>>> 8:
 461              	>>>  hstring "+!"
 461 0704 02       	>>>>  .byte lex+9f-(.+1)
 461 0705 2B21     	>>>>  .ascii "+!"
 461              	>>>> 9:
 461 0707 00       	>>>>  .balign 4,0
 461              	>>>  .set lex,0
 461 0708 B4090000 	>>>  .int plusstore
 461              	>>>  .previous
 461              	>>  .balign 4,0
 461 09b0 04070000 	>>  .int _thread
 461              	> plusstore:
 462 09b4 06BC     	  pop { r1, r2 }
 463 09b6 0388     	  ldrh r3, [r0]
 464 09b8 4488     	  ldrh r4, [r0, #2]
 465 09ba 03EB0443 	  add r3, r3, r4, lsl #16
 466 09be 1944     	  add r1, r1, r3
 467 09c0 0180     	  strh r1, [r0]
 468 09c2 090C     	  lsrs r1, #16
 469 09c4 4180     	  strh r1, [r0, #2]
 470 09c6 1046     	  mov r0, r2
 471              	  next
 471 09c8 7047     	>  bx lr
 472              	
 473              	@ ------------------------------------------------------------------------
 474              	@ copy bytes from src to dest for specified length
 475              	
 476              	@     ( src dst len --- )
 477              	
 478              	code "cmove", cmove
 478              	>  header "cmove",cmove
 478              	>>  _header_ "cmove",cmove
 478              	>>>  .section .data
 478 070c 04070000 	>>>  .int _thread
 478              	>>>  .set _thread,.
 478              	>>> 8:
 478              	>>>  hstring "cmove"
 478 0710 05       	>>>>  .byte lex+9f-(.+1)
 478 0711 636D6F76 	>>>>  .ascii "cmove"
 478      65
 478              	>>>> 9:
 478 0716 0000     	>>>>  .balign 4,0
 478              	>>>  .set lex,0
 478 0718 D0090000 	>>>  .int cmove
 478              	>>>  .previous
 478 09ca 0000     	>>  .balign 4,0
 478 09cc 10070000 	>>  .int _thread
 478              	> cmove:
 479 09d0 0EBC     	  pop { r1, r2, r3 }
 480 09d2 0028     	  cmp r0, #0                @ zero length move?
 481 09d4 05D0     	  beq 2f
 482              	
 483              	1:
 484 09d6 12F8014B 	  ldrb r4, [r2], #1
 485 09da 01F8014B 	  strb r4, [r1], #1
 486 09de 0138     	  subs r0, r0, #1
 487 09e0 F9D1     	  bne 1b
 488              	
 489              	2:
 490 09e2 1846     	  mov r0, r3                @ put new top of stack item in r0
 491              	  next
 491 09e4 7047     	>  bx lr
 492              	
 493              	@ ------------------------------------------------------------------------
 494              	@ cmove data from src to dst starting from the end of the buffers
 495              	
 496              	@     ( src dst len --- )
 497              	
 498              	code "cmove>", cmoveto
 498              	>  header "cmove>",cmoveto
 498              	>>  _header_ "cmove>",cmoveto
 498              	>>>  .section .data
 498 071c 10070000 	>>>  .int _thread
 498              	>>>  .set _thread,.
 498              	>>> 8:
 498              	>>>  hstring "cmove>"
 498 0720 06       	>>>>  .byte lex+9f-(.+1)
 498 0721 636D6F76 	>>>>  .ascii "cmove>"
 498      653E
 498              	>>>> 9:
 498 0727 00       	>>>>  .balign 4,0
 498              	>>>  .set lex,0
 498 0728 EC090000 	>>>  .int cmoveto
 498              	>>>  .previous
 498 09e6 0000     	>>  .balign 4,0
 498 09e8 20070000 	>>  .int _thread
 498              	> cmoveto:
 499 09ec 0EBC     	  pop { r1, r2, r3 }
 500 09ee 0028     	  cmp r0, #0                @ zero length move?
 501 09f0 08D0     	  beq 2f
 502              	
 503 09f2 0138     	  subs r0, r0, #1           @ point src and dst at end of data
 504 09f4 1218     	  adds r2, r2, r0
 505 09f6 0918     	  adds r1, r1, r0
 506              	
 507              	1:
 508 09f8 12F80149 	  ldrb r4, [r2], #-1        @ copy one byte
 509 09fc 01F80149 	  strb r4, [r1], #-1
 510 0a00 0138     	  subs r0, r0, #1           @ count down till we go negative
 511 0a02 F9D5     	  bpl 1b                    @ i.e. we DO want to copy the 0th byte
 512              	
 513              	2:
 514 0a04 1846     	  mov r0, r3                @ put new top of stack item in r0
 515              	  next
 515 0a06 7047     	>  bx lr
 516              	
 517              	@ ------------------------------------------------------------------------
 518              	@ fill buffer with specified data
 519              	
 520              	@   ( a1 n1 c1 --- )
 521              	
 522              	code "fill", fill
 522              	>  header "fill",fill
 522              	>>  _header_ "fill",fill
 522              	>>>  .section .data
 522 072c 20070000 	>>>  .int _thread
 522              	>>>  .set _thread,.
 522              	>>> 8:
 522              	>>>  hstring "fill"
 522 0730 04       	>>>>  .byte lex+9f-(.+1)
 522 0731 66696C6C 	>>>>  .ascii "fill"
 522              	>>>> 9:
 522 0735 000000   	>>>>  .balign 4,0
 522              	>>>  .set lex,0
 522 0738 0C0A0000 	>>>  .int fill
 522              	>>>  .previous
 522              	>>  .balign 4,0
 522 0a08 30070000 	>>  .int _thread
 522              	> fill:
 523 0a0c 0EBC     	  pop { r1, r2, r3 }
 524              	
 525              	_fill1:
 526 0a0e 1144     	  add r1, r1, r2            @ point r1 beyond end of data
 527              	0:
 528 0a10 8A42     	  cmp r2, r1                @ does r2 point beyond end of data?
 529 0a12 1CBF     	  itt ne
 530 0a14 02F8010B 	  strbne r0, [r2], #1       @ if not store next byte
 531 0a18 FAE7     	  bne 0b                    @ and repeat
 532 0a1a 1846     	  mov r0, r3
 533              	  next
 533 0a1c 7047     	>  bx lr
 534              	
 535              	@ ------------------------------------------------------------------------
 536              	@ fill buffer with spaces
 537              	
 538              	@     ( a1 n1 --- )
 539              	
 540              	@ code "blank", blank
 541              	@   pop { r2, r3 }
 542              	@   mov r1, r0
 543              	@   movs r0, #0x20
 544              	@   b _fill1
 545              	
 546              	@ ------------------------------------------------------------------------
 547              	@ fill buffer with zeros
 548              	
 549              	@     ( a1 n1 --- )
 550              	
 551              	code "erase", erase
 551              	>  header "erase",erase
 551              	>>  _header_ "erase",erase
 551              	>>>  .section .data
 551 073c 30070000 	>>>  .int _thread
 551              	>>>  .set _thread,.
 551              	>>> 8:
 551              	>>>  hstring "erase"
 551 0740 05       	>>>>  .byte lex+9f-(.+1)
 551 0741 65726173 	>>>>  .ascii "erase"
 551      65
 551              	>>>> 9:
 551 0746 0000     	>>>>  .balign 4,0
 551              	>>>  .set lex,0
 551 0748 240A0000 	>>>  .int erase
 551              	>>>  .previous
 551 0a1e 0000     	>>  .balign 4,0
 551 0a20 40070000 	>>  .int _thread
 551              	> erase:
 552 0a24 0CBC     	  pop { r2, r3 }
 553 0a26 0146     	  mov r1, r0
 554 0a28 0020     	  movs r0, #0
 555 0a2a F0E7     	  b _fill1
 556              	
 557              	@ ------------------------------------------------------------------------
 558              	
 559              	@     ( a1 n1 n2 --- )
 560              	
 561              	code "dfill", dfill
 561              	>  header "dfill",dfill
 561              	>>  _header_ "dfill",dfill
 561              	>>>  .section .data
 561 074c 40070000 	>>>  .int _thread
 561              	>>>  .set _thread,.
 561              	>>> 8:
 561              	>>>  hstring "dfill"
 561 0750 05       	>>>>  .byte lex+9f-(.+1)
 561 0751 6466696C 	>>>>  .ascii "dfill"
 561      6C
 561              	>>>> 9:
 561 0756 0000     	>>>>  .balign 4,0
 561              	>>>  .set lex,0
 561 0758 300A0000 	>>>  .int dfill
 561              	>>>  .previous
 561              	>>  .balign 4,0
 561 0a2c 50070000 	>>  .int _thread
 561              	> dfill:
 562 0a30 0EBC     	  pop { r1, r2, r3 }
 563 0a32 8900     	  movs r1, r1, lsl #2
 564 0a34 1144     	  add r1, r1, r2
 565              	
 566              	0:
 567 0a36 8A42     	  cmp r2, r1
 568 0a38 18BF     	  it ne
 569 0a3a 42F8040B 	  strne r0, [r2], #4
 570 0a3e FAD1     	  bne 0b
 571 0a40 1846     	  mov r0, r3
 572              	  next
 572 0a42 7047     	>  bx lr
 573              	
 574              	@ ------------------------------------------------------------------------
 575              	@ ascii uppercase translation table
 576              	
 577              	atbl:
 578 0a44 00010203 	 .byte 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
 578      04050607 
 579 0a4c 08090A0B 	 .byte 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
 579      0C0D0E0F 
 580 0a54 10111213 	 .byte 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17
 580      14151617 
 581 0a5c 18191A1B 	 .byte 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f
 581      1C1D1E1F 
 582 0a64 20212223 	 .byte 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27
 582      24252627 
 583 0a6c 28292A2B 	 .byte 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f
 583      2C2D2E2F 
 584 0a74 30313233 	 .byte 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37
 584      34353637 
 585 0a7c 38393A3B 	 .byte 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f
 585      3C3D3E3F 
 586 0a84 40414243 	 .byte 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47
 586      44454647 
 587 0a8c 48494A4B 	 .byte 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f
 587      4C4D4E4F 
 588 0a94 50515253 	 .byte 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57
 588      54555657 
 589 0a9c 58595A5B 	 .byte 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f
 589      5C5D5E5F 
 590 0aa4 60414243 	 .byte 0x60, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47
 590      44454647 
 591 0aac 48494A4B 	 .byte 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f
 591      4C4D4E4F 
 592 0ab4 50515253 	 .byte 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57
 592      54555657 
 593 0abc 58595A7B 	 .byte 0x58, 0x59, 0x5a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f
 593      7C7D7E7F 
 594              	
 595              	@ ------------------------------------------------------------------------
 596              	@ upper case a character
 597              	
 598              	@     ( c1 --- c2 )
 599              	
 600              	code "upc", upc
 600              	>  header "upc",upc
 600              	>>  _header_ "upc",upc
 600              	>>>  .section .data
 600 075c 50070000 	>>>  .int _thread
 600              	>>>  .set _thread,.
 600              	>>> 8:
 600              	>>>  hstring "upc"
 600 0760 03       	>>>>  .byte lex+9f-(.+1)
 600 0761 757063   	>>>>  .ascii "upc"
 600              	>>>> 9:
 600              	>>>>  .balign 4,0
 600              	>>>  .set lex,0
 600 0764 C80A0000 	>>>  .int upc
 600              	>>>  .previous
 600              	>>  .balign 4,0
 600 0ac4 60070000 	>>  .int _thread
 600              	> upc:
 601 0ac8 00F07F00 	  and r0, r0, #0x7f
 602 0acc AFF28C01 	  adr r1, atbl
 603 0ad0 085C     	  ldrb r0, [r1, r0]
 604              	  next
 604 0ad2 7047     	>  bx lr
 605              	
 606              	@ ------------------------------------------------------------------------
 607              	@ compare strings of specified length
 608              	
 609              	@     ( a1 a2 n1 --- f1 )
 610              	
 611              	code "comp", comp
 611              	>  header "comp",comp
 611              	>>  _header_ "comp",comp
 611              	>>>  .section .data
 611 0768 60070000 	>>>  .int _thread
 611              	>>>  .set _thread,.
 611              	>>> 8:
 611              	>>>  hstring "comp"
 611 076c 04       	>>>>  .byte lex+9f-(.+1)
 611 076d 636F6D70 	>>>>  .ascii "comp"
 611              	>>>> 9:
 611 0771 000000   	>>>>  .balign 4,0
 611              	>>>  .set lex,0
 611 0774 D80A0000 	>>>  .int comp
 611              	>>>  .previous
 611              	>>  .balign 4,0
 611 0ad4 6C070000 	>>  .int _thread
 611              	> comp:
 612 0ad8 06BC     	  pop { r1, r2 }
 613 0ada 0028     	  cmp r0, #0                @ zero length data
 614 0adc 08D0     	  beq 1f
 615              	0:
 616 0ade 0C78     	  ldrb r4, [r1]             @ fetch one char from src and dst
 617 0ae0 1578     	  ldrb r5, [r2]
 618 0ae2 AC42     	  cmp r4, r5                @ compare them
 619 0ae4 04D1     	  bne 1f                    @ if not same then exit from this loop
 620 0ae6 0131     	  adds r1, r1, #1
 621 0ae8 0132     	  adds r2, r2, #1
 622 0aea 0138     	  subs r0, r0, #1           @ count length down by 1
 623 0aec F7D1     	  bne 0b                    @ loop till done
 624              	  next                      @ return 0 == strings the same
 624 0aee 7047     	>  bx lr
 625              	
 626              	1:
 627 0af0 CCBF     	  ite gt
 628 0af2 0120     	  movgt r0, #1
 629 0af4 6FF00000 	  mvnle r0, #0
 630              	  next
 630 0af8 7047     	>  bx lr
 631              	
 632              	@ ------------------------------------------------------------------------
 633              	@ store zero char at end of string
 634              	
 635              	@ this is useful when passing strings to system calls.
 636              	
 637              	@     ( a1 n1 --- a1 )
 638              	
 639              	code "s>z", s2z
 639              	>  header "s>z",s2z
 639              	>>  _header_ "s>z",s2z
 639              	>>>  .section .data
 639 0778 6C070000 	>>>  .int _thread
 639              	>>>  .set _thread,.
 639              	>>> 8:
 639              	>>>  hstring "s>z"
 639 077c 03       	>>>>  .byte lex+9f-(.+1)
 639 077d 733E7A   	>>>>  .ascii "s>z"
 639              	>>>> 9:
 639              	>>>>  .balign 4,0
 639              	>>>  .set lex,0
 639 0780 000B0000 	>>>  .int s2z
 639              	>>>  .previous
 639 0afa 0000     	>>  .balign 4,0
 639 0afc 7C070000 	>>  .int _thread
 639              	> s2z:
 640 0b00 0146     	  mov r1, r0                @ set r0 = address, r1 = length
 641 0b02 01BC     	  pop { r0 }
 642 0b04 4218     	  adds r2, r0, r1           @ point r2 at end of string
 643 0b06 0023     	  movs r3, #0               @ store zero byte at end of string
 644 0b08 1370     	  strb r3, [r2]
 645              	  next
 645 0b0a 7047     	>  bx lr
 646              	
 647              	@ ------------------------------------------------------------------------
 648              	
 649              	@    ( a1 n1 a2 --- )
 650              	
 651              	colon "$!", strstore
 651              	>  header "$!",strstore
 651              	>>  _header_ "$!",strstore
 651              	>>>  .section .data
 651 0784 7C070000 	>>>  .int _thread
 651              	>>>  .set _thread,.
 651              	>>> 8:
 651              	>>>  hstring "$!"
 651 0788 02       	>>>>  .byte lex+9f-(.+1)
 651 0789 2421     	>>>>  .ascii "$!"
 651              	>>>> 9:
 651 078b 00       	>>>>  .balign 4,0
 651              	>>>  .set lex,0
 651 078c 100B0000 	>>>  .int strstore
 651              	>>>  .previous
 651              	>>  .balign 4,0
 651 0b0c 88070000 	>>  .int _thread
 651              	> strstore:
 651 0b10 AFF30080 	>  nop.w
 651              	>  rpush lr
 651 0b14 4CF804ED 	>>  str lr,[rp,#-4]!
 652 0b18 FFF7F8FC 	  bl twodup
 653 0b1c FFF768FE 	  bl cstore
 654 0b20 00F068F8 	  bl oneplus
 655 0b24 FFF700FD 	  bl swap
 656 0b28 FFF752FF 	  bl cmove
 657              	  exit
 657              	>  rpop pc
 657 0b2c 5CF804FB 	>>  ldr pc,[rp],#4
 658              	
 659              	@ ------------------------------------------------------------------------
 660              	@ append a counted string to end of another (assumes space)
 661              	
 662              	@     ( a1 n1 a2 --- )
 663              	
 664              	colon "$+", strplus
 664              	>  header "$+",strplus
 664              	>>  _header_ "$+",strplus
 664              	>>>  .section .data
 664 0790 88070000 	>>>  .int _thread
 664              	>>>  .set _thread,.
 664              	>>> 8:
 664              	>>>  hstring "$+"
 664 0794 02       	>>>>  .byte lex+9f-(.+1)
 664 0795 242B     	>>>>  .ascii "$+"
 664              	>>>> 9:
 664 0797 00       	>>>>  .balign 4,0
 664              	>>>  .set lex,0
 664 0798 340B0000 	>>>  .int strplus
 664              	>>>  .previous
 664              	>>  .balign 4,0
 664 0b30 94070000 	>>  .int _thread
 664              	> strplus:
 664 0b34 AFF30080 	>  nop.w
 664              	>  rpush lr
 664 0b38 4CF804ED 	>>  str lr,[rp,#-4]!
 665 0b3c FFF758FD 	  bl duptor
 666 0b40 FFF7CEFE 	  bl count
 667 0b44 FFF754FD 	  bl duptor
 668 0b48 00F016F8 	  bl plus
 669 0b4c FFF72CFD 	  bl drot
 670 0b50 FFF730FD 	  bl tor
 671 0b54 FFF7E8FC 	  bl swap
 672 0b58 FFF756FD 	  bl rfetch
 673 0b5c FFF738FF 	  bl cmove
 674 0b60 FFF73EFD 	  bl tworto
 675 0b64 00F008F8 	  bl plus
 676 0b68 FFF734FD 	  bl rto
 677 0b6c FFF740FE 	  bl cstore
 678              	  exit
 678              	>  rpop pc
 678 0b70 5CF804FB 	>>  ldr pc,[rp],#4
 679              	
 680              	@ ========================================================================
 314              	  .include "math.s"         @ basic math
   1              	@ math.s
   2              	@ ------------------------------------------------------------------------
   3              	
   4              	@ ------------------------------------------------------------------------
   5              	@ add top two items of parameter stack
   6              	
   7              	@       ( n1 n2 --- n3 )
   8              	
   9              	code "+", plus
   9              	>  header "+",plus
   9              	>>  _header_ "+",plus
   9              	>>>  .section .data
   9 079c 94070000 	>>>  .int _thread
   9              	>>>  .set _thread,.
   9              	>>> 8:
   9              	>>>  hstring "+"
   9 07a0 01       	>>>>  .byte lex+9f-(.+1)
   9 07a1 2B       	>>>>  .ascii "+"
   9              	>>>> 9:
   9 07a2 0000     	>>>>  .balign 4,0
   9              	>>>  .set lex,0
   9 07a4 780B0000 	>>>  .int plus
   9              	>>>  .previous
   9              	>>  .balign 4,0
   9 0b74 A0070000 	>>  .int _thread
   9              	> plus:
  10 0b78 02BC     	  pop { r1 }
  11 0b7a 4018     	  adds r0, r0, r1
  12              	  next
  12 0b7c 7047     	>  bx lr
  13              	
  14              	@ ------------------------------------------------------------------------
  15              	@ compute difference between top two items of parameter stack
  16              	
  17              	@       ( n1 n2 --- n3 )
  18              	
  19              	code "-", minus
  19              	>  header "-",minus
  19              	>>  _header_ "-",minus
  19              	>>>  .section .data
  19 07a8 A0070000 	>>>  .int _thread
  19              	>>>  .set _thread,.
  19              	>>> 8:
  19              	>>>  hstring "-"
  19 07ac 01       	>>>>  .byte lex+9f-(.+1)
  19 07ad 2D       	>>>>  .ascii "-"
  19              	>>>> 9:
  19 07ae 0000     	>>>>  .balign 4,0
  19              	>>>  .set lex,0
  19 07b0 840B0000 	>>>  .int minus
  19              	>>>  .previous
  19 0b7e 0000     	>>  .balign 4,0
  19 0b80 AC070000 	>>  .int _thread
  19              	> minus:
  20 0b84 02BC     	  pop { r1 }
  21 0b86 081A     	  subs r0, r1, r0
  22              	  next
  22 0b88 7047     	>  bx lr
  23              	
  24              	@ ------------------------------------------------------------------------
  25              	@ compute absolute value of top item of parameter stack
  26              	
  27              	@       ( n1 --- n1` )
  28              	
  29              	code "abs", abs
  29              	>  header "abs",abs
  29              	>>  _header_ "abs",abs
  29              	>>>  .section .data
  29 07b4 AC070000 	>>>  .int _thread
  29              	>>>  .set _thread,.
  29              	>>> 8:
  29              	>>>  hstring "abs"
  29 07b8 03       	>>>>  .byte lex+9f-(.+1)
  29 07b9 616273   	>>>>  .ascii "abs"
  29              	>>>> 9:
  29              	>>>>  .balign 4,0
  29              	>>>  .set lex,0
  29 07bc 900B0000 	>>>  .int abs
  29              	>>>  .previous
  29 0b8a 0000     	>>  .balign 4,0
  29 0b8c B8070000 	>>  .int _thread
  29              	> abs:
  30 0b90 C117     	  movs r1, r0, asr #31
  31 0b92 4840     	  eors r0, r0, r1
  32 0b94 401A     	  subs r0, r0, r1
  33              	  next
  33 0b96 7047     	>  bx lr
  34              	
  35              	@ ------------------------------------------------------------------------
  36              	@ shift left n1 by n2 bits
  37              	
  38              	@       ( n1 n2 --- n3 )
  39              	
  40              	code "<<", shll
  40              	>  header "<<",shll
  40              	>>  _header_ "<<",shll
  40              	>>>  .section .data
  40 07c0 B8070000 	>>>  .int _thread
  40              	>>>  .set _thread,.
  40              	>>> 8:
  40              	>>>  hstring "<<"
  40 07c4 02       	>>>>  .byte lex+9f-(.+1)
  40 07c5 3C3C     	>>>>  .ascii "<<"
  40              	>>>> 9:
  40 07c7 00       	>>>>  .balign 4,0
  40              	>>>  .set lex,0
  40 07c8 9C0B0000 	>>>  .int shll
  40              	>>>  .previous
  40              	>>  .balign 4,0
  40 0b98 C4070000 	>>  .int _thread
  40              	> shll:
  41 0b9c 02BC     	  pop { r1 }
  42 0b9e 11FA00F0 	  movs r0, r1, lsl r0
  43              	  next
  43 0ba2 7047     	>  bx lr
  44              	
  45              	@ ------------------------------------------------------------------------
  46              	@ signed shift right n1 by n2 bits
  47              	
  48              	@       ( n1 n2 --- n3 )
  49              	
  50              	code ">>", shrr
  50              	>  header ">>",shrr
  50              	>>  _header_ ">>",shrr
  50              	>>>  .section .data
  50 07cc C4070000 	>>>  .int _thread
  50              	>>>  .set _thread,.
  50              	>>> 8:
  50              	>>>  hstring ">>"
  50 07d0 02       	>>>>  .byte lex+9f-(.+1)
  50 07d1 3E3E     	>>>>  .ascii ">>"
  50              	>>>> 9:
  50 07d3 00       	>>>>  .balign 4,0
  50              	>>>  .set lex,0
  50 07d4 A80B0000 	>>>  .int shrr
  50              	>>>  .previous
  50              	>>  .balign 4,0
  50 0ba4 D0070000 	>>  .int _thread
  50              	> shrr:
  51 0ba8 02BC     	  pop { r1 }
  52 0baa 51FA00F0 	  movs r0, r1, asr r0
  53              	  next
  53 0bae 7047     	>  bx lr
  54              	
  55              	@ ------------------------------------------------------------------------
  56              	@ unsigned shift right n1 by n2 bits
  57              	
  58              	@       ( n1 n2 --- n3 )
  59              	
  60              	code "u>>", ushr
  60              	>  header "u>>",ushr
  60              	>>  _header_ "u>>",ushr
  60              	>>>  .section .data
  60 07d8 D0070000 	>>>  .int _thread
  60              	>>>  .set _thread,.
  60              	>>> 8:
  60              	>>>  hstring "u>>"
  60 07dc 03       	>>>>  .byte lex+9f-(.+1)
  60 07dd 753E3E   	>>>>  .ascii "u>>"
  60              	>>>> 9:
  60              	>>>>  .balign 4,0
  60              	>>>  .set lex,0
  60 07e0 B40B0000 	>>>  .int ushr
  60              	>>>  .previous
  60              	>>  .balign 4,0
  60 0bb0 DC070000 	>>  .int _thread
  60              	> ushr:
  61 0bb4 02BC     	  pop { r1 }
  62 0bb6 31FA00F0 	  movs r0, r1, lsr r0
  63              	  next
  63 0bba 7047     	>  bx lr
  64              	
  65              	@ ------------------------------------------------------------------------
  66              	@ multiply top item of parameter stack by two
  67              	
  68              	@       ( n1 --- n2 )
  69              	
  70              	code "2*", twostar
  70              	>  header "2*",twostar
  70              	>>  _header_ "2*",twostar
  70              	>>>  .section .data
  70 07e4 DC070000 	>>>  .int _thread
  70              	>>>  .set _thread,.
  70              	>>> 8:
  70              	>>>  hstring "2*"
  70 07e8 02       	>>>>  .byte lex+9f-(.+1)
  70 07e9 322A     	>>>>  .ascii "2*"
  70              	>>>> 9:
  70 07eb 00       	>>>>  .balign 4,0
  70              	>>>  .set lex,0
  70 07ec C00B0000 	>>>  .int twostar
  70              	>>>  .previous
  70              	>>  .balign 4,0
  70 0bbc E8070000 	>>  .int _thread
  70              	> twostar:
  71 0bc0 4000     	  lsls r0, #1
  72              	  next
  72 0bc2 7047     	>  bx lr
  73              	
  74              	@ ------------------------------------------------------------------------
  75              	@ multiply top item of parameter stack by three
  76              	
  77              	@       ( n1 --- n2 )
  78              	
  79              	code "3*", threestar
  79              	>  header "3*",threestar
  79              	>>  _header_ "3*",threestar
  79              	>>>  .section .data
  79 07f0 E8070000 	>>>  .int _thread
  79              	>>>  .set _thread,.
  79              	>>> 8:
  79              	>>>  hstring "3*"
  79 07f4 02       	>>>>  .byte lex+9f-(.+1)
  79 07f5 332A     	>>>>  .ascii "3*"
  79              	>>>> 9:
  79 07f7 00       	>>>>  .balign 4,0
  79              	>>>  .set lex,0
  79 07f8 C80B0000 	>>>  .int threestar
  79              	>>>  .previous
  79              	>>  .balign 4,0
  79 0bc4 F4070000 	>>  .int _thread
  79              	> threestar:
  80 0bc8 10EB4000 	  adds r0, r0, r0, lsl #1
  81              	  next
  81 0bcc 7047     	>  bx lr
  82              	
  83              	@ ------------------------------------------------------------------------
  84              	@ multiply top item of parameter stack by four
  85              	
  86              	@       ( n1 --- n2 )
  87              	
  88              	code "4*", fourstar
  88              	>  header "4*",fourstar
  88              	>>  _header_ "4*",fourstar
  88              	>>>  .section .data
  88 07fc F4070000 	>>>  .int _thread
  88              	>>>  .set _thread,.
  88              	>>> 8:
  88              	>>>  hstring "4*"
  88 0800 02       	>>>>  .byte lex+9f-(.+1)
  88 0801 342A     	>>>>  .ascii "4*"
  88              	>>>> 9:
  88 0803 00       	>>>>  .balign 4,0
  88              	>>>  .set lex,0
  88 0804 D40B0000 	>>>  .int fourstar
  88              	>>>  .previous
  88 0bce 0000     	>>  .balign 4,0
  88 0bd0 00080000 	>>  .int _thread
  88              	> fourstar:
  89 0bd4 8000     	  lsls r0, #2
  90              	  next
  90 0bd6 7047     	>  bx lr
  91              	
  92              	@ ------------------------------------------------------------------------
  93              	@ signed divide top item of parameter stack by two
  94              	
  95              	@       ( n1 --- n2 )
  96              	
  97              	
  98              	code "2/", twoslash
  98              	>  header "2/",twoslash
  98              	>>  _header_ "2/",twoslash
  98              	>>>  .section .data
  98 0808 00080000 	>>>  .int _thread
  98              	>>>  .set _thread,.
  98              	>>> 8:
  98              	>>>  hstring "2/"
  98 080c 02       	>>>>  .byte lex+9f-(.+1)
  98 080d 322F     	>>>>  .ascii "2/"
  98              	>>>> 9:
  98 080f 00       	>>>>  .balign 4,0
  98              	>>>  .set lex,0
  98 0810 DC0B0000 	>>>  .int twoslash
  98              	>>>  .previous
  98              	>>  .balign 4,0
  98 0bd8 0C080000 	>>  .int _thread
  98              	> twoslash:
  99 0bdc 4010     	  asrs r0, #1
 100              	  next
 100 0bde 7047     	>  bx lr
 101              	
 102              	@ ------------------------------------------------------------------------
 103              	@ unsigned divide top item of parameter stack by two
 104              	
 105              	@       ( n1 --- n2 )
 106              	
 107              	code "u2/", u2slash
 107              	>  header "u2/",u2slash
 107              	>>  _header_ "u2/",u2slash
 107              	>>>  .section .data
 107 0814 0C080000 	>>>  .int _thread
 107              	>>>  .set _thread,.
 107              	>>> 8:
 107              	>>>  hstring "u2/"
 107 0818 03       	>>>>  .byte lex+9f-(.+1)
 107 0819 75322F   	>>>>  .ascii "u2/"
 107              	>>>> 9:
 107              	>>>>  .balign 4,0
 107              	>>>  .set lex,0
 107 081c E40B0000 	>>>  .int u2slash
 107              	>>>  .previous
 107              	>>  .balign 4,0
 107 0be0 18080000 	>>  .int _thread
 107              	> u2slash:
 108 0be4 4008     	  lsrs r0, #1
 109              	  next
 109 0be6 7047     	>  bx lr
 110              	
 111              	@ ------------------------------------------------------------------------
 112              	@ divide top item of parameter stack by four
 113              	
 114              	@       ( n1 --- n2 )
 115              	
 116              	code "4/", fourslash
 116              	>  header "4/",fourslash
 116              	>>  _header_ "4/",fourslash
 116              	>>>  .section .data
 116 0820 18080000 	>>>  .int _thread
 116              	>>>  .set _thread,.
 116              	>>> 8:
 116              	>>>  hstring "4/"
 116 0824 02       	>>>>  .byte lex+9f-(.+1)
 116 0825 342F     	>>>>  .ascii "4/"
 116              	>>>> 9:
 116 0827 00       	>>>>  .balign 4,0
 116              	>>>  .set lex,0
 116 0828 EC0B0000 	>>>  .int fourslash
 116              	>>>  .previous
 116              	>>  .balign 4,0
 116 0be8 24080000 	>>  .int _thread
 116              	> fourslash:
 117 0bec 8010     	  asrs r0, #2
 118              	  next
 118 0bee 7047     	>  bx lr
 119              	
 120              	@ ------------------------------------------------------------------------
 121              	@ add one to top item of parameter stack
 122              	
 123              	@       ( n1 --- n2 )
 124              	
 125              	code "1+", oneplus
 125              	>  header "1+",oneplus
 125              	>>  _header_ "1+",oneplus
 125              	>>>  .section .data
 125 082c 24080000 	>>>  .int _thread
 125              	>>>  .set _thread,.
 125              	>>> 8:
 125              	>>>  hstring "1+"
 125 0830 02       	>>>>  .byte lex+9f-(.+1)
 125 0831 312B     	>>>>  .ascii "1+"
 125              	>>>> 9:
 125 0833 00       	>>>>  .balign 4,0
 125              	>>>  .set lex,0
 125 0834 F40B0000 	>>>  .int oneplus
 125              	>>>  .previous
 125              	>>  .balign 4,0
 125 0bf0 30080000 	>>  .int _thread
 125              	> oneplus:
 126 0bf4 0130     	  adds r0, r0, #1
 127              	  next
 127 0bf6 7047     	>  bx lr
 128              	
 129              	@ ------------------------------------------------------------------------
 130              	@ subtract one from top item of parameter stack
 131              	
 132              	@       ( n1 --- n2 )
 133              	
 134              	code "1-", oneminus
 134              	>  header "1-",oneminus
 134              	>>  _header_ "1-",oneminus
 134              	>>>  .section .data
 134 0838 30080000 	>>>  .int _thread
 134              	>>>  .set _thread,.
 134              	>>> 8:
 134              	>>>  hstring "1-"
 134 083c 02       	>>>>  .byte lex+9f-(.+1)
 134 083d 312D     	>>>>  .ascii "1-"
 134              	>>>> 9:
 134 083f 00       	>>>>  .balign 4,0
 134              	>>>  .set lex,0
 134 0840 FC0B0000 	>>>  .int oneminus
 134              	>>>  .previous
 134              	>>  .balign 4,0
 134 0bf8 3C080000 	>>  .int _thread
 134              	> oneminus:
 135 0bfc 0138     	  subs r0, r0, #1
 136              	  next
 136 0bfe 7047     	>  bx lr
 137              	
 138              	@ ------------------------------------------------------------------------
 139              	@ add two to top item of parameters stack
 140              	
 141              	@       ( n1 --- n2 )
 142              	
 143              	code "2+", twoplus
 143              	>  header "2+",twoplus
 143              	>>  _header_ "2+",twoplus
 143              	>>>  .section .data
 143 0844 3C080000 	>>>  .int _thread
 143              	>>>  .set _thread,.
 143              	>>> 8:
 143              	>>>  hstring "2+"
 143 0848 02       	>>>>  .byte lex+9f-(.+1)
 143 0849 322B     	>>>>  .ascii "2+"
 143              	>>>> 9:
 143 084b 00       	>>>>  .balign 4,0
 143              	>>>  .set lex,0
 143 084c 040C0000 	>>>  .int twoplus
 143              	>>>  .previous
 143              	>>  .balign 4,0
 143 0c00 48080000 	>>  .int _thread
 143              	> twoplus:
 144 0c04 0230     	  adds r0, r0, #2
 145              	  next
 145 0c06 7047     	>  bx lr
 146              	
 147              	@ ------------------------------------------------------------------------
 148              	@ subtract two from top item of parameter stack
 149              	
 150              	@       ( n1 --- n2 )
 151              	
 152              	code "2-", twominus
 152              	>  header "2-",twominus
 152              	>>  _header_ "2-",twominus
 152              	>>>  .section .data
 152 0850 48080000 	>>>  .int _thread
 152              	>>>  .set _thread,.
 152              	>>> 8:
 152              	>>>  hstring "2-"
 152 0854 02       	>>>>  .byte lex+9f-(.+1)
 152 0855 322D     	>>>>  .ascii "2-"
 152              	>>>> 9:
 152 0857 00       	>>>>  .balign 4,0
 152              	>>>  .set lex,0
 152 0858 0C0C0000 	>>>  .int twominus
 152              	>>>  .previous
 152              	>>  .balign 4,0
 152 0c08 54080000 	>>  .int _thread
 152              	> twominus:
 153 0c0c 0238     	  subs r0, r0, #2
 154              	  next
 154 0c0e 7047     	>  bx lr
 155              	
 156              	@ ------------------------------------------------------------------------
 157              	@ add three to top item of parameter stack
 158              	
 159              	@       ( n1 --- n2 )
 160              	
 161              	code "3+", threeplus
 161              	>  header "3+",threeplus
 161              	>>  _header_ "3+",threeplus
 161              	>>>  .section .data
 161 085c 54080000 	>>>  .int _thread
 161              	>>>  .set _thread,.
 161              	>>> 8:
 161              	>>>  hstring "3+"
 161 0860 02       	>>>>  .byte lex+9f-(.+1)
 161 0861 332B     	>>>>  .ascii "3+"
 161              	>>>> 9:
 161 0863 00       	>>>>  .balign 4,0
 161              	>>>  .set lex,0
 161 0864 140C0000 	>>>  .int threeplus
 161              	>>>  .previous
 161              	>>  .balign 4,0
 161 0c10 60080000 	>>  .int _thread
 161              	> threeplus:
 162 0c14 0330     	  adds r0, r0, #3
 163              	  next
 163 0c16 7047     	>  bx lr
 164              	
 165              	@ ------------------------------------------------------------------------
 166              	@ subtract three from top item of parameter stack
 167              	
 168              	@       ( n1 --- n2 )
 169              	
 170              	code "3-", threeminus
 170              	>  header "3-",threeminus
 170              	>>  _header_ "3-",threeminus
 170              	>>>  .section .data
 170 0868 60080000 	>>>  .int _thread
 170              	>>>  .set _thread,.
 170              	>>> 8:
 170              	>>>  hstring "3-"
 170 086c 02       	>>>>  .byte lex+9f-(.+1)
 170 086d 332D     	>>>>  .ascii "3-"
 170              	>>>> 9:
 170 086f 00       	>>>>  .balign 4,0
 170              	>>>  .set lex,0
 170 0870 1C0C0000 	>>>  .int threeminus
 170              	>>>  .previous
 170              	>>  .balign 4,0
 170 0c18 6C080000 	>>  .int _thread
 170              	> threeminus:
 171 0c1c 0338     	  subs r0, r0, #3
 172              	  next
 172 0c1e 7047     	>  bx lr
 173              	
 174              	@ ------------------------------------------------------------------------
 175              	@ add four to top item of parameter stack
 176              	
 177              	@       ( a1 --- a2 )
 178              	
 179              	code "4+", fourplus
 179              	>  header "4+",fourplus
 179              	>>  _header_ "4+",fourplus
 179              	>>>  .section .data
 179 0874 6C080000 	>>>  .int _thread
 179              	>>>  .set _thread,.
 179              	>>> 8:
 179              	>>>  hstring "4+"
 179 0878 02       	>>>>  .byte lex+9f-(.+1)
 179 0879 342B     	>>>>  .ascii "4+"
 179              	>>>> 9:
 179 087b 00       	>>>>  .balign 4,0
 179              	>>>  .set lex,0
 179 087c 240C0000 	>>>  .int fourplus
 179              	>>>  .previous
 179              	>>  .balign 4,0
 179 0c20 78080000 	>>  .int _thread
 179              	> fourplus:
 180 0c24 0430     	  adds r0, r0, #4
 181              	  next
 181 0c26 7047     	>  bx lr
 182              	
 183              	@ ------------------------------------------------------------------------
 184              	@ subtract four from top item of parameter stack
 185              	
 186              	@       ( a1 --- a2 )
 187              	
 188              	code "4-", fourminus
 188              	>  header "4-",fourminus
 188              	>>  _header_ "4-",fourminus
 188              	>>>  .section .data
 188 0880 78080000 	>>>  .int _thread
 188              	>>>  .set _thread,.
 188              	>>> 8:
 188              	>>>  hstring "4-"
 188 0884 02       	>>>>  .byte lex+9f-(.+1)
 188 0885 342D     	>>>>  .ascii "4-"
 188              	>>>> 9:
 188 0887 00       	>>>>  .balign 4,0
 188              	>>>  .set lex,0
 188 0888 2C0C0000 	>>>  .int fourminus
 188              	>>>  .previous
 188              	>>  .balign 4,0
 188 0c28 84080000 	>>  .int _thread
 188              	> fourminus:
 189 0c2c 0438     	  subs r0, r0, #4
 190              	  next
 190 0c2e 7047     	>  bx lr
 191              	
 192              	@ ------------------------------------------------------------------------
 193              	@ twos complement top of parameter stack
 194              	
 195              	@       ( n1 --- n2)
 196              	
 197              	code "negate", negate
 197              	>  header "negate",negate
 197              	>>  _header_ "negate",negate
 197              	>>>  .section .data
 197 088c 84080000 	>>>  .int _thread
 197              	>>>  .set _thread,.
 197              	>>> 8:
 197              	>>>  hstring "negate"
 197 0890 06       	>>>>  .byte lex+9f-(.+1)
 197 0891 6E656761 	>>>>  .ascii "negate"
 197      7465
 197              	>>>> 9:
 197 0897 00       	>>>>  .balign 4,0
 197              	>>>  .set lex,0
 197 0898 340C0000 	>>>  .int negate
 197              	>>>  .previous
 197              	>>  .balign 4,0
 197 0c30 90080000 	>>  .int _thread
 197              	> negate:
 198 0c34 4042     	  rsbs r0, r0, #0
 199              	  next
 199 0c36 7047     	>  bx lr
 200              	
 201              	@ ------------------------------------------------------------------------
 202              	@ conditionally twos complement second of parameter stack
 203              	
 204              	@       ( n1 n2 --- n2)
 205              	
 206              	code "?negate", qnegate
 206              	>  header "?negate",qnegate
 206              	>>  _header_ "?negate",qnegate
 206              	>>>  .section .data
 206 089c 90080000 	>>>  .int _thread
 206              	>>>  .set _thread,.
 206              	>>> 8:
 206              	>>>  hstring "?negate"
 206 08a0 07       	>>>>  .byte lex+9f-(.+1)
 206 08a1 3F6E6567 	>>>>  .ascii "?negate"
 206      617465
 206              	>>>> 9:
 206              	>>>>  .balign 4,0
 206              	>>>  .set lex,0
 206 08a8 3C0C0000 	>>>  .int qnegate
 206              	>>>  .previous
 206              	>>  .balign 4,0
 206 0c38 A0080000 	>>  .int _thread
 206              	> qnegate:
 207 0c3c 0028     	  cmp r0, #0
 208 0c3e 01BC     	  pop { r0 }
 209 0c40 18BF     	  it ne
 210 0c42 4042     	  rsbne r0, r0, #0
 211              	  next
 211 0c44 7047     	>  bx lr
 212              	
 213              	@ ------------------------------------------------------------------------
 214              	@ twos complement double
 215              	
 216              	@       ( d1 --- d2 )
 217              	
 218              	code "dnegate", dnegate
 218              	>  header "dnegate",dnegate
 218              	>>  _header_ "dnegate",dnegate
 218              	>>>  .section .data
 218 08ac A0080000 	>>>  .int _thread
 218              	>>>  .set _thread,.
 218              	>>> 8:
 218              	>>>  hstring "dnegate"
 218 08b0 07       	>>>>  .byte lex+9f-(.+1)
 218 08b1 646E6567 	>>>>  .ascii "dnegate"
 218      617465
 218              	>>>> 9:
 218              	>>>>  .balign 4,0
 218              	>>>  .set lex,0
 218 08b8 4C0C0000 	>>>  .int dnegate
 218              	>>>  .previous
 218 0c46 0000     	>>  .balign 4,0
 218 0c48 B0080000 	>>  .int _thread
 218              	> dnegate:
 219 0c4c 02BC     	  pop { r1 }
 220 0c4e 0022     	  movs r2, #0
 221 0c50 4942     	  rsbs r1, r1, #0
 222 0c52 62EB0000 	  sbc r0, r2, r0
 223 0c56 02B4     	  push { r1 }
 224              	  next
 224 0c58 7047     	>  bx lr
 225              	
 226              	@ ------------------------------------------------------------------------
 227              	@ add top two double numbers
 228              	
 229              	@       ( d1 d2 --- d3 )
 230              	
 231              	code "d+", dplus
 231              	>  header "d+",dplus
 231              	>>  _header_ "d+",dplus
 231              	>>>  .section .data
 231 08bc B0080000 	>>>  .int _thread
 231              	>>>  .set _thread,.
 231              	>>> 8:
 231              	>>>  hstring "d+"
 231 08c0 02       	>>>>  .byte lex+9f-(.+1)
 231 08c1 642B     	>>>>  .ascii "d+"
 231              	>>>> 9:
 231 08c3 00       	>>>>  .balign 4,0
 231              	>>>  .set lex,0
 231 08c4 600C0000 	>>>  .int dplus
 231              	>>>  .previous
 231 0c5a 0000     	>>  .balign 4,0
 231 0c5c C0080000 	>>  .int _thread
 231              	> dplus:
 232 0c60 0EBC     	  pop { r1, r2, r3 }
 233 0c62 5918     	  adds r1, r3, r1
 234 0c64 5041     	  adcs r0, r2, r0
 235 0c66 02B4     	  push { r1 }
 236              	  next
 236 0c68 7047     	>  bx lr
 237              	
 238              	@ ------------------------------------------------------------------------
 239              	@ compute difference between top two double numbers
 240              	
 241              	@       ( d1 d2 --- d3 )
 242              	
 243              	colon "d-", dminus
 243              	>  header "d-",dminus
 243              	>>  _header_ "d-",dminus
 243              	>>>  .section .data
 243 08c8 C0080000 	>>>  .int _thread
 243              	>>>  .set _thread,.
 243              	>>> 8:
 243              	>>>  hstring "d-"
 243 08cc 02       	>>>>  .byte lex+9f-(.+1)
 243 08cd 642D     	>>>>  .ascii "d-"
 243              	>>>> 9:
 243 08cf 00       	>>>>  .balign 4,0
 243              	>>>  .set lex,0
 243 08d0 700C0000 	>>>  .int dminus
 243              	>>>  .previous
 243 0c6a 0000     	>>  .balign 4,0
 243 0c6c CC080000 	>>  .int _thread
 243              	> dminus:
 243 0c70 AFF30080 	>  nop.w
 243              	>  rpush lr
 243 0c74 4CF804ED 	>>  str lr,[rp,#-4]!
 244 0c78 FFF7E8FF 	  bl dnegate
 245 0c7c FFF7F0FF 	  bl dplus
 246              	  exit
 246              	>  rpop pc
 246 0c80 5CF804FB 	>>  ldr pc,[rp],#4
 247              	
 248              	@ ------------------------------------------------------------------------
 249              	@ compute absolute value of top double number
 250              	
 251              	@       ( d1 --- d2 )
 252              	
 253              	code "dabs", dabs
 253              	>  header "dabs",dabs
 253              	>>  _header_ "dabs",dabs
 253              	>>>  .section .data
 253 08d4 CC080000 	>>>  .int _thread
 253              	>>>  .set _thread,.
 253              	>>> 8:
 253              	>>>  hstring "dabs"
 253 08d8 04       	>>>>  .byte lex+9f-(.+1)
 253 08d9 64616273 	>>>>  .ascii "dabs"
 253              	>>>> 9:
 253 08dd 000000   	>>>>  .balign 4,0
 253              	>>>  .set lex,0
 253 08e0 880C0000 	>>>  .int dabs
 253              	>>>  .previous
 253              	>>  .balign 4,0
 253 0c84 D8080000 	>>  .int _thread
 253              	> dabs:
 254 0c88 0028     	  cmp r0, #0
 255 0c8a DFD4     	  bmi dnegate
 256              	  next
 256 0c8c 7047     	>  bx lr
 257              	
 258              	@ ------------------------------------------------------------------------
 259              	@ sign extend single to double
 260              	
 261              	@       ( n1 --- d1 )
 262              	
 263              	code "s>d", s2d
 263              	>  header "s>d",s2d
 263              	>>  _header_ "s>d",s2d
 263              	>>>  .section .data
 263 08e4 D8080000 	>>>  .int _thread
 263              	>>>  .set _thread,.
 263              	>>> 8:
 263              	>>>  hstring "s>d"
 263 08e8 03       	>>>>  .byte lex+9f-(.+1)
 263 08e9 733E64   	>>>>  .ascii "s>d"
 263              	>>>> 9:
 263              	>>>>  .balign 4,0
 263              	>>>  .set lex,0
 263 08ec 940C0000 	>>>  .int s2d
 263              	>>>  .previous
 263 0c8e 0000     	>>  .balign 4,0
 263 0c90 E8080000 	>>  .int _thread
 263              	> s2d:
 264 0c94 01B4     	  push { r0 }
 265 0c96 C017     	  movs r0, r0, asr #31
 266              	  next
 266 0c98 7047     	>  bx lr
 267              	
 268              	@ ------------------------------------------------------------------------
 269              	@ unsigned multiply double by single
 270              	
 271              	@       ( d1 n1 --- d2 )
 272              	
 273              	code "um*", umstar
 273              	>  header "um*",umstar
 273              	>>  _header_ "um*",umstar
 273              	>>>  .section .data
 273 08f0 E8080000 	>>>  .int _thread
 273              	>>>  .set _thread,.
 273              	>>> 8:
 273              	>>>  hstring "um*"
 273 08f4 03       	>>>>  .byte lex+9f-(.+1)
 273 08f5 756D2A   	>>>>  .ascii "um*"
 273              	>>>> 9:
 273              	>>>>  .balign 4,0
 273              	>>>  .set lex,0
 273 08f8 A00C0000 	>>>  .int umstar
 273              	>>>  .previous
 273 0c9a 0000     	>>  .balign 4,0
 273 0c9c F4080000 	>>  .int _thread
 273              	> umstar:
 274 0ca0 02BC     	  pop { r1 }
 275 0ca2 A0FB0123 	  umull r2, r3, r0, r1
 276 0ca6 04B4     	  push { r2 }
 277 0ca8 1846     	  mov r0, r3
 278              	  next
 278 0caa 7047     	>  bx lr
 279              	
 280              	@ ------------------------------------------------------------------------
 281              	@ signed multiply double by single
 282              	
 283              	@       ( d1 n1 --- d2 )
 284              	
 285              	code "m*", mstar
 285              	>  header "m*",mstar
 285              	>>  _header_ "m*",mstar
 285              	>>>  .section .data
 285 08fc F4080000 	>>>  .int _thread
 285              	>>>  .set _thread,.
 285              	>>> 8:
 285              	>>>  hstring "m*"
 285 0900 02       	>>>>  .byte lex+9f-(.+1)
 285 0901 6D2A     	>>>>  .ascii "m*"
 285              	>>>> 9:
 285 0903 00       	>>>>  .balign 4,0
 285              	>>>  .set lex,0
 285 0904 B00C0000 	>>>  .int mstar
 285              	>>>  .previous
 285              	>>  .balign 4,0
 285 0cac 00090000 	>>  .int _thread
 285              	> mstar:
 286 0cb0 02BC     	  pop { r1 }
 287 0cb2 80FB0123 	  smull r2, r3, r0, r1
 288 0cb6 04B4     	  push { r2 }
 289 0cb8 1846     	  mov r0, r3
 290              	  next
 290 0cba 7047     	>  bx lr
 291              	
 292              	@ ------------------------------------------------------------------------
 293              	@ compute product of top two items of parameter stack
 294              	
 295              	@       ( n1 n2 --- n3 )
 296              	
 297              	code "*", star
 297              	>  header "*",star
 297              	>>  _header_ "*",star
 297              	>>>  .section .data
 297 0908 00090000 	>>>  .int _thread
 297              	>>>  .set _thread,.
 297              	>>> 8:
 297              	>>>  hstring "*"
 297 090c 01       	>>>>  .byte lex+9f-(.+1)
 297 090d 2A       	>>>>  .ascii "*"
 297              	>>>> 9:
 297 090e 0000     	>>>>  .balign 4,0
 297              	>>>  .set lex,0
 297 0910 C00C0000 	>>>  .int star
 297              	>>>  .previous
 297              	>>  .balign 4,0
 297 0cbc 0C090000 	>>  .int _thread
 297              	> star:
 298 0cc0 02BC     	  pop { r1 }
 299 0cc2 01FB00F0 	  mul r0, r1
 300              	  next
 300 0cc6 7047     	>  bx lr
 301              	
 302              	@ ------------------------------------------------------------------------
 303              	@ multiply top two items of parameter stack then add the third
 304              	
 305              	@       ( n1 n2 n3 --- n4 )
 306              	
 307              	code "*+", star_plus
 307              	>  header "*+",star_plus
 307              	>>  _header_ "*+",star_plus
 307              	>>>  .section .data
 307 0914 0C090000 	>>>  .int _thread
 307              	>>>  .set _thread,.
 307              	>>> 8:
 307              	>>>  hstring "*+"
 307 0918 02       	>>>>  .byte lex+9f-(.+1)
 307 0919 2A2B     	>>>>  .ascii "*+"
 307              	>>>> 9:
 307 091b 00       	>>>>  .balign 4,0
 307              	>>>  .set lex,0
 307 091c CC0C0000 	>>>  .int star_plus
 307              	>>>  .previous
 307              	>>  .balign 4,0
 307 0cc8 18090000 	>>  .int _thread
 307              	> star_plus:
 308 0ccc 06BC     	  pop { r1, r2 }
 309 0cce 01FB00F0 	  mul r0, r1
 310 0cd2 1044     	  add r0, r2
 311              	  next
 311 0cd4 7047     	>  bx lr
 312              	
 313              	@ ------------------------------------------------------------------------
 314              	@ signed 32 / 32 divide  (fast)
 315              	
 316              	@     ( n1 n2 --- rem quo )
 317              	
 318              	code "sdiv", sdiv
 318              	>  header "sdiv",sdiv
 318              	>>  _header_ "sdiv",sdiv
 318              	>>>  .section .data
 318 0920 18090000 	>>>  .int _thread
 318              	>>>  .set _thread,.
 318              	>>> 8:
 318              	>>>  hstring "sdiv"
 318 0924 04       	>>>>  .byte lex+9f-(.+1)
 318 0925 73646976 	>>>>  .ascii "sdiv"
 318              	>>>> 9:
 318 0929 000000   	>>>>  .balign 4,0
 318              	>>>  .set lex,0
 318 092c DC0C0000 	>>>  .int sdiv
 318              	>>>  .previous
 318 0cd6 0000     	>>  .balign 4,0
 318 0cd8 24090000 	>>  .int _thread
 318              	> sdiv:
 319 0cdc 02BC     	  pop { r1 }
 320 0cde 91FBF0F2 	  sdiv r2, r1, r0
 321 0ce2 02FB1013 	  mls r3, r2, r0, r1
 322 0ce6 12EBE372 	  adds r2, r2, r3, asr #31
 323 0cea 10EAE370 	  ands r0, r0, r3, asr #31
 324 0cee 1B18     	  adds r3, r3, r0
 325 0cf0 08B4     	  push { r3 }
 326 0cf2 1000     	  movs r0, r2
 327              	  next
 327 0cf4 7047     	>  bx lr
 328              	
 329              	@ ------------------------------------------------------------------------
 330              	@ unsigned 32 / 32 divide (fast)
 331              	
 332              	@     ( n1 n2 --- rem quo )
 333              	
 334              	code "udiv", udiv
 334              	>  header "udiv",udiv
 334              	>>  _header_ "udiv",udiv
 334              	>>>  .section .data
 334 0930 24090000 	>>>  .int _thread
 334              	>>>  .set _thread,.
 334              	>>> 8:
 334              	>>>  hstring "udiv"
 334 0934 04       	>>>>  .byte lex+9f-(.+1)
 334 0935 75646976 	>>>>  .ascii "udiv"
 334              	>>>> 9:
 334 0939 000000   	>>>>  .balign 4,0
 334              	>>>  .set lex,0
 334 093c FC0C0000 	>>>  .int udiv
 334              	>>>  .previous
 334 0cf6 0000     	>>  .balign 4,0
 334 0cf8 34090000 	>>  .int _thread
 334              	> udiv:
 335 0cfc 02BC     	  pop { r1 }
 336 0cfe B1FBF0F2 	  udiv r2, r1, r0
 337 0d02 02FB1010 	  mls r0, r2, r0, r1
 338 0d06 01B4     	  push { r0 }
 339 0d08 1000     	  movs r0, r2
 340              	  next
 340 0d0a 7047     	>  bx lr
 341              	
 342              	@ ------------------------------------------------------------------------
 343              	@ software 64/32 division (slow)
 344              	
 345              	@   ( d1 n1 --- rem quo )
 346              	
 347              	code "um/mod", ummod
 347              	>  header "um/mod",ummod
 347              	>>  _header_ "um/mod",ummod
 347              	>>>  .section .data
 347 0940 34090000 	>>>  .int _thread
 347              	>>>  .set _thread,.
 347              	>>> 8:
 347              	>>>  hstring "um/mod"
 347 0944 06       	>>>>  .byte lex+9f-(.+1)
 347 0945 756D2F6D 	>>>>  .ascii "um/mod"
 347      6F64
 347              	>>>> 9:
 347 094b 00       	>>>>  .balign 4,0
 347              	>>>  .set lex,0
 347 094c 100D0000 	>>>  .int ummod
 347              	>>>  .previous
 347              	>>  .balign 4,0
 347 0d0c 44090000 	>>  .int _thread
 347              	> ummod:
 348 0d10 06BC     	  pop { r1, r2 }
 349              	
 350 0d12 0023     	  movs r3, #0
 351 0d14 4025     	  movs r5, #64
 352              	1:
 353 0d16 9218     	  adds r2, r2, r2
 354 0d18 4941     	  adcs r1, r1, r1
 355 0d1a 5B41     	  adcs r3, r3, r3
 356 0d1c 32BF     	  itee cc
 357 0d1e B3EB0004 	  subscc r4, r3, r0
 358 0d22 1B1A     	  subcs r3, r3, r0
 359 0d24 0132     	  addcs r2, r2, #1
 360 0d26 013D     	  subs r5, r5, #1
 361 0d28 F5D1     	  bne 1b
 362              	
 363 0d2a 08B4     	  push { r3 }
 364              	
 365 0d2c 1046     	  mov r0, r2
 366              	  next
 366 0d2e 7047     	>  bx lr
 367              	
 368              	@ ------------------------------------------------------------------------
 369              	@ fast NEON 64/32 divide
 370              	
 371              	@     ( d1 n1 --- rem quo )
 372              	
 373              	code "vdiv", vdiv
 373              	>  header "vdiv",vdiv
 373              	>>  _header_ "vdiv",vdiv
 373              	>>>  .section .data
 373 0950 44090000 	>>>  .int _thread
 373              	>>>  .set _thread,.
 373              	>>> 8:
 373              	>>>  hstring "vdiv"
 373 0954 04       	>>>>  .byte lex+9f-(.+1)
 373 0955 76646976 	>>>>  .ascii "vdiv"
 373              	>>>> 9:
 373 0959 000000   	>>>>  .balign 4,0
 373              	>>>  .set lex,0
 373 095c 340D0000 	>>>  .int vdiv
 373              	>>>  .previous
 373              	>>  .balign 4,0
 373 0d30 54090000 	>>  .int _thread
 373              	> vdiv:
 374 0d34 BDEC020A 	  vpop { s0, s1 }           @ pop d1 into s0 and s1
 375 0d38 B8EE601B 	  vcvt.f64.u32 d1, s1       @ convert s1 to 64 bit float
 376 0d3c B8EE400B 	  vcvt.f64.u32 d0, s0       @ convert s0 to 64 bit float
 377              	
 378 0d40 A0EF9005 	  vshl.i64 d0, d0, #32      @ shift d0 to hi 32 bits and add to low 32
 379 0d44 30EE010B 	  vadd.f64 d0, d0, d1       @ D0 = 64 bit d1 in floating point
 380              	
 381 0d48 01EE100A 	  vmov s2, r0               @ convert divisor to 64 bit float
 382 0d4c B8EE411B 	  vcvt.f64.u32 d1, s2       @ D1 = divisor
 383              	
 384 0d50 80EE012B 	  vdiv.f64 d2, d0, d1       @ divide d0 by d1, result in d2
 385              	
 386 0d54 BCEEC22B 	  vcvt.u32.f64 s4, d2
 387 0d58 12EE100A 	  vmov r0, s4               @ r0 = quotient
 388 0d5c B8EE422B 	  vcvt.f64.u32 d2, s4       @ convert result back to float sans fraction
 389              	
 390 0d60 22EE013B 	  vmul.f64 d3, d2, d1       @ D3 = result * divisor
 391 0d64 30EE434B 	  vsub.f64 d4, d0, d3       @ calculate remainder
 392 0d68 BCEEC40B 	  vcvt.u32.f64 s0, d4
 393              	
 394 0d6c 2DED010A 	  vpush { s0 }
 395              	  next
 395 0d70 7047     	>  bx lr
 396              	
 397              	@ ------------------------------------------------------------------------
 398              	@ zero extend 16 bit r0 to 32 bits
 399              	
 400              	@     ( h1 --- n1 )
 401              	
 402              	code "uxth", uxth
 402              	>  header "uxth",uxth
 402              	>>  _header_ "uxth",uxth
 402              	>>>  .section .data
 402 0960 54090000 	>>>  .int _thread
 402              	>>>  .set _thread,.
 402              	>>> 8:
 402              	>>>  hstring "uxth"
 402 0964 04       	>>>>  .byte lex+9f-(.+1)
 402 0965 75787468 	>>>>  .ascii "uxth"
 402              	>>>> 9:
 402 0969 000000   	>>>>  .balign 4,0
 402              	>>>  .set lex,0
 402 096c 780D0000 	>>>  .int uxth
 402              	>>>  .previous
 402 0d72 0000     	>>  .balign 4,0
 402 0d74 64090000 	>>  .int _thread
 402              	> uxth:
 403 0d78 80B2     	  uxth r0, r0
 404              	  next
 404 0d7a 7047     	>  bx lr
 405              	
 406              	@ ------------------------------------------------------------------------
 407              	@ sign extend 16 bit r0 to 32 bits
 408              	
 409              	@     ( h1 --- n1 )
 410              	
 411              	code "sxth", sxth
 411              	>  header "sxth",sxth
 411              	>>  _header_ "sxth",sxth
 411              	>>>  .section .data
 411 0970 64090000 	>>>  .int _thread
 411              	>>>  .set _thread,.
 411              	>>> 8:
 411              	>>>  hstring "sxth"
 411 0974 04       	>>>>  .byte lex+9f-(.+1)
 411 0975 73787468 	>>>>  .ascii "sxth"
 411              	>>>> 9:
 411 0979 000000   	>>>>  .balign 4,0
 411              	>>>  .set lex,0
 411 097c 800D0000 	>>>  .int sxth
 411              	>>>  .previous
 411              	>>  .balign 4,0
 411 0d7c 74090000 	>>  .int _thread
 411              	> sxth:
 412 0d80 00B2     	  sxth r0, r0
 413              	  next
 413 0d82 7047     	>  bx lr
 414              	
 415              	@ ------------------------------------------------------------------------
 416              	@ divide double by single, return double q, single r
 417              	
 418              	@       ( d1 n1 --- rem quo )
 419              	
 420              	colon "mu/mod", musmod
 420              	>  header "mu/mod",musmod
 420              	>>  _header_ "mu/mod",musmod
 420              	>>>  .section .data
 420 0980 74090000 	>>>  .int _thread
 420              	>>>  .set _thread,.
 420              	>>> 8:
 420              	>>>  hstring "mu/mod"
 420 0984 06       	>>>>  .byte lex+9f-(.+1)
 420 0985 6D752F6D 	>>>>  .ascii "mu/mod"
 420      6F64
 420              	>>>> 9:
 420 098b 00       	>>>>  .balign 4,0
 420              	>>>  .set lex,0
 420 098c 880D0000 	>>>  .int musmod
 420              	>>>  .previous
 420              	>>  .balign 4,0
 420 0d84 84090000 	>>  .int _thread
 420              	> musmod:
 420 0d88 AFF30080 	>  nop.w
 420              	>  rpush lr
 420 0d8c 4CF804ED 	>>  str lr,[rp,#-4]!
 421 0d90 FFF710FC 	  bl tor
 422              	  cliteral 0
 422 0d94 01B4     	>  push { r0 }
 422 0d96 0020     	>  movs r0,#0
 423 0d98 FFF736FC 	  bl rfetch
 424 0d9c FFF7CAFF 	  bl vdiv                   @ bl ummod
 425 0da0 FFF718FC 	  bl rto
 426 0da4 FFF7C0FB 	  bl swap
 427 0da8 FFF704FC 	  bl tor
 428 0dac FFF7C2FF 	  bl vdiv                   @ bl ummod
 429 0db0 FFF710FC 	  bl rto
 430              	  exit
 430              	>  rpop pc
 430 0db4 5CF804FB 	>>  ldr pc,[rp],#4
 431              	
 432              	@ ------------------------------------------------------------------------
 433              	
 434              	colon "(/mod)", psmod
 434              	>  header "(/mod)",psmod
 434              	>>  _header_ "(/mod)",psmod
 434              	>>>  .section .data
 434 0990 84090000 	>>>  .int _thread
 434              	>>>  .set _thread,.
 434              	>>> 8:
 434              	>>>  hstring "(/mod)"
 434 0994 06       	>>>>  .byte lex+9f-(.+1)
 434 0995 282F6D6F 	>>>>  .ascii "(/mod)"
 434      6429
 434              	>>>> 9:
 434 099b 00       	>>>>  .balign 4,0
 434              	>>>  .set lex,0
 434 099c BC0D0000 	>>>  .int psmod
 434              	>>>  .previous
 434              	>>  .balign 4,0
 434 0db8 94090000 	>>  .int _thread
 434              	> psmod:
 434 0dbc AFF30080 	>  nop.w
 434              	>  rpush lr
 434 0dc0 4CF804ED 	>>  str lr,[rp,#-4]!
 435 0dc4 FFF79EFB 	  bl dup
 436 0dc8 00F0B4F8 	  bl zless
 437 0dcc FFF7DAFB 	  bl pluck
 438 0dd0 00F0B0F8 	  bl zless
 439 0dd4 00F07CF8 	  bl xor
 440 0dd8 FFF7F2FB 	  bl twotor
 441 0ddc FFF7D8FE 	  bl abs
 442              	  cliteral 0
 442 0de0 01B4     	>  push { r0 }
 442 0de2 0020     	>  movs r0,#0
 443 0de4 FFF7F6FB 	  bl rto
 444 0de8 FFF7D2FE 	  bl abs
 445 0dec FFF7A2FF 	  bl vdiv                   @ bl ummod
 446 0df0 FFF7F0FB 	  bl rto
 447 0df4 FFF722FF 	  bl qnegate
 448              	  exit
 448              	>  rpop pc
 448 0df8 5CF804FB 	>>  ldr pc,[rp],#4
 449              	
 450              	@ ------------------------------------------------------------------------
 451              	@ wrapper for (/mod) to floor result
 452              	
 453              	colon "/mod", smod
 453              	>  header "/mod",smod
 453              	>>  _header_ "/mod",smod
 453              	>>>  .section .data
 453 09a0 94090000 	>>>  .int _thread
 453              	>>>  .set _thread,.
 453              	>>> 8:
 453              	>>>  hstring "/mod"
 453 09a4 04       	>>>>  .byte lex+9f-(.+1)
 453 09a5 2F6D6F64 	>>>>  .ascii "/mod"
 453              	>>>> 9:
 453 09a9 000000   	>>>>  .balign 4,0
 453              	>>>  .set lex,0
 453 09ac 000E0000 	>>>  .int smod
 453              	>>>  .previous
 453              	>>  .balign 4,0
 453 0dfc A4090000 	>>  .int _thread
 453              	> smod:
 453 0e00 AFF30080 	>  nop.w
 453              	>  rpush lr
 453 0e04 4CF804ED 	>>  str lr,[rp,#-4]!
 454 0e08 FFF780FB 	  bl twodup
 455 0e0c 00F060F8 	  bl xor
 456 0e10 00F090F8 	  bl zless
 457 0e14 01F02AF8 	  bl qbranch
 458 0e18 3D00     	  .hword (3f - .) + 1
 459 0e1a FFF7E9FB 	  bl duptor
 460 0e1e FFF7CDFF 	  bl psmod
 461 0e22 FFF79FFB 	  bl over
 462 0e26 01F021F8 	  bl qbranch
 463 0e2a 2100     	  .hword (1f - .) + 1
 464 0e2c FFF7E6FE 	  bl oneminus
 465 0e30 FFF77AFB 	  bl swap
 466 0e34 FFF7CEFB 	  bl rto
 467 0e38 FFF7A4FE 	  bl minus
 468 0e3c FFF7FAFE 	  bl negate
 469 0e40 FFF772FB 	  bl swap
 470 0e44 01F008F8 	  bl branch
 471 0e48 0700     	  .hword (2f - .) + 1
 472              	1:
 473 0e4a FFF7D7FB 	  bl rdrop
 474              	2:
 475 0e4e 01F003F8 	  bl branch
 476 0e52 0700     	  .hword (4f - .) + 1
 477              	3:
 478 0e54 FFF7B2FF 	  bl psmod
 479              	4:
 480              	  exit
 480              	>  rpop pc
 480 0e58 5CF804FB 	>>  ldr pc,[rp],#4
 481              	
 482              	@ ------------------------------------------------------------------------
 483              	
 484              	colon "mod", mod
 484              	>  header "mod",mod
 484              	>>  _header_ "mod",mod
 484              	>>>  .section .data
 484 09b0 A4090000 	>>>  .int _thread
 484              	>>>  .set _thread,.
 484              	>>> 8:
 484              	>>>  hstring "mod"
 484 09b4 03       	>>>>  .byte lex+9f-(.+1)
 484 09b5 6D6F64   	>>>>  .ascii "mod"
 484              	>>>> 9:
 484              	>>>>  .balign 4,0
 484              	>>>  .set lex,0
 484 09b8 600E0000 	>>>  .int mod
 484              	>>>  .previous
 484              	>>  .balign 4,0
 484 0e5c B4090000 	>>  .int _thread
 484              	> mod:
 484 0e60 AFF30080 	>  nop.w
 484              	>  rpush lr
 484 0e64 4CF804ED 	>>  str lr,[rp,#-4]!
 485 0e68 FFF7CAFF 	  bl smod
 486 0e6c FFF76AFB 	  bl drop
 487              	  exit
 487              	>  rpop pc
 487 0e70 5CF804FB 	>>  ldr pc,[rp],#4
 488              	
 489              	@ ------------------------------------------------------------------------
 490              	
 491              	colon "/", slash
 491              	>  header "/",slash
 491              	>>  _header_ "/",slash
 491              	>>>  .section .data
 491 09bc B4090000 	>>>  .int _thread
 491              	>>>  .set _thread,.
 491              	>>> 8:
 491              	>>>  hstring "/"
 491 09c0 01       	>>>>  .byte lex+9f-(.+1)
 491 09c1 2F       	>>>>  .ascii "/"
 491              	>>>> 9:
 491 09c2 0000     	>>>>  .balign 4,0
 491              	>>>  .set lex,0
 491 09c4 780E0000 	>>>  .int slash
 491              	>>>  .previous
 491              	>>  .balign 4,0
 491 0e74 C0090000 	>>  .int _thread
 491              	> slash:
 491 0e78 AFF30080 	>  nop.w
 491              	>  rpush lr
 491 0e7c 4CF804ED 	>>  str lr,[rp,#-4]!
 492 0e80 FFF7BEFF 	  bl smod
 493 0e84 FFF774FB 	  bl nip
 494              	  exit
 494              	>  rpop pc
 494 0e88 5CF804FB 	>>  ldr pc,[rp],#4
 495              	
 496              	@ ------------------------------------------------------------------------
 497              	@ neat arm code stolen from the net
 498              	
 499              	code "bswap", bswap
 499              	>  header "bswap",bswap
 499              	>>  _header_ "bswap",bswap
 499              	>>>  .section .data
 499 09c8 C0090000 	>>>  .int _thread
 499              	>>>  .set _thread,.
 499              	>>> 8:
 499              	>>>  hstring "bswap"
 499 09cc 05       	>>>>  .byte lex+9f-(.+1)
 499 09cd 62737761 	>>>>  .ascii "bswap"
 499      70
 499              	>>>> 9:
 499 09d2 0000     	>>>>  .balign 4,0
 499              	>>>  .set lex,0
 499 09d4 900E0000 	>>>  .int bswap
 499              	>>>  .previous
 499              	>>  .balign 4,0
 499 0e8c CC090000 	>>  .int _thread
 499              	> bswap:
 500 0e90 00BA     	  rev r0, r0                @ armv6 or higher
 501              	  next
 501 0e92 7047     	>  bx lr
 502              	
 503              	@ ========================================================================
 315              	  .include "logic.s"        @ more basic math
   1              	@ logic.s
   2              	@ ------------------------------------------------------------------------
   3              	
   4              	@ ------------------------------------------------------------------------
   5              	
   6              	  _constant_ "true", true,  -1
   6              	>  header "true",true
   6              	>>  _header_ "true",true
   6              	>>>  .section .data
   6 09d8 CC090000 	>>>  .int _thread
   6              	>>>  .set _thread,.
   6              	>>> 8:
   6              	>>>  hstring "true"
   6 09dc 04       	>>>>  .byte lex+9f-(.+1)
   6 09dd 74727565 	>>>>  .ascii "true"
   6              	>>>> 9:
   6 09e1 000000   	>>>>  .balign 4,0
   6              	>>>  .set lex,0
   6 09e4 980E0000 	>>>  .int true
   6              	>>>  .previous
   6              	>>  .balign 4,0
   6 0e94 DC090000 	>>  .int _thread
   6              	> true:
   6              	>  rpush lr
   6 0e98 4CF804ED 	>>  str lr,[rp,#-4]!
   6 0e9c FFF76CFA 	>  bl dovar
   6 0ea0 FFFFFFFF 	>  .int -1
   7              	  _constant_ "false", false, 0
   7              	>  header "false",false
   7              	>>  _header_ "false",false
   7              	>>>  .section .data
   7 09e8 DC090000 	>>>  .int _thread
   7              	>>>  .set _thread,.
   7              	>>> 8:
   7              	>>>  hstring "false"
   7 09ec 05       	>>>>  .byte lex+9f-(.+1)
   7 09ed 66616C73 	>>>>  .ascii "false"
   7      65
   7              	>>>> 9:
   7 09f2 0000     	>>>>  .balign 4,0
   7              	>>>  .set lex,0
   7 09f4 A80E0000 	>>>  .int false
   7              	>>>  .previous
   7              	>>  .balign 4,0
   7 0ea4 EC090000 	>>  .int _thread
   7              	> false:
   7              	>  rpush lr
   7 0ea8 4CF804ED 	>>  str lr,[rp,#-4]!
   7 0eac FFF764FA 	>  bl dovar
   7 0eb0 00000000 	>  .int 0
   8              	
   9              	@ ------------------------------------------------------------------------
  10              	
  11              	@       ( n1 n2 --- n3 )
  12              	
  13              	code "and", and_
  13              	>  header "and",and_
  13              	>>  _header_ "and",and_
  13              	>>>  .section .data
  13 09f8 EC090000 	>>>  .int _thread
  13              	>>>  .set _thread,.
  13              	>>> 8:
  13              	>>>  hstring "and"
  13 09fc 03       	>>>>  .byte lex+9f-(.+1)
  13 09fd 616E64   	>>>>  .ascii "and"
  13              	>>>> 9:
  13              	>>>>  .balign 4,0
  13              	>>>  .set lex,0
  13 0a00 B80E0000 	>>>  .int and_
  13              	>>>  .previous
  13              	>>  .balign 4,0
  13 0eb4 FC090000 	>>  .int _thread
  13              	> and_:
  14 0eb8 02BC     	  pop { r1 }
  15 0eba 0840     	  ands r0, r0, r1
  16              	  next
  16 0ebc 7047     	>  bx lr
  17              	
  18              	@ ------------------------------------------------------------------------
  19              	
  20              	@       ( n1 n2 --- n3 )
  21              	
  22              	code "or", or_
  22              	>  header "or",or_
  22              	>>  _header_ "or",or_
  22              	>>>  .section .data
  22 0a04 FC090000 	>>>  .int _thread
  22              	>>>  .set _thread,.
  22              	>>> 8:
  22              	>>>  hstring "or"
  22 0a08 02       	>>>>  .byte lex+9f-(.+1)
  22 0a09 6F72     	>>>>  .ascii "or"
  22              	>>>> 9:
  22 0a0b 00       	>>>>  .balign 4,0
  22              	>>>  .set lex,0
  22 0a0c C40E0000 	>>>  .int or_
  22              	>>>  .previous
  22 0ebe 0000     	>>  .balign 4,0
  22 0ec0 080A0000 	>>  .int _thread
  22              	> or_:
  23 0ec4 02BC     	  pop { r1 }
  24 0ec6 0843     	  orrs r0, r0, r1
  25              	  next
  25 0ec8 7047     	>  bx lr
  26              	
  27              	@ ------------------------------------------------------------------------
  28              	
  29              	@       ( n1 n2 --- n3 )
  30              	
  31              	code "xor", xor
  31              	>  header "xor",xor
  31              	>>  _header_ "xor",xor
  31              	>>>  .section .data
  31 0a10 080A0000 	>>>  .int _thread
  31              	>>>  .set _thread,.
  31              	>>> 8:
  31              	>>>  hstring "xor"
  31 0a14 03       	>>>>  .byte lex+9f-(.+1)
  31 0a15 786F72   	>>>>  .ascii "xor"
  31              	>>>> 9:
  31              	>>>>  .balign 4,0
  31              	>>>  .set lex,0
  31 0a18 D00E0000 	>>>  .int xor
  31              	>>>  .previous
  31 0eca 0000     	>>  .balign 4,0
  31 0ecc 140A0000 	>>  .int _thread
  31              	> xor:
  32 0ed0 02BC     	  pop { r1 }
  33 0ed2 4840     	  eors r0, r0, r1
  34              	  next
  34 0ed4 7047     	>  bx lr
  35              	
  36              	@ ------------------------------------------------------------------------
  37              	
  38              	@       ( n1 --- n3 )
  39              	
  40              	code "not", not
  40              	>  header "not",not
  40              	>>  _header_ "not",not
  40              	>>>  .section .data
  40 0a1c 140A0000 	>>>  .int _thread
  40              	>>>  .set _thread,.
  40              	>>> 8:
  40              	>>>  hstring "not"
  40 0a20 03       	>>>>  .byte lex+9f-(.+1)
  40 0a21 6E6F74   	>>>>  .ascii "not"
  40              	>>>> 9:
  40              	>>>>  .balign 4,0
  40              	>>>  .set lex,0
  40 0a24 DC0E0000 	>>>  .int not
  40              	>>>  .previous
  40 0ed6 0000     	>>  .balign 4,0
  40 0ed8 200A0000 	>>  .int _thread
  40              	> not:
  41 0edc C043     	  mvns r0, r0
  42              	  next
  42 0ede 7047     	>  bx lr
  43              	
  44              	@ ------------------------------------------------------------------------
  45              	
  46              	@       ( n1 --- f1 )
  47              	
  48              	code "0=", zequals
  48              	>  header "0=",zequals
  48              	>>  _header_ "0=",zequals
  48              	>>>  .section .data
  48 0a28 200A0000 	>>>  .int _thread
  48              	>>>  .set _thread,.
  48              	>>> 8:
  48              	>>>  hstring "0="
  48 0a2c 02       	>>>>  .byte lex+9f-(.+1)
  48 0a2d 303D     	>>>>  .ascii "0="
  48              	>>>> 9:
  48 0a2f 00       	>>>>  .balign 4,0
  48              	>>>  .set lex,0
  48 0a30 E40E0000 	>>>  .int zequals
  48              	>>>  .previous
  48              	>>  .balign 4,0
  48 0ee0 2C0A0000 	>>  .int _thread
  48              	> zequals:
  49 0ee4 0138     	  subs r0, r0, #1
  50 0ee6 8041     	  sbcs r0, r0, r0
  51              	  next
  51 0ee8 7047     	>  bx lr
  52              	
  53              	@ ------------------------------------------------------------------------
  54              	
  55              	@       ( d1 --- f1 )
  56              	
  57              	code "d0=", dzequ
  57              	>  header "d0=",dzequ
  57              	>>  _header_ "d0=",dzequ
  57              	>>>  .section .data
  57 0a34 2C0A0000 	>>>  .int _thread
  57              	>>>  .set _thread,.
  57              	>>> 8:
  57              	>>>  hstring "d0="
  57 0a38 03       	>>>>  .byte lex+9f-(.+1)
  57 0a39 64303D   	>>>>  .ascii "d0="
  57              	>>>> 9:
  57              	>>>>  .balign 4,0
  57              	>>>  .set lex,0
  57 0a3c F00E0000 	>>>  .int dzequ
  57              	>>>  .previous
  57 0eea 0000     	>>  .balign 4,0
  57 0eec 380A0000 	>>  .int _thread
  57              	> dzequ:
  58 0ef0 02BC     	  pop { r1 }
  59 0ef2 40EA0100 	  orr r0, r0, r1
  60 0ef6 F5E7     	  b zequals
  61              	
  62              	@ ------------------------------------------------------------------------
  63              	
  64              	@       ( n1 --- f1 )
  65              	
  66              	code "0<>", znotequ
  66              	>  header "0<>",znotequ
  66              	>>  _header_ "0<>",znotequ
  66              	>>>  .section .data
  66 0a40 380A0000 	>>>  .int _thread
  66              	>>>  .set _thread,.
  66              	>>> 8:
  66              	>>>  hstring "0<>"
  66 0a44 03       	>>>>  .byte lex+9f-(.+1)
  66 0a45 303C3E   	>>>>  .ascii "0<>"
  66              	>>>> 9:
  66              	>>>>  .balign 4,0
  66              	>>>  .set lex,0
  66 0a48 FC0E0000 	>>>  .int znotequ
  66              	>>>  .previous
  66              	>>  .balign 4,0
  66 0ef8 440A0000 	>>  .int _thread
  66              	> znotequ:
  67 0efc 0138     	  subs r0, r0, #1
  68 0efe 60EB0000 	  sbc r0, r0, r0
  69 0f02 6FEA0000 	  mvn r0, r0
  70              	  next
  70 0f06 7047     	>  bx lr
  71              	
  72              	@ ------------------------------------------------------------------------
  73              	
  74              	@       ( n1 n2 --- f1 )
  75              	
  76              	code "=", equals
  76              	>  header "=",equals
  76              	>>  _header_ "=",equals
  76              	>>>  .section .data
  76 0a4c 440A0000 	>>>  .int _thread
  76              	>>>  .set _thread,.
  76              	>>> 8:
  76              	>>>  hstring "="
  76 0a50 01       	>>>>  .byte lex+9f-(.+1)
  76 0a51 3D       	>>>>  .ascii "="
  76              	>>>> 9:
  76 0a52 0000     	>>>>  .balign 4,0
  76              	>>>  .set lex,0
  76 0a54 0C0F0000 	>>>  .int equals
  76              	>>>  .previous
  76              	>>  .balign 4,0
  76 0f08 500A0000 	>>  .int _thread
  76              	> equals:
  77 0f0c 02BC     	  pop { r1 }
  78 0f0e 401A     	  subs r0, r0, r1
  79 0f10 0138     	  subs r0, r0, #1
  80 0f12 8041     	  sbcs r0, r0, r0
  81              	  next
  81 0f14 7047     	>  bx lr
  82              	
  83              	@ ------------------------------------------------------------------------
  84              	
  85              	@       ( n1 n2 --- f1 )
  86              	
  87              	colon "<>", notequals
  87              	>  header "<>",notequals
  87              	>>  _header_ "<>",notequals
  87              	>>>  .section .data
  87 0a58 500A0000 	>>>  .int _thread
  87              	>>>  .set _thread,.
  87              	>>> 8:
  87              	>>>  hstring "<>"
  87 0a5c 02       	>>>>  .byte lex+9f-(.+1)
  87 0a5d 3C3E     	>>>>  .ascii "<>"
  87              	>>>> 9:
  87 0a5f 00       	>>>>  .balign 4,0
  87              	>>>  .set lex,0
  87 0a60 1C0F0000 	>>>  .int notequals
  87              	>>>  .previous
  87 0f16 0000     	>>  .balign 4,0
  87 0f18 5C0A0000 	>>  .int _thread
  87              	> notequals:
  87 0f1c AFF30080 	>  nop.w
  87              	>  rpush lr
  87 0f20 4CF804ED 	>>  str lr,[rp,#-4]!
  88 0f24 FFF7F2FF 	  bl equals
  89 0f28 FFF7D8FF 	  bl not
  90              	  exit
  90              	>  rpop pc
  90 0f2c 5CF804FB 	>>  ldr pc,[rp],#4
  91              	
  92              	@ ------------------------------------------------------------------------
  93              	
  94              	@       ( n1 --- f1 )
  95              	
  96              	code "0<", zless
  96              	>  header "0<",zless
  96              	>>  _header_ "0<",zless
  96              	>>>  .section .data
  96 0a64 5C0A0000 	>>>  .int _thread
  96              	>>>  .set _thread,.
  96              	>>> 8:
  96              	>>>  hstring "0<"
  96 0a68 02       	>>>>  .byte lex+9f-(.+1)
  96 0a69 303C     	>>>>  .ascii "0<"
  96              	>>>> 9:
  96 0a6b 00       	>>>>  .balign 4,0
  96              	>>>  .set lex,0
  96 0a6c 340F0000 	>>>  .int zless
  96              	>>>  .previous
  96              	>>  .balign 4,0
  96 0f30 680A0000 	>>  .int _thread
  96              	> zless:
  97 0f34 C017     	  movs r0, r0, asr #31
  98              	  next
  98 0f36 7047     	>  bx lr
  99              	
 100              	@ ------------------------------------------------------------------------
 101              	
 102              	@       ( n1 --- f1 )
 103              	
 104              	code "0>", zgreater
 104              	>  header "0>",zgreater
 104              	>>  _header_ "0>",zgreater
 104              	>>>  .section .data
 104 0a70 680A0000 	>>>  .int _thread
 104              	>>>  .set _thread,.
 104              	>>> 8:
 104              	>>>  hstring "0>"
 104 0a74 02       	>>>>  .byte lex+9f-(.+1)
 104 0a75 303E     	>>>>  .ascii "0>"
 104              	>>>> 9:
 104 0a77 00       	>>>>  .balign 4,0
 104              	>>>  .set lex,0
 104 0a78 3C0F0000 	>>>  .int zgreater
 104              	>>>  .previous
 104              	>>  .balign 4,0
 104 0f38 740A0000 	>>  .int _thread
 104              	> zgreater:
 105 0f3c C0F10000 	  rsb r0, r0, #0
 106 0f40 C017     	  movs r0, r0, asr #31
 107              	  next
 107 0f42 7047     	>  bx lr
 108              	
 109              	@ ------------------------------------------------------------------------
 110              	
 111              	@       ( n1 n2 --- n3 )
 112              	
 113              	code "u<", uless
 113              	>  header "u<",uless
 113              	>>  _header_ "u<",uless
 113              	>>>  .section .data
 113 0a7c 740A0000 	>>>  .int _thread
 113              	>>>  .set _thread,.
 113              	>>> 8:
 113              	>>>  hstring "u<"
 113 0a80 02       	>>>>  .byte lex+9f-(.+1)
 113 0a81 753C     	>>>>  .ascii "u<"
 113              	>>>> 9:
 113 0a83 00       	>>>>  .balign 4,0
 113              	>>>  .set lex,0
 113 0a84 480F0000 	>>>  .int uless
 113              	>>>  .previous
 113              	>>  .balign 4,0
 113 0f44 800A0000 	>>  .int _thread
 113              	> uless:
 114 0f48 02BC     	  pop { r1 }
 115 0f4a 081A     	  subs r0, r1, r0
 116 0f4c 8041     	  sbcs r0, r0, r0
 117              	  next
 117 0f4e 7047     	>  bx lr
 118              	
 119              	@ ------------------------------------------------------------------------
 120              	
 121              	@       ( n1 n2 --- n3 )
 122              	
 123              	code "u>", ugreater
 123              	>  header "u>",ugreater
 123              	>>  _header_ "u>",ugreater
 123              	>>>  .section .data
 123 0a88 800A0000 	>>>  .int _thread
 123              	>>>  .set _thread,.
 123              	>>> 8:
 123              	>>>  hstring "u>"
 123 0a8c 02       	>>>>  .byte lex+9f-(.+1)
 123 0a8d 753E     	>>>>  .ascii "u>"
 123              	>>>> 9:
 123 0a8f 00       	>>>>  .balign 4,0
 123              	>>>  .set lex,0
 123 0a90 540F0000 	>>>  .int ugreater
 123              	>>>  .previous
 123              	>>  .balign 4,0
 123 0f50 8C0A0000 	>>  .int _thread
 123              	> ugreater:
 124 0f54 02BC     	  pop { r1 }
 125 0f56 401A     	  subs r0, r0, r1
 126 0f58 8041     	  sbcs r0, r0, r0
 127              	  next
 127 0f5a 7047     	>  bx lr
 128              	
 129              	@ ------------------------------------------------------------------------
 130              	
 131              	@       ( n1 n2 --- n3 )
 132              	
 133              	code "<", less
 133              	>  header "<",less
 133              	>>  _header_ "<",less
 133              	>>>  .section .data
 133 0a94 8C0A0000 	>>>  .int _thread
 133              	>>>  .set _thread,.
 133              	>>> 8:
 133              	>>>  hstring "<"
 133 0a98 01       	>>>>  .byte lex+9f-(.+1)
 133 0a99 3C       	>>>>  .ascii "<"
 133              	>>>> 9:
 133 0a9a 0000     	>>>>  .balign 4,0
 133              	>>>  .set lex,0
 133 0a9c 600F0000 	>>>  .int less
 133              	>>>  .previous
 133              	>>  .balign 4,0
 133 0f5c 980A0000 	>>  .int _thread
 133              	> less:
 134 0f60 02BC     	  pop { r1 }
 135 0f62 8142     	  cmp r1, r0
 136 0f64 B4BF     	  ite lt
 137 0f66 4FF0FF30 	  movlt r0, #-1
 138 0f6a 0020     	  movge r0, #0
 139              	  next
 139 0f6c 7047     	>  bx lr
 140              	
 141              	@-------------------------------------------------------------------------
 142              	
 143              	@       ( n1 n2 --- n3 )
 144              	
 145              	code ">", greater
 145              	>  header ">",greater
 145              	>>  _header_ ">",greater
 145              	>>>  .section .data
 145 0aa0 980A0000 	>>>  .int _thread
 145              	>>>  .set _thread,.
 145              	>>> 8:
 145              	>>>  hstring ">"
 145 0aa4 01       	>>>>  .byte lex+9f-(.+1)
 145 0aa5 3E       	>>>>  .ascii ">"
 145              	>>>> 9:
 145 0aa6 0000     	>>>>  .balign 4,0
 145              	>>>  .set lex,0
 145 0aa8 740F0000 	>>>  .int greater
 145              	>>>  .previous
 145 0f6e 0000     	>>  .balign 4,0
 145 0f70 A40A0000 	>>  .int _thread
 145              	> greater:
 146 0f74 02BC     	  pop { r1 }
 147 0f76 8142     	  cmp r1, r0
 148 0f78 CCBF     	  ite gt
 149 0f7a 4FF0FF30 	  movgt r0, #-1
 150 0f7e 0020     	  movle r0, #0
 151              	  next
 151 0f80 7047     	>  bx lr
 152              	
 153              	@ ------------------------------------------------------------------------
 154              	
 155              	@     ( d1 d2 --- f1 )
 156              	
 157              	colon "d=", dequals
 157              	>  header "d=",dequals
 157              	>>  _header_ "d=",dequals
 157              	>>>  .section .data
 157 0aac A40A0000 	>>>  .int _thread
 157              	>>>  .set _thread,.
 157              	>>> 8:
 157              	>>>  hstring "d="
 157 0ab0 02       	>>>>  .byte lex+9f-(.+1)
 157 0ab1 643D     	>>>>  .ascii "d="
 157              	>>>> 9:
 157 0ab3 00       	>>>>  .balign 4,0
 157              	>>>  .set lex,0
 157 0ab4 880F0000 	>>>  .int dequals
 157              	>>>  .previous
 157 0f82 0000     	>>  .balign 4,0
 157 0f84 B00A0000 	>>  .int _thread
 157              	> dequals:
 157 0f88 AFF30080 	>  nop.w
 157              	>  rpush lr
 157 0f8c 4CF804ED 	>>  str lr,[rp,#-4]!
 158 0f90 FFF76EFE 	  bl dminus
 159 0f94 FFF796FF 	  bl or_
 160 0f98 FFF7A4FF 	  bl zequals
 161              	  exit
 161              	>  rpop pc
 161 0f9c 5CF804FB 	>>  ldr pc,[rp],#4
 162              	
 163              	@ ------------------------------------------------------------------------
 164              	
 165              	@       ( d1 --- f1 )
 166              	
 167              	code "d0<", dzless
 167              	>  header "d0<",dzless
 167              	>>  _header_ "d0<",dzless
 167              	>>>  .section .data
 167 0ab8 B00A0000 	>>>  .int _thread
 167              	>>>  .set _thread,.
 167              	>>> 8:
 167              	>>>  hstring "d0<"
 167 0abc 03       	>>>>  .byte lex+9f-(.+1)
 167 0abd 64303C   	>>>>  .ascii "d0<"
 167              	>>>> 9:
 167              	>>>>  .balign 4,0
 167              	>>>  .set lex,0
 167 0ac0 A40F0000 	>>>  .int dzless
 167              	>>>  .previous
 167              	>>  .balign 4,0
 167 0fa0 BC0A0000 	>>  .int _thread
 167              	> dzless:
 168 0fa4 01B0     	  add sp, sp, #4
 169 0fa6 C017     	  movs r0, r0, asr #31
 170              	  next
 170 0fa8 7047     	>  bx lr
 171              	
 172              	@ ------------------------------------------------------------------------
 173              	
 174              	@       ( d1 d2 --- f1 )
 175              	
 176              	colon "d<", dless
 176              	>  header "d<",dless
 176              	>>  _header_ "d<",dless
 176              	>>>  .section .data
 176 0ac4 BC0A0000 	>>>  .int _thread
 176              	>>>  .set _thread,.
 176              	>>> 8:
 176              	>>>  hstring "d<"
 176 0ac8 02       	>>>>  .byte lex+9f-(.+1)
 176 0ac9 643C     	>>>>  .ascii "d<"
 176              	>>>> 9:
 176 0acb 00       	>>>>  .balign 4,0
 176              	>>>  .set lex,0
 176 0acc B00F0000 	>>>  .int dless
 176              	>>>  .previous
 176 0faa 0000     	>>  .balign 4,0
 176 0fac C80A0000 	>>  .int _thread
 176              	> dless:
 176 0fb0 AFF30080 	>  nop.w
 176              	>  rpush lr
 176 0fb4 4CF804ED 	>>  str lr,[rp,#-4]!
 177 0fb8 FFF75AFE 	  bl dminus
 178 0fbc FFF7F2FF 	  bl dzless
 179              	  next
 179 0fc0 7047     	>  bx lr
 180              	
 181              	@ ------------------------------------------------------------------------
 182              	
 183              	@       ( d1 d2 --- f1 )
 184              	
 185              	colon "d>", dgreater
 185              	>  header "d>",dgreater
 185              	>>  _header_ "d>",dgreater
 185              	>>>  .section .data
 185 0ad0 C80A0000 	>>>  .int _thread
 185              	>>>  .set _thread,.
 185              	>>> 8:
 185              	>>>  hstring "d>"
 185 0ad4 02       	>>>>  .byte lex+9f-(.+1)
 185 0ad5 643E     	>>>>  .ascii "d>"
 185              	>>>> 9:
 185 0ad7 00       	>>>>  .balign 4,0
 185              	>>>  .set lex,0
 185 0ad8 C80F0000 	>>>  .int dgreater
 185              	>>>  .previous
 185 0fc2 0000     	>>  .balign 4,0
 185 0fc4 D40A0000 	>>  .int _thread
 185              	> dgreater:
 185 0fc8 AFF30080 	>  nop.w
 185              	>  rpush lr
 185 0fcc 4CF804ED 	>>  str lr,[rp,#-4]!
 186 0fd0 FFF7B0FA 	  bl twoswap
 187 0fd4 FFF7ECFF 	  bl dless
 188              	  exit
 188              	>  rpop pc
 188 0fd8 5CF804FB 	>>  ldr pc,[rp],#4
 189              	
 190              	@ ------------------------------------------------------------------------
 191              	
 192              	@       ( d1 d2 -- f1 )
 193              	
 194              	colon "d<>", dnotequ
 194              	>  header "d<>",dnotequ
 194              	>>  _header_ "d<>",dnotequ
 194              	>>>  .section .data
 194 0adc D40A0000 	>>>  .int _thread
 194              	>>>  .set _thread,.
 194              	>>> 8:
 194              	>>>  hstring "d<>"
 194 0ae0 03       	>>>>  .byte lex+9f-(.+1)
 194 0ae1 643C3E   	>>>>  .ascii "d<>"
 194              	>>>> 9:
 194              	>>>>  .balign 4,0
 194              	>>>  .set lex,0
 194 0ae4 E00F0000 	>>>  .int dnotequ
 194              	>>>  .previous
 194              	>>  .balign 4,0
 194 0fdc E00A0000 	>>  .int _thread
 194              	> dnotequ:
 194 0fe0 AFF30080 	>  nop.w
 194              	>  rpush lr
 194 0fe4 4CF804ED 	>>  str lr,[rp,#-4]!
 195 0fe8 FFF7CEFF 	  bl dequals
 196 0fec FFF776FF 	  bl not
 197              	  exit
 197              	>  rpop pc
 197 0ff0 5CF804FB 	>>  ldr pc,[rp],#4
 198              	
 199              	@ ------------------------------------------------------------------------
 200              	
 201              	@     ( n1 n2 --- n1 | n2 )
 202              	
 203              	code "min", min
 203              	>  header "min",min
 203              	>>  _header_ "min",min
 203              	>>>  .section .data
 203 0ae8 E00A0000 	>>>  .int _thread
 203              	>>>  .set _thread,.
 203              	>>> 8:
 203              	>>>  hstring "min"
 203 0aec 03       	>>>>  .byte lex+9f-(.+1)
 203 0aed 6D696E   	>>>>  .ascii "min"
 203              	>>>> 9:
 203              	>>>>  .balign 4,0
 203              	>>>  .set lex,0
 203 0af0 F80F0000 	>>>  .int min
 203              	>>>  .previous
 203              	>>  .balign 4,0
 203 0ff4 EC0A0000 	>>  .int _thread
 203              	> min:
 204 0ff8 02BC     	  pop { r1 }
 205 0ffa 8842     	  cmp r0, r1
 206 0ffc C8BF     	  it gt
 207 0ffe 0846     	  movgt r0, r1
 208              	  next
 208 1000 7047     	>  bx lr
 209              	
 210              	@ ------------------------------------------------------------------------
 211              	
 212              	@     ( n1 n2 --- n1 | n2 )
 213              	
 214              	code "max", max
 214              	>  header "max",max
 214              	>>  _header_ "max",max
 214              	>>>  .section .data
 214 0af4 EC0A0000 	>>>  .int _thread
 214              	>>>  .set _thread,.
 214              	>>> 8:
 214              	>>>  hstring "max"
 214 0af8 03       	>>>>  .byte lex+9f-(.+1)
 214 0af9 6D6178   	>>>>  .ascii "max"
 214              	>>>> 9:
 214              	>>>>  .balign 4,0
 214              	>>>  .set lex,0
 214 0afc 08100000 	>>>  .int max
 214              	>>>  .previous
 214 1002 0000     	>>  .balign 4,0
 214 1004 F80A0000 	>>  .int _thread
 214              	> max:
 215 1008 02BC     	  pop { r1 }
 216 100a 8842     	  cmp r0, r1
 217 100c B8BF     	  it lt
 218 100e 0846     	  movlt r0, r1
 219              	  next
 219 1010 7047     	>  bx lr
 220              	
 221              	@ ------------------------------------------------------------------------
 222              	
 223              	@     ( n1 n2 --- n1 | n2 )
 224              	
 225              	code "umin", umin
 225              	>  header "umin",umin
 225              	>>  _header_ "umin",umin
 225              	>>>  .section .data
 225 0b00 F80A0000 	>>>  .int _thread
 225              	>>>  .set _thread,.
 225              	>>> 8:
 225              	>>>  hstring "umin"
 225 0b04 04       	>>>>  .byte lex+9f-(.+1)
 225 0b05 756D696E 	>>>>  .ascii "umin"
 225              	>>>> 9:
 225 0b09 000000   	>>>>  .balign 4,0
 225              	>>>  .set lex,0
 225 0b0c 18100000 	>>>  .int umin
 225              	>>>  .previous
 225 1012 0000     	>>  .balign 4,0
 225 1014 040B0000 	>>  .int _thread
 225              	> umin:
 226 1018 02BC     	  pop { r1 }
 227 101a 8842     	  cmp r0, r1
 228 101c 88BF     	  it hi
 229 101e 0846     	  movhi r0, r1
 230              	  next
 230 1020 7047     	>  bx lr
 231              	
 232              	@ ------------------------------------------------------------------------
 233              	
 234              	@     ( n1 n2 --- n1 | n2 )
 235              	
 236              	code "umax", umax
 236              	>  header "umax",umax
 236              	>>  _header_ "umax",umax
 236              	>>>  .section .data
 236 0b10 040B0000 	>>>  .int _thread
 236              	>>>  .set _thread,.
 236              	>>> 8:
 236              	>>>  hstring "umax"
 236 0b14 04       	>>>>  .byte lex+9f-(.+1)
 236 0b15 756D6178 	>>>>  .ascii "umax"
 236              	>>>> 9:
 236 0b19 000000   	>>>>  .balign 4,0
 236              	>>>  .set lex,0
 236 0b1c 28100000 	>>>  .int umax
 236              	>>>  .previous
 236 1022 0000     	>>  .balign 4,0
 236 1024 140B0000 	>>  .int _thread
 236              	> umax:
 237 1028 02BC     	  pop { r1 }
 238 102a 8842     	  cmp r0, r1
 239 102c 38BF     	  it lo
 240 102e 0846     	  movlo r0, r1
 241              	  next
 241 1030 7047     	>  bx lr
 242              	
 243              	@ ------------------------------------------------------------------------
 244              	
 245              	@     ( n1 lower upper --- f1 )
 246              	
 247              	code "between", between
 247              	>  header "between",between
 247              	>>  _header_ "between",between
 247              	>>>  .section .data
 247 0b20 140B0000 	>>>  .int _thread
 247              	>>>  .set _thread,.
 247              	>>> 8:
 247              	>>>  hstring "between"
 247 0b24 07       	>>>>  .byte lex+9f-(.+1)
 247 0b25 62657477 	>>>>  .ascii "between"
 247      65656E
 247              	>>>> 9:
 247              	>>>>  .balign 4,0
 247              	>>>  .set lex,0
 247 0b2c 38100000 	>>>  .int between
 247              	>>>  .previous
 247 1032 0000     	>>  .balign 4,0
 247 1034 240B0000 	>>  .int _thread
 247              	> between:
 248 1038 06BC     	  pop { r1, r2 }
 249 103a 8242     	  cmp r2, r0
 250 103c D8BF     	  it le
 251 103e 9142     	  cmple r1, r2
 252 1040 D4BF     	  ite le
 253 1042 6FF00000 	  mvnle r0, #0
 254 1046 0020     	  movgt r0, #0
 255              	  next
 255 1048 7047     	>  bx lr
 256              	
 257              	@ ------------------------------------------------------------------------
 258              	
 259              	@     ( n1 lower upper --- f1 )
 260              	
 261              	code "within", within
 261              	>  header "within",within
 261              	>>  _header_ "within",within
 261              	>>>  .section .data
 261 0b30 240B0000 	>>>  .int _thread
 261              	>>>  .set _thread,.
 261              	>>> 8:
 261              	>>>  hstring "within"
 261 0b34 06       	>>>>  .byte lex+9f-(.+1)
 261 0b35 77697468 	>>>>  .ascii "within"
 261      696E
 261              	>>>> 9:
 261 0b3b 00       	>>>>  .balign 4,0
 261              	>>>  .set lex,0
 261 0b3c 50100000 	>>>  .int within
 261              	>>>  .previous
 261 104a 0000     	>>  .balign 4,0
 261 104c 340B0000 	>>  .int _thread
 261              	> within:
 262 1050 06BC     	  pop { r1, r2 }
 263 1052 8242     	  cmp r2, r0
 264 1054 B8BF     	  it lt
 265 1056 9142     	  cmplt r1, r2
 266 1058 B4BF     	  ite lt
 267 105a 6FF00000 	  mvnlt r0, #0
 268 105e 0020     	  movge r0, #0
 269              	  next
 269 1060 7047     	>  bx lr
 270              	
 271              	@ ========================================================================
 316              	  .include "io.s"           @ basic i/o
   1              	@ io.s    - basic i/o
   2              	@ ------------------------------------------------------------------------
   3              	
   4              	@ ------------------------------------------------------------------------
   5              	
   6              	  _constant_ "rows", rows, 25
   6              	>  header "rows",rows
   6              	>>  _header_ "rows",rows
   6              	>>>  .section .data
   6 0b40 340B0000 	>>>  .int _thread
   6              	>>>  .set _thread,.
   6              	>>> 8:
   6              	>>>  hstring "rows"
   6 0b44 04       	>>>>  .byte lex+9f-(.+1)
   6 0b45 726F7773 	>>>>  .ascii "rows"
   6              	>>>> 9:
   6 0b49 000000   	>>>>  .balign 4,0
   6              	>>>  .set lex,0
   6 0b4c 68100000 	>>>  .int rows
   6              	>>>  .previous
   6 1062 0000     	>>  .balign 4,0
   6 1064 440B0000 	>>  .int _thread
   6              	> rows:
   6              	>  rpush lr
   6 1068 4CF804ED 	>>  str lr,[rp,#-4]!
   6 106c FFF784F9 	>  bl dovar
   6 1070 19000000 	>  .int 25
   7              	  _constant_ "cols", cols, 80
   7              	>  header "cols",cols
   7              	>>  _header_ "cols",cols
   7              	>>>  .section .data
   7 0b50 440B0000 	>>>  .int _thread
   7              	>>>  .set _thread,.
   7              	>>> 8:
   7              	>>>  hstring "cols"
   7 0b54 04       	>>>>  .byte lex+9f-(.+1)
   7 0b55 636F6C73 	>>>>  .ascii "cols"
   7              	>>>> 9:
   7 0b59 000000   	>>>>  .balign 4,0
   7              	>>>  .set lex,0
   7 0b5c 78100000 	>>>  .int cols
   7              	>>>  .previous
   7              	>>  .balign 4,0
   7 1074 540B0000 	>>  .int _thread
   7              	> cols:
   7              	>  rpush lr
   7 1078 4CF804ED 	>>  str lr,[rp,#-4]!
   7 107c FFF77CF9 	>  bl dovar
   7 1080 50000000 	>  .int 80
   8              	  _constant_ "bl",   bl_,  0x20
   8              	>  header "bl",bl_
   8              	>>  _header_ "bl",bl_
   8              	>>>  .section .data
   8 0b60 540B0000 	>>>  .int _thread
   8              	>>>  .set _thread,.
   8              	>>> 8:
   8              	>>>  hstring "bl"
   8 0b64 02       	>>>>  .byte lex+9f-(.+1)
   8 0b65 626C     	>>>>  .ascii "bl"
   8              	>>>> 9:
   8 0b67 00       	>>>>  .balign 4,0
   8              	>>>  .set lex,0
   8 0b68 88100000 	>>>  .int bl_
   8              	>>>  .previous
   8              	>>  .balign 4,0
   8 1084 640B0000 	>>  .int _thread
   8              	> bl_:
   8              	>  rpush lr
   8 1088 4CF804ED 	>>  str lr,[rp,#-4]!
   8 108c FFF774F9 	>  bl dovar
   8 1090 20000000 	>  .int 0x20
   9              	
  10              	@ ------------------------------------------------------------------------
  11              	
  12              	  _defer_ "source", source, psource
  12              	>  header "source",source
  12              	>>  _header_ "source",source
  12              	>>>  .section .data
  12 0b6c 640B0000 	>>>  .int _thread
  12              	>>>  .set _thread,.
  12              	>>> 8:
  12              	>>>  hstring "source"
  12 0b70 06       	>>>>  .byte lex+9f-(.+1)
  12 0b71 736F7572 	>>>>  .ascii "source"
  12      6365
  12              	>>>> 9:
  12 0b77 00       	>>>>  .balign 4,0
  12              	>>>  .set lex,0
  12 0b78 98100000 	>>>  .int source
  12              	>>>  .previous
  12              	>>  .balign 4,0
  12 1094 700B0000 	>>  .int _thread
  12              	> source:
  12              	>  rpush lr
  12 1098 4CF804ED 	>>  str lr,[rp,#-4]!
  12 109c FFF762F9 	>  bl dodefer
  12 10a0 48110000 	>  .int psource
  13              	  _defer_ "refill", refill, query
  13              	>  header "refill",refill
  13              	>>  _header_ "refill",refill
  13              	>>>  .section .data
  13 0b7c 700B0000 	>>>  .int _thread
  13              	>>>  .set _thread,.
  13              	>>> 8:
  13              	>>>  hstring "refill"
  13 0b80 06       	>>>>  .byte lex+9f-(.+1)
  13 0b81 72656669 	>>>>  .ascii "refill"
  13      6C6C
  13              	>>>> 9:
  13 0b87 00       	>>>>  .balign 4,0
  13              	>>>  .set lex,0
  13 0b88 A8100000 	>>>  .int refill
  13              	>>>  .previous
  13              	>>  .balign 4,0
  13 10a4 800B0000 	>>  .int _thread
  13              	> refill:
  13              	>  rpush lr
  13 10a8 4CF804ED 	>>  str lr,[rp,#-4]!
  13 10ac FFF75AF9 	>  bl dodefer
  13 10b0 B4140000 	>  .int query
  14              	  _defer_ "emit", emit, pemit
  14              	>  header "emit",emit
  14              	>>  _header_ "emit",emit
  14              	>>>  .section .data
  14 0b8c 800B0000 	>>>  .int _thread
  14              	>>>  .set _thread,.
  14              	>>> 8:
  14              	>>>  hstring "emit"
  14 0b90 04       	>>>>  .byte lex+9f-(.+1)
  14 0b91 656D6974 	>>>>  .ascii "emit"
  14              	>>>> 9:
  14 0b95 000000   	>>>>  .balign 4,0
  14              	>>>  .set lex,0
  14 0b98 B8100000 	>>>  .int emit
  14              	>>>  .previous
  14              	>>  .balign 4,0
  14 10b4 900B0000 	>>  .int _thread
  14              	> emit:
  14              	>  rpush lr
  14 10b8 4CF804ED 	>>  str lr,[rp,#-4]!
  14 10bc FFF752F9 	>  bl dodefer
  14 10c0 60110000 	>  .int pemit
  15              	  _defer_ "type", type, ptype
  15              	>  header "type",type
  15              	>>  _header_ "type",type
  15              	>>>  .section .data
  15 0b9c 900B0000 	>>>  .int _thread
  15              	>>>  .set _thread,.
  15              	>>> 8:
  15              	>>>  hstring "type"
  15 0ba0 04       	>>>>  .byte lex+9f-(.+1)
  15 0ba1 74797065 	>>>>  .ascii "type"
  15              	>>>> 9:
  15 0ba5 000000   	>>>>  .balign 4,0
  15              	>>>  .set lex,0
  15 0ba8 C8100000 	>>>  .int type
  15              	>>>  .previous
  15              	>>  .balign 4,0
  15 10c4 A00B0000 	>>  .int _thread
  15              	> type:
  15              	>  rpush lr
  15 10c8 4CF804ED 	>>  str lr,[rp,#-4]!
  15 10cc FFF74AF9 	>  bl dodefer
  15 10d0 F8110000 	>  .int ptype
  16              	  _defer_ "key", key, pkey
  16              	>  header "key",key
  16              	>>  _header_ "key",key
  16              	>>>  .section .data
  16 0bac A00B0000 	>>>  .int _thread
  16              	>>>  .set _thread,.
  16              	>>> 8:
  16              	>>>  hstring "key"
  16 0bb0 03       	>>>>  .byte lex+9f-(.+1)
  16 0bb1 6B6579   	>>>>  .ascii "key"
  16              	>>>> 9:
  16              	>>>>  .balign 4,0
  16              	>>>  .set lex,0
  16 0bb4 D8100000 	>>>  .int key
  16              	>>>  .previous
  16              	>>  .balign 4,0
  16 10d4 B00B0000 	>>  .int _thread
  16              	> key:
  16              	>  rpush lr
  16 10d8 4CF804ED 	>>  str lr,[rp,#-4]!
  16 10dc FFF742F9 	>  bl dodefer
  16 10e0 C0110000 	>  .int pkey
  17              	
  18              	  _var_ "fdout", fdout, 1
  18              	>  header "fdout",fdout
  18              	>>  _header_ "fdout",fdout
  18              	>>>  .section .data
  18 0bb8 B00B0000 	>>>  .int _thread
  18              	>>>  .set _thread,.
  18              	>>> 8:
  18              	>>>  hstring "fdout"
  18 0bbc 05       	>>>>  .byte lex+9f-(.+1)
  18 0bbd 66646F75 	>>>>  .ascii "fdout"
  18      74
  18              	>>>> 9:
  18 0bc2 0000     	>>>>  .balign 4,0
  18              	>>>  .set lex,0
  18 0bc4 E8100000 	>>>  .int fdout
  18              	>>>  .previous
  18              	>>  .balign 4,0
  18 10e4 BC0B0000 	>>  .int _thread
  18              	> fdout:
  18              	>  rpush lr
  18 10e8 4CF804ED 	>>  str lr,[rp,#-4]!
  18 10ec FFF744F9 	>  bl dovar
  18 10f0 01000000 	>  .int 1
  19              	
  20              	  _var_ "#tib", numtib, 0
  20              	>  header "#tib",numtib
  20              	>>  _header_ "#tib",numtib
  20              	>>>  .section .data
  20 0bc8 BC0B0000 	>>>  .int _thread
  20              	>>>  .set _thread,.
  20              	>>> 8:
  20              	>>>  hstring "#tib"
  20 0bcc 04       	>>>>  .byte lex+9f-(.+1)
  20 0bcd 23746962 	>>>>  .ascii "#tib"
  20              	>>>> 9:
  20 0bd1 000000   	>>>>  .balign 4,0
  20              	>>>  .set lex,0
  20 0bd4 F8100000 	>>>  .int numtib
  20              	>>>  .previous
  20              	>>  .balign 4,0
  20 10f4 CC0B0000 	>>  .int _thread
  20              	> numtib:
  20              	>  rpush lr
  20 10f8 4CF804ED 	>>  str lr,[rp,#-4]!
  20 10fc FFF73CF9 	>  bl dovar
  20 1100 00000000 	>  .int 0
  21              	  _var_ ">in", toin, 0
  21              	>  header ">in",toin
  21              	>>  _header_ ">in",toin
  21              	>>>  .section .data
  21 0bd8 CC0B0000 	>>>  .int _thread
  21              	>>>  .set _thread,.
  21              	>>> 8:
  21              	>>>  hstring ">in"
  21 0bdc 03       	>>>>  .byte lex+9f-(.+1)
  21 0bdd 3E696E   	>>>>  .ascii ">in"
  21              	>>>> 9:
  21              	>>>>  .balign 4,0
  21              	>>>  .set lex,0
  21 0be0 08110000 	>>>  .int toin
  21              	>>>  .previous
  21              	>>  .balign 4,0
  21 1104 DC0B0000 	>>  .int _thread
  21              	> toin:
  21              	>  rpush lr
  21 1108 4CF804ED 	>>  str lr,[rp,#-4]!
  21 110c FFF734F9 	>  bl dovar
  21 1110 00000000 	>  .int 0
  22              	  _var_ "#out", numout, 0
  22              	>  header "#out",numout
  22              	>>  _header_ "#out",numout
  22              	>>>  .section .data
  22 0be4 DC0B0000 	>>>  .int _thread
  22              	>>>  .set _thread,.
  22              	>>> 8:
  22              	>>>  hstring "#out"
  22 0be8 04       	>>>>  .byte lex+9f-(.+1)
  22 0be9 236F7574 	>>>>  .ascii "#out"
  22              	>>>> 9:
  22 0bed 000000   	>>>>  .balign 4,0
  22              	>>>  .set lex,0
  22 0bf0 18110000 	>>>  .int numout
  22              	>>>  .previous
  22              	>>  .balign 4,0
  22 1114 E80B0000 	>>  .int _thread
  22              	> numout:
  22              	>  rpush lr
  22 1118 4CF804ED 	>>  str lr,[rp,#-4]!
  22 111c FFF72CF9 	>  bl dovar
  22 1120 00000000 	>  .int 0
  23              	  _var_ "#line", numline, 0
  23              	>  header "#line",numline
  23              	>>  _header_ "#line",numline
  23              	>>>  .section .data
  23 0bf4 E80B0000 	>>>  .int _thread
  23              	>>>  .set _thread,.
  23              	>>> 8:
  23              	>>>  hstring "#line"
  23 0bf8 05       	>>>>  .byte lex+9f-(.+1)
  23 0bf9 236C696E 	>>>>  .ascii "#line"
  23      65
  23              	>>>> 9:
  23 0bfe 0000     	>>>>  .balign 4,0
  23              	>>>  .set lex,0
  23 0c00 28110000 	>>>  .int numline
  23              	>>>  .previous
  23              	>>  .balign 4,0
  23 1124 F80B0000 	>>  .int _thread
  23              	> numline:
  23              	>  rpush lr
  23 1128 4CF804ED 	>>  str lr,[rp,#-4]!
  23 112c FFF724F9 	>  bl dovar
  23 1130 00000000 	>  .int 0
  24              	  _var_ "tib", tib, 0
  24              	>  header "tib",tib
  24              	>>  _header_ "tib",tib
  24              	>>>  .section .data
  24 0c04 F80B0000 	>>>  .int _thread
  24              	>>>  .set _thread,.
  24              	>>> 8:
  24              	>>>  hstring "tib"
  24 0c08 03       	>>>>  .byte lex+9f-(.+1)
  24 0c09 746962   	>>>>  .ascii "tib"
  24              	>>>> 9:
  24              	>>>>  .balign 4,0
  24              	>>>  .set lex,0
  24 0c0c 38110000 	>>>  .int tib
  24              	>>>  .previous
  24              	>>  .balign 4,0
  24 1134 080C0000 	>>  .int _thread
  24              	> tib:
  24              	>  rpush lr
  24 1138 4CF804ED 	>>  str lr,[rp,#-4]!
  24 113c FFF71CF9 	>  bl dovar
  24 1140 00000000 	>  .int 0
  25              	
  26              	@ ------------------------------------------------------------------------
  27              	@ return address and filled size of current input buffer
  28              	
  29              	@    ( --- a1 n1 )
  30              	
  31              	colon "(source)", psource
  31              	>  header "(source)",psource
  31              	>>  _header_ "(source)",psource
  31              	>>>  .section .data
  31 0c10 080C0000 	>>>  .int _thread
  31              	>>>  .set _thread,.
  31              	>>> 8:
  31              	>>>  hstring "(source)"
  31 0c14 08       	>>>>  .byte lex+9f-(.+1)
  31 0c15 28736F75 	>>>>  .ascii "(source)"
  31      72636529 
  31              	>>>> 9:
  31 0c1d 000000   	>>>>  .balign 4,0
  31              	>>>  .set lex,0
  31 0c20 48110000 	>>>  .int psource
  31              	>>>  .previous
  31              	>>  .balign 4,0
  31 1144 140C0000 	>>  .int _thread
  31              	> psource:
  31 1148 AFF30080 	>  nop.w
  31              	>  rpush lr
  31 114c 4CF804ED 	>>  str lr,[rp,#-4]!
  32 1150 FFF7F2FF 	  bl tib                    @ default input source is the terminal
  33 1154 FFF7D0FF 	  bl numtib                 @ input buffer. return its address and the
  34              	  exit                      @ number of characters it contains
  34              	>  rpop pc
  34 1158 5CF804FB 	>>  ldr pc,[rp],#4
  35              	
  36              	@ ------------------------------------------------------------------------
  37              	@ emit character to stdout
  38              	
  39              	@       ( c1 --- )
  40              	
  41              	colon "(emit)", pemit
  41              	>  header "(emit)",pemit
  41              	>>  _header_ "(emit)",pemit
  41              	>>>  .section .data
  41 0c24 140C0000 	>>>  .int _thread
  41              	>>>  .set _thread,.
  41              	>>> 8:
  41              	>>>  hstring "(emit)"
  41 0c28 06       	>>>>  .byte lex+9f-(.+1)
  41 0c29 28656D69 	>>>>  .ascii "(emit)"
  41      7429
  41              	>>>> 9:
  41 0c2f 00       	>>>>  .balign 4,0
  41              	>>>  .set lex,0
  41 0c30 60110000 	>>>  .int pemit
  41              	>>>  .previous
  41              	>>  .balign 4,0
  41 115c 280C0000 	>>  .int _thread
  41              	> pemit:
  41 1160 AFF30080 	>  nop.w
  41              	>  rpush lr
  41 1164 4CF804ED 	>>  str lr,[rp,#-4]!
  42 1168 FFF7BEFF 	  bl fdout                  @ file descriptor
  43 116c FFF752FA 	  bl spfetch                @ point to data to write
  44 1170 FFF758FD 	  bl cellplus
  45              	  cliteral 1                @ length of data to write
  45 1174 01B4     	>  push { r0 }
  45 1176 0120     	>  movs r0,#1
  46 1178 FFF76EF9 	  bl sys_write
  47 117c FFF7E6F9 	  bl twodrop                @ discard return result and character
  48 1180 FFF768FB 	  bl zincrto
  49 1184 FFF7C8FF 	  bl numout                 @ count chars on line
  50              	  exit
  50              	>  rpop pc
  50 1188 5CF804FB 	>>  ldr pc,[rp],#4
  51              	
  52              	@ ------------------------------------------------------------------------
  53              	@ return true if a keypress is ready to read (key wont block)
  54              	
  55              	@       ( --- f1 )
  56              	
  57              	colon "key?", qkey
  57              	>  header "key?",qkey
  57              	>>  _header_ "key?",qkey
  57              	>>>  .section .data
  57 0c34 280C0000 	>>>  .int _thread
  57              	>>>  .set _thread,.
  57              	>>> 8:
  57              	>>>  hstring "key?"
  57 0c38 04       	>>>>  .byte lex+9f-(.+1)
  57 0c39 6B65793F 	>>>>  .ascii "key?"
  57              	>>>> 9:
  57 0c3d 000000   	>>>>  .balign 4,0
  57              	>>>  .set lex,0
  57 0c40 90110000 	>>>  .int qkey
  57              	>>>  .previous
  57              	>>  .balign 4,0
  57 118c 380C0000 	>>  .int _thread
  57              	> qkey:
  57 1190 AFF30080 	>  nop.w
  57              	>  rpush lr
  57 1194 4CF804ED 	>>  str lr,[rp,#-4]!
  58              	  cliteral 0                @ timeout
  58 1198 01B4     	>  push { r0 }
  58 119a 0020     	>  movs r0,#0
  59              	  cliteral 1                @ number of file descriptors in the following
  59 119c 01B4     	>  push { r0 }
  59 119e 0120     	>  movs r0,#1
  60 11a0 01B4     	  push { r0 }               @ address of pollfd structure
  61 11a2 04A0     	  adr r0, 1f
  62 11a4 FFF790F9 	  bl sys_poll               @ poll for key presses
  63              	  cliteral 1
  63 11a8 01B4     	>  push { r0 }
  63 11aa 0120     	>  movs r0,#1
  64 11ac FFF7AEFE 	  bl equals                 @ return t/f
  65              	  exit
  65              	>  rpop pc
  65 11b0 5CF804FB 	>>  ldr pc,[rp],#4
  66              	1:                          @ an anonymous pollfd structure
  67 11b4 00000000 	  .int 0                    @ file descriptor (stdin)
  68 11b8 0100     	  .hword 1                  @ requested events = POLLIN
  69 11ba 0000     	  .hword 0                  @ returned events
  70              	
  71              	@ ------------------------------------------------------------------------
  72              	
  73              	@       ( --- c1 )
  74              	
  75              	colon "(key)", pkey
  75              	>  header "(key)",pkey
  75              	>>  _header_ "(key)",pkey
  75              	>>>  .section .data
  75 0c44 380C0000 	>>>  .int _thread
  75              	>>>  .set _thread,.
  75              	>>> 8:
  75              	>>>  hstring "(key)"
  75 0c48 05       	>>>>  .byte lex+9f-(.+1)
  75 0c49 286B6579 	>>>>  .ascii "(key)"
  75      29
  75              	>>>> 9:
  75 0c4e 0000     	>>>>  .balign 4,0
  75              	>>>  .set lex,0
  75 0c50 C0110000 	>>>  .int pkey
  75              	>>>  .previous
  75              	>>  .balign 4,0
  75 11bc 480C0000 	>>  .int _thread
  75              	> pkey:
  75 11c0 AFF30080 	>  nop.w
  75              	>  rpush lr
  75 11c4 4CF804ED 	>>  str lr,[rp,#-4]!
  76              	  cliteral 0                @ push place holder to read into
  76 11c8 01B4     	>  push { r0 }
  76 11ca 0020     	>  movs r0,#0
  77              	  cliteral 1                @ number of characters to read
  77 11cc 01B4     	>  push { r0 }
  77 11ce 0120     	>  movs r0,#1
  78 11d0 FFF720FA 	  bl spfetch                @ point at read buffer (the place holder)
  79 11d4 FFF726FD 	  bl cellplus
  80              	  cliteral 0                @ file descriptor = stdin
  80 11d8 01B4     	>  push { r0 }
  80 11da 0020     	>  movs r0,#0
  81 11dc FFF734F9 	  bl sys_read
  82              	
  83 11e0 FFF7B2F8 	  bl qexit                  @ not a very elegant way of handling read
  84 11e4 FEF760FF 	  bl intty                  @ failures
  85 11e8 FFF7AEF8 	  bl qexit
  86 11ec FFF7D6F8 	  bl bye
  87              	  exit
  87              	>  rpop pc
  87 11f0 5CF804FB 	>>  ldr pc,[rp],#4
  88              	
  89              	@ ------------------------------------------------------------------------
  90              	
  91              	@       ( a1 n1 --- )
  92              	
  93              	colon "(type)", ptype
  93              	>  header "(type)",ptype
  93              	>>  _header_ "(type)",ptype
  93              	>>>  .section .data
  93 0c54 480C0000 	>>>  .int _thread
  93              	>>>  .set _thread,.
  93              	>>> 8:
  93              	>>>  hstring "(type)"
  93 0c58 06       	>>>>  .byte lex+9f-(.+1)
  93 0c59 28747970 	>>>>  .ascii "(type)"
  93      6529
  93              	>>>> 9:
  93 0c5f 00       	>>>>  .balign 4,0
  93              	>>>  .set lex,0
  93 0c60 F8110000 	>>>  .int ptype
  93              	>>>  .previous
  93              	>>  .balign 4,0
  93 11f4 580C0000 	>>  .int _thread
  93              	> ptype:
  93 11f8 AFF30080 	>  nop.w
  93              	>  rpush lr
  93 11fc 4CF804ED 	>>  str lr,[rp,#-4]!
  94 1200 00F0E2FE 	  bl bounds                 @ ( a2 a1 --- )
  95 1204 00F082FE 	  bl pqdo
  96 1208 1500     	  .hword (1f - .) + 1
  97              	0:
  98 120a 00F08DFE 	  bl i
  99 120e FFF7EBFA 	  bl cfetch
 100 1212 FFF751FF 	  bl emit
 101 1216 00F047FE 	  bl ploop
 102 121a F1FF     	  .hword (0b - .) + 1
 103              	1:
 104              	  exit
 104              	>  rpop pc
 104 121c 5CF804FB 	>>  ldr pc,[rp],#4
 105              	
 106              	@ ------------------------------------------------------------------------
 107              	
 108              	colon "cr", cr_
 108              	>  header "cr",cr_
 108              	>>  _header_ "cr",cr_
 108              	>>>  .section .data
 108 0c64 580C0000 	>>>  .int _thread
 108              	>>>  .set _thread,.
 108              	>>> 8:
 108              	>>>  hstring "cr"
 108 0c68 02       	>>>>  .byte lex+9f-(.+1)
 108 0c69 6372     	>>>>  .ascii "cr"
 108              	>>>> 9:
 108 0c6b 00       	>>>>  .balign 4,0
 108              	>>>  .set lex,0
 108 0c6c 24120000 	>>>  .int cr_
 108              	>>>  .previous
 108              	>>  .balign 4,0
 108 1220 680C0000 	>>  .int _thread
 108              	> cr_:
 108 1224 AFF30080 	>  nop.w
 108              	>  rpush lr
 108 1228 4CF804ED 	>>  str lr,[rp,#-4]!
 109 122c 00F090F8 	  bl eol                    @ emit an end of line character
 110 1230 FFF742FF 	  bl emit
 111 1234 FFF778FF 	  bl numline                @ get current line number plus 1
 112 1238 FFF7DCFC 	  bl oneplus
 113 123c FFF714FF 	  bl rows                   @ or total # rows which ever is smaller
 114 1240 FFF7DAFE 	  bl min
 115 1244 FFF7E4FA 	  bl zstoreto               @ set that as the current line
 116 1248 FFF76EFF 	  bl numline
 117 124c FFF738FB 	  bl zoffto                 @ no characters have been emitted to this line
 118 1250 FFF762FF 	  bl numout
 119              	  exit
 119              	>  rpop pc
 119 1254 5CF804FB 	>>  ldr pc,[rp],#4
 120              	
 121              	@ ------------------------------------------------------------------------
 122              	@ emit one space
 123              	
 124              	colon "space", space
 124              	>  header "space",space
 124              	>>  _header_ "space",space
 124              	>>>  .section .data
 124 0c70 680C0000 	>>>  .int _thread
 124              	>>>  .set _thread,.
 124              	>>> 8:
 124              	>>>  hstring "space"
 124 0c74 05       	>>>>  .byte lex+9f-(.+1)
 124 0c75 73706163 	>>>>  .ascii "space"
 124      65
 124              	>>>> 9:
 124 0c7a 0000     	>>>>  .balign 4,0
 124              	>>>  .set lex,0
 124 0c7c 5C120000 	>>>  .int space
 124              	>>>  .previous
 124              	>>  .balign 4,0
 124 1258 740C0000 	>>  .int _thread
 124              	> space:
 124 125c AFF30080 	>  nop.w
 124              	>  rpush lr
 124 1260 4CF804ED 	>>  str lr,[rp,#-4]!
 125 1264 FFF710FF 	  bl bl_
 126 1268 FFF726FF 	  bl emit
 127              	  exit
 127              	>  rpop pc
 127 126c 5CF804FB 	>>  ldr pc,[rp],#4
 128              	
 129              	@ ------------------------------------------------------------------------
 130              	@ emit n1 spaces
 131              	
 132              	@       ( n1 --- )
 133              	
 134              	colon "spaces", spaces
 134              	>  header "spaces",spaces
 134              	>>  _header_ "spaces",spaces
 134              	>>>  .section .data
 134 0c80 740C0000 	>>>  .int _thread
 134              	>>>  .set _thread,.
 134              	>>> 8:
 134              	>>>  hstring "spaces"
 134 0c84 06       	>>>>  .byte lex+9f-(.+1)
 134 0c85 73706163 	>>>>  .ascii "spaces"
 134      6573
 134              	>>>> 9:
 134 0c8b 00       	>>>>  .balign 4,0
 134              	>>>  .set lex,0
 134 0c8c 74120000 	>>>  .int spaces
 134              	>>>  .previous
 134              	>>  .balign 4,0
 134 1270 840C0000 	>>  .int _thread
 134              	> spaces:
 134 1274 AFF30080 	>  nop.w
 134              	>  rpush lr
 134 1278 4CF804ED 	>>  str lr,[rp,#-4]!
 135 127c 00F096FE 	  bl dorep
 136 1280 FFF7ECFF 	  bl space
 137              	  exit
 137              	>  rpop pc
 137 1284 5CF804FB 	>>  ldr pc,[rp],#4
 138              	
 139              	@ ------------------------------------------------------------------------
 140              	@ type an inline counted string
 141              	
 142              	colon "(.\")", pdotq
 142              	>  header "(.\")",pdotq
 142              	>>  _header_ "(.\")",pdotq
 142              	>>>  .section .data
 142 0c90 840C0000 	>>>  .int _thread
 142              	>>>  .set _thread,.
 142              	>>> 8:
 142              	>>>  hstring "(.\")"
 142 0c94 04       	>>>>  .byte lex+9f-(.+1)
 142 0c95 282E2229 	>>>>  .ascii "(.\")"
 142              	>>>> 9:
 142 0c99 000000   	>>>>  .balign 4,0
 142              	>>>  .set lex,0
 142 0c9c 8C120000 	>>>  .int pdotq
 142              	>>>  .previous
 142              	>>  .balign 4,0
 142 1288 940C0000 	>>  .int _thread
 142              	> pdotq:
 142 128c AFF30080 	>  nop.w
 142              	>  rpush lr
 142 1290 4CF804ED 	>>  str lr,[rp,#-4]!
 143 1294 FFF79EF9 	  bl rto                    @ get address of inline string
 144 1298 FFF7B0FC 	  bl oneminus               @ address is thumbificated
 145 129c FFF720FB 	  bl count                  @ ( a1 n1 --- )
 146 12a0 FFF734F9 	  bl twodup                 @ set our return address to the end of
 147 12a4 FFF768FC 	  bl plus                   @ the string (aligned)
 148 12a8 00F012FC 	  bl align
 149 12ac FFF7A2FC 	  bl oneplus                @ thumbificate the return address
 150 12b0 FFF780F9 	  bl tor
 151 12b4 FFF708FF 	  bl type                   @ type the string
 152              	  exit
 152              	>  rpop pc
 152 12b8 5CF804FB 	>>  ldr pc,[rp],#4
 153              	
 154              	@ ------------------------------------------------------------------------
 155              	@ conditionally type an inline abort message
 156              	
 157              	@       ( f1 --- )
 158              	
 159              	colon "(abort\")", pabortq
 159              	>  header "(abort\")",pabortq
 159              	>>  _header_ "(abort\")",pabortq
 159              	>>>  .section .data
 159 0ca0 940C0000 	>>>  .int _thread
 159              	>>>  .set _thread,.
 159              	>>> 8:
 159              	>>>  hstring "(abort\")"
 159 0ca4 08       	>>>>  .byte lex+9f-(.+1)
 159 0ca5 2861626F 	>>>>  .ascii "(abort\")"
 159      72742229 
 159              	>>>> 9:
 159 0cad 000000   	>>>>  .balign 4,0
 159              	>>>  .set lex,0
 159 0cb0 C0120000 	>>>  .int pabortq
 159              	>>>  .previous
 159              	>>  .balign 4,0
 159 12bc A40C0000 	>>  .int _thread
 159              	> pabortq:
 159 12c0 AFF30080 	>  nop.w
 159              	>  rpush lr
 159 12c4 4CF804ED 	>>  str lr,[rp,#-4]!
 160 12c8 FFF784F9 	  bl rto                    @ get address of message
 161 12cc FFF796FC 	  bl oneminus               @ dethumbificate the address
 162 12d0 FFF706FB 	  bl count                  @ ( a1 n1 --- )
 163 12d4 FFF762F9 	  bl rot                    @ do we abort or no?
 164 12d8 00F0C8FD 	  bl qbranch
 165 12dc 0F00     	  .hword (1f - .) + 1
 166              	
 167 12de FFF7F3FE 	  bl type                   @ yes. type string
 168 12e2 FFF79FFF 	  bl cr_
 169 12e6 00F02DFA 	  bl abort                  @ and jump back into top of quit
 170              	
 171              	1:
 172 12ea FFF745FC 	  bl plus                   @ not aborting. set return address to the
 173 12ee 00F0EFFB 	  bl align                  @ end of the string (aligned)
 174 12f2 FFF77FFC 	  bl oneplus                @ thumbificate the return address
 175 12f6 FFF75DF9 	  bl tor
 176              	  exit
 176              	>  rpop pc
 176 12fa 5CF804FB 	>>  ldr pc,[rp],#4
 177              	
 178              	@ ------------------------------------------------------------------------
 179              	@ return scratch pad address
 180              	
 181              	@       ( --- a1 )
 182              	
 183              	colon "pad", pad
 183              	>  header "pad",pad
 183              	>>  _header_ "pad",pad
 183              	>>>  .section .data
 183 0cb4 A40C0000 	>>>  .int _thread
 183              	>>>  .set _thread,.
 183              	>>> 8:
 183              	>>>  hstring "pad"
 183 0cb8 03       	>>>>  .byte lex+9f-(.+1)
 183 0cb9 706164   	>>>>  .ascii "pad"
 183              	>>>> 9:
 183              	>>>>  .balign 4,0
 183              	>>>  .set lex,0
 183 0cbc 04130000 	>>>  .int pad
 183              	>>>  .previous
 183 12fe 0000     	>>  .balign 4,0
 183 1300 B80C0000 	>>  .int _thread
 183              	> pad:
 183 1304 AFF30080 	>  nop.w
 183              	>  rpush lr
 183 1308 4CF804ED 	>>  str lr,[rp,#-4]!
 184 130c 00F0B0FE 	  bl here                   @ forth custom puts the scratchpad at 80
 185              	  cliteral 80               @ bytes above 'here'
 185 1310 01B4     	>  push { r0 }
 185 1312 5020     	>  movs r0,#80
 186 1314 FFF730FC 	  bl plus                   @ custom is law!
 187              	  exit
 187              	>  rpop pc
 187 1318 5CF804FB 	>>  ldr pc,[rp],#4
 188              	
 189              	@ ------------------------------------------------------------------------
 190              	@ add n2 to a1 (advance address), sub n2 from n1 (decrement count by n2)
 191              	
 192              	@       ( a1 n1 n2 --- a2 n3 )
 193              	
 194              	code "/string", sstring
 194              	>  header "/string",sstring
 194              	>>  _header_ "/string",sstring
 194              	>>>  .section .data
 194 0cc0 B80C0000 	>>>  .int _thread
 194              	>>>  .set _thread,.
 194              	>>> 8:
 194              	>>>  hstring "/string"
 194 0cc4 07       	>>>>  .byte lex+9f-(.+1)
 194 0cc5 2F737472 	>>>>  .ascii "/string"
 194      696E67
 194              	>>>> 9:
 194              	>>>>  .balign 4,0
 194              	>>>  .set lex,0
 194 0ccc 20130000 	>>>  .int sstring
 194              	>>>  .previous
 194              	>>  .balign 4,0
 194 131c C40C0000 	>>  .int _thread
 194              	> sstring:
 195 1320 06BC     	  pop { r1, r2 }
 196 1322 1218     	  adds r2, r2, r0
 197 1324 081A     	  subs r0, r1, r0
 198 1326 04B4     	  push { r2 }
 199              	  next
 199 1328 7047     	>  bx lr
 200              	
 201              	@ ========================================================================
 317              	  .include "expect.s"       @ query and expect
   1              	@ expect.s - read in line of code from keyboard
   2              	@ ------------------------------------------------------------------------
   3              	
   4              	  _defer_ "expect", expect, pexpect
   4              	>  header "expect",expect
   4              	>>  _header_ "expect",expect
   4              	>>>  .section .data
   4 0cd0 C40C0000 	>>>  .int _thread
   4              	>>>  .set _thread,.
   4              	>>> 8:
   4              	>>>  hstring "expect"
   4 0cd4 06       	>>>>  .byte lex+9f-(.+1)
   4 0cd5 65787065 	>>>>  .ascii "expect"
   4      6374
   4              	>>>> 9:
   4 0cdb 00       	>>>>  .balign 4,0
   4              	>>>  .set lex,0
   4 0cdc 30130000 	>>>  .int expect
   4              	>>>  .previous
   4 132a 0000     	>>  .balign 4,0
   4 132c D40C0000 	>>  .int _thread
   4              	> expect:
   4              	>  rpush lr
   4 1330 4CF804ED 	>>  str lr,[rp,#-4]!
   4 1334 FFF716F8 	>  bl dodefer
   4 1338 64140000 	>  .int pexpect
   5              	
   6              	@ ------------------------------------------------------------------------
   7              	
   8              	  _constant_ "bs", bs_ , 8
   8              	>  header "bs",bs_
   8              	>>  _header_ "bs",bs_
   8              	>>>  .section .data
   8 0ce0 D40C0000 	>>>  .int _thread
   8              	>>>  .set _thread,.
   8              	>>> 8:
   8              	>>>  hstring "bs"
   8 0ce4 02       	>>>>  .byte lex+9f-(.+1)
   8 0ce5 6273     	>>>>  .ascii "bs"
   8              	>>>> 9:
   8 0ce7 00       	>>>>  .balign 4,0
   8              	>>>  .set lex,0
   8 0ce8 40130000 	>>>  .int bs_
   8              	>>>  .previous
   8              	>>  .balign 4,0
   8 133c E40C0000 	>>  .int _thread
   8              	> bs_:
   8              	>  rpush lr
   8 1340 4CF804ED 	>>  str lr,[rp,#-4]!
   8 1344 FFF718F8 	>  bl dovar
   8 1348 08000000 	>  .int 8
   9              	  _constant_ "eol", eol, 0xa
   9              	>  header "eol",eol
   9              	>>  _header_ "eol",eol
   9              	>>>  .section .data
   9 0cec E40C0000 	>>>  .int _thread
   9              	>>>  .set _thread,.
   9              	>>> 8:
   9              	>>>  hstring "eol"
   9 0cf0 03       	>>>>  .byte lex+9f-(.+1)
   9 0cf1 656F6C   	>>>>  .ascii "eol"
   9              	>>>> 9:
   9              	>>>>  .balign 4,0
   9              	>>>  .set lex,0
   9 0cf4 50130000 	>>>  .int eol
   9              	>>>  .previous
   9              	>>  .balign 4,0
   9 134c F00C0000 	>>  .int _thread
   9              	> eol:
   9              	>  rpush lr
   9 1350 4CF804ED 	>>  str lr,[rp,#-4]!
   9 1354 FFF710F8 	>  bl dovar
   9 1358 0A000000 	>  .int 0xa
  10              	
  11              	@ ------------------------------------------------------------------------
  12              	
  13              	@ does not support any editing of the input line other than deleting
  14              	@ characters and retyping them.  this functionality will be added to the
  15              	@ as part of the history extension (eventually :)
  16              	
  17              	@ ------------------------------------------------------------------------
  18              	
  19              	@     ( --- )
  20              	
  21              	colon "(bs)", pbs
  21              	>  header "(bs)",pbs
  21              	>>  _header_ "(bs)",pbs
  21              	>>>  .section .data
  21 0cf8 F00C0000 	>>>  .int _thread
  21              	>>>  .set _thread,.
  21              	>>> 8:
  21              	>>>  hstring "(bs)"
  21 0cfc 04       	>>>>  .byte lex+9f-(.+1)
  21 0cfd 28627329 	>>>>  .ascii "(bs)"
  21              	>>>> 9:
  21 0d01 000000   	>>>>  .balign 4,0
  21              	>>>  .set lex,0
  21 0d04 60130000 	>>>  .int pbs
  21              	>>>  .previous
  21              	>>  .balign 4,0
  21 135c FC0C0000 	>>  .int _thread
  21              	> pbs:
  21 1360 AFF30080 	>  nop.w
  21              	>  rpush lr
  21 1364 4CF804ED 	>>  str lr,[rp,#-4]!
  22 1368 FFF7EAFF 	  bl bs_                    @ backspace over the top of the charactger
  23 136c FFF7A4FE 	  bl emit
  24              	  cliteral 2                @ we need to subtract two from #out.  one
  24 1370 01B4     	>  push { r0 }
  24 1372 0220     	>  movs r0,#2
  25 1374 6FEA0000 	  mvn r0, r0                @ for the character we deleted and one because
  26 1378 FFF75AFA 	  bl zplusstoreto           @ the emit of the backspace added 1 to #out
  27 137c FFF7CCFE 	  bl numout                 @ too
  28              	  exit
  28              	>  rpop pc
  28 1380 5CF804FB 	>>  ldr pc,[rp],#4
  29              	
  30              	@ ------------------------------------------------------------------------
  31              	@ delete one character from buffer and delete it visually too
  32              	
  33              	@     ( count --- )
  34              	
  35              	colon "bsin", bsin
  35              	>  header "bsin",bsin
  35              	>>  _header_ "bsin",bsin
  35              	>>>  .section .data
  35 0d08 FC0C0000 	>>>  .int _thread
  35              	>>>  .set _thread,.
  35              	>>> 8:
  35              	>>>  hstring "bsin"
  35 0d0c 04       	>>>>  .byte lex+9f-(.+1)
  35 0d0d 6273696E 	>>>>  .ascii "bsin"
  35              	>>>> 9:
  35 0d11 000000   	>>>>  .balign 4,0
  35              	>>>  .set lex,0
  35 0d14 88130000 	>>>  .int bsin
  35              	>>>  .previous
  35              	>>  .balign 4,0
  35 1384 0C0D0000 	>>  .int _thread
  35              	> bsin:
  35 1388 AFF30080 	>  nop.w
  35              	>  rpush lr
  35 138c 4CF804ED 	>>  str lr,[rp,#-4]!
  36 1390 FFF7B8F8 	  bl dup                    @ if buffer is empty get out
  37 1394 FFF7A6FD 	  bl zequals
  38 1398 FEF7D6FF 	  bl qexit
  39 139c FFF72EFC 	  bl oneminus               @ decrement count
  40 13a0 FFF7DEFF 	  bl pbs                    @ blot out and char and retreat cursor
  41 13a4 FFF75AFF 	  bl space
  42 13a8 FFF7DAFF 	  bl pbs
  43              	  exit
  43              	>  rpop pc
  43 13ac 5CF804FB 	>>  ldr pc,[rp],#4
  44              	
  45              	@ ------------------------------------------------------------------------
  46              	@ user terminated input...
  47              	
  48              	#     (  max addr count c1 --- max addr max )
  49              	
  50              	colon "crin", crin
  50              	>  header "crin",crin
  50              	>>  _header_ "crin",crin
  50              	>>>  .section .data
  50 0d18 0C0D0000 	>>>  .int _thread
  50              	>>>  .set _thread,.
  50              	>>> 8:
  50              	>>>  hstring "crin"
  50 0d1c 04       	>>>>  .byte lex+9f-(.+1)
  50 0d1d 6372696E 	>>>>  .ascii "crin"
  50              	>>>> 9:
  50 0d21 000000   	>>>>  .balign 4,0
  50              	>>>  .set lex,0
  50 0d24 B4130000 	>>>  .int crin
  50              	>>>  .previous
  50              	>>  .balign 4,0
  50 13b0 1C0D0000 	>>  .int _thread
  50              	> crin:
  50 13b4 AFF30080 	>  nop.w
  50              	>  rpush lr
  50 13b8 4CF804ED 	>>  str lr,[rp,#-4]!
  51 13bc FFF7C2F8 	  bl drop                   @ discard cr char
  52 13c0 FFF716F9 	  bl duptor
  53 13c4 FFF724FA 	  bl zstoreto               @ make tib count = input count
  54 13c8 FFF796FE 	  bl numtib
  55 13cc FFF7CAF8 	  bl over                   @ fake it, we entered max # chars
  56 13d0 FFF700F9 	  bl rto                    @ if input was not empty emit a space
  57 13d4 FFF786FD 	  bl zequals
  58 13d8 FEF7B6FF 	  bl qexit
  59 13dc FFF73EFF 	  bl space
  60              	  exit
  60              	>  rpop pc
  60 13e0 5CF804FB 	>>  ldr pc,[rp],#4
  61              	
  62              	@ ------------------------------------------------------------------------
  63              	@ user entered a control character. was it a backspace?
  64              	
  65              	@     ( c1 --- )
  66              	
  67              	colon "?bsin", qbsin
  67              	>  header "?bsin",qbsin
  67              	>>  _header_ "?bsin",qbsin
  67              	>>>  .section .data
  67 0d28 1C0D0000 	>>>  .int _thread
  67              	>>>  .set _thread,.
  67              	>>> 8:
  67              	>>>  hstring "?bsin"
  67 0d2c 05       	>>>>  .byte lex+9f-(.+1)
  67 0d2d 3F627369 	>>>>  .ascii "?bsin"
  67      6E
  67              	>>>> 9:
  67 0d32 0000     	>>>>  .balign 4,0
  67              	>>>  .set lex,0
  67 0d34 E8130000 	>>>  .int qbsin
  67              	>>>  .previous
  67              	>>  .balign 4,0
  67 13e4 2C0D0000 	>>  .int _thread
  67              	> qbsin:
  67 13e8 AFF30080 	>  nop.w
  67              	>  rpush lr
  67 13ec 4CF804ED 	>>  str lr,[rp,#-4]!
  68 13f0 FFF7A6FF 	  bl bs_                    @ exit if c1 is not a backspace
  69 13f4 FFF792FD 	  bl notequals
  70 13f8 FEF7A6FF 	  bl qexit
  71 13fc FFF7C4FF 	  bl bsin                   @ otherwise process character deletion
  72              	  exit
  72              	>  rpop pc
  72 1400 5CF804FB 	>>  ldr pc,[rp],#4
  73              	
  74              	@ ------------------------------------------------------------------------
  75              	@ user entered a control char, it was a bs or a cr or we ignore it
  76              	
  77              	@     ( c1 --- )
  78              	
  79              	colon "^char", ctrlchr
  79              	>  header "^char",ctrlchr
  79              	>>  _header_ "^char",ctrlchr
  79              	>>>  .section .data
  79 0d38 2C0D0000 	>>>  .int _thread
  79              	>>>  .set _thread,.
  79              	>>> 8:
  79              	>>>  hstring "^char"
  79 0d3c 05       	>>>>  .byte lex+9f-(.+1)
  79 0d3d 5E636861 	>>>>  .ascii "^char"
  79      72
  79              	>>>> 9:
  79 0d42 0000     	>>>>  .balign 4,0
  79              	>>>  .set lex,0
  79 0d44 08140000 	>>>  .int ctrlchr
  79              	>>>  .previous
  79              	>>  .balign 4,0
  79 1404 3C0D0000 	>>  .int _thread
  79              	> ctrlchr:
  79 1408 AFF30080 	>  nop.w
  79              	>  rpush lr
  79 140c 4CF804ED 	>>  str lr,[rp,#-4]!
  80 1410 FFF778F8 	  bl dup                    @ is c1 a cr
  81              	  cliteral 0x0d
  81 1414 01B4     	>  push { r0 }
  81 1416 0D20     	>  movs r0,#0x0d
  82 1418 FFF778FD 	  bl equals
  83 141c FFF7A2F8 	  bl over
  84              	  cliteral 0x0a             @ or an lf
  84 1420 01B4     	>  push { r0 }
  84 1422 0A20     	>  movs r0,#0x0a
  85 1424 FFF772FD 	  bl equals
  86 1428 FFF74CFD 	  bl or_
  87 142c 00F0EEFC 	  bl qcolon
  88 1430 FFF7C0FF 	  bl crin                   @ if so terminate input of string
  89 1434 FFF7D8FF 	  bl qbsin                  @ else test for backspace
  90              	  exit
  90              	>  rpop pc
  90 1438 5CF804FB 	>>  ldr pc,[rp],#4
  91              	
  92              	@ ------------------------------------------------------------------------
  93              	@ user entered a normal character
  94              	
  95              	@     ( addr #in c1 --- addr #in )
  96              	
  97              	colon "norm-char", normchar
  97              	>  header "norm-char",normchar
  97              	>>  _header_ "norm-char",normchar
  97              	>>>  .section .data
  97 0d48 3C0D0000 	>>>  .int _thread
  97              	>>>  .set _thread,.
  97              	>>> 8:
  97              	>>>  hstring "norm-char"
  97 0d4c 09       	>>>>  .byte lex+9f-(.+1)
  97 0d4d 6E6F726D 	>>>>  .ascii "norm-char"
  97      2D636861 
  97      72
  97              	>>>> 9:
  97 0d56 0000     	>>>>  .balign 4,0
  97              	>>>  .set lex,0
  97 0d58 40140000 	>>>  .int normchar
  97              	>>>  .previous
  97              	>>  .balign 4,0
  97 143c 4C0D0000 	>>  .int _thread
  97              	> normchar:
  97 1440 AFF30080 	>  nop.w
  97              	>  rpush lr
  97 1444 4CF804ED 	>>  str lr,[rp,#-4]!
  98 1448 FFF768F8 	  bl threedup               @ make copy of parameters
  99 144c FFF734FE 	  bl emit                   @ display the char the user typed
 100 1450 FFF792FB 	  bl plus                   @ add count to address
 101 1454 FFF7CCF9 	  bl cstore                 @ store c1 at this address
 102 1458 FFF7CCFB 	  bl oneplus                @ bump count by one
 103              	  exit
 103              	>  rpop pc
 103 145c 5CF804FB 	>>  ldr pc,[rp],#4
 104              	
 105              	@ ------------------------------------------------------------------------
 106              	@ input max of n1 characters to address a1
 107              	
 108              	@    ( a1 n1 --- )
 109              	
 110              	colon "(expect)", pexpect
 110              	>  header "(expect)",pexpect
 110              	>>  _header_ "(expect)",pexpect
 110              	>>>  .section .data
 110 0d5c 4C0D0000 	>>>  .int _thread
 110              	>>>  .set _thread,.
 110              	>>> 8:
 110              	>>>  hstring "(expect)"
 110 0d60 08       	>>>>  .byte lex+9f-(.+1)
 110 0d61 28657870 	>>>>  .ascii "(expect)"
 110      65637429 
 110              	>>>> 9:
 110 0d69 000000   	>>>>  .balign 4,0
 110              	>>>  .set lex,0
 110 0d6c 64140000 	>>>  .int pexpect
 110              	>>>  .previous
 110              	>>  .balign 4,0
 110 1460 600D0000 	>>  .int _thread
 110              	> pexpect:
 110 1464 AFF30080 	>  nop.w
 110              	>  rpush lr
 110 1468 4CF804ED 	>>  str lr,[rp,#-4]!
 111 146c FFF75CF8 	  bl swap
 112              	  cliteral 0                @ number so far
 112 1470 01B4     	>  push { r0 }
 112 1472 0020     	>  movs r0,#0
 113              	0:
 114 1474 FFF786F8 	  bl pluck                  @ max length
 115 1478 FFF774F8 	  bl over                   @ number so far
 116 147c FFF782FB 	  bl minus                  @ not equal while...
 117 1480 00F0F4FC 	  bl qbranch
 118 1484 2500     	  .hword (1f - .) + 1
 119              	
 120 1486 FFF727FE 	  bl key                    @ input character
 121 148a FFF73BF8 	  bl dup
 122 148e FFF7FBFD 	  bl bl_                    @ if it is a ctrl char
 123 1492 FFF765FD 	  bl less
 124 1496 00F0B9FC 	  bl qcolon
 125 149a FFF7B5FF 	  bl ctrlchr                @ handle ctrl chars
 126 149e FFF7CFFF 	  bl normchar               @ else handle normal chars
 127              	
 128 14a2 00F0D9FC 	  bl branch
 129 14a6 CFFF     	  .hword (0b - .) + 1
 130              	
 131              	@ note: we simply terminate the input loop if we have recieved the max
 132              	@ number of characters. a better way would be to allow input of only
 133              	@ a backspace or an enter
 134              	
 135              	1:
 136 14a8 FFF756F8 	  bl threedrop              @ max length reachedd
 137              	  exit                      @
 137              	>  rpop pc
 137 14ac 5CF804FB 	>>  ldr pc,[rp],#4
 138              	
 139              	@ ------------------------------------------------------------------------
 140              	@ expect a max of 256 characters into the terminal input buffer
 141              	
 142              	colon "query", query
 142              	>  header "query",query
 142              	>>  _header_ "query",query
 142              	>>>  .section .data
 142 0d70 600D0000 	>>>  .int _thread
 142              	>>>  .set _thread,.
 142              	>>> 8:
 142              	>>>  hstring "query"
 142 0d74 05       	>>>>  .byte lex+9f-(.+1)
 142 0d75 71756572 	>>>>  .ascii "query"
 142      79
 142              	>>>> 9:
 142 0d7a 0000     	>>>>  .balign 4,0
 142              	>>>  .set lex,0
 142 0d7c B4140000 	>>>  .int query
 142              	>>>  .previous
 142              	>>  .balign 4,0
 142 14b0 740D0000 	>>  .int _thread
 142              	> query:
 142 14b4 AFF30080 	>  nop.w
 142              	>  rpush lr
 142 14b8 4CF804ED 	>>  str lr,[rp,#-4]!
 143 14bc FFF73CFE 	  bl tib                    @ address of input buffer
 144              	  wliteral 256              @ max nuber of chars to input
 144 14c0 01B4     	>  push { r0 }
 144 14c2 40F20010 	>  movw r0,#256
 145 14c6 FFF733FF 	  bl expect                 @ input text
 146 14ca FFF7F9F9 	  bl zoffto                 @ reset terminal parse point
 147 14ce FFF71BFE 	  bl toin
 148              	  exit
 148              	>  rpop pc
 148 14d2 5CF804FB 	>>  ldr pc,[rp],#4
 149              	
 150              	@ ========================================================================
 318              	  .include "scan.s"         @ skip and scan
   1              	@ scan.s
   2              	@ ------------------------------------------------------------------------
   3              	
   4              	@ when you type bl word ... parse-word will scan the next token out of
   5              	@ the input buffer up to the specified delimiting character (the blank)
   6              	@ but it will also delimit on either a tab or an end of line.  In the case
   7              	@ of delimiting on an end of line we have a minor issue we need to deal
   8              	@ with..
   9              	@
  10              	@ if the word we just parsed is the \ line comment word then the next
  11              	@ line of the sorce file will be treated as a comment (\ parses to the
  12              	@ next eol which in this case is the end of the line immediatly following)
  13              	
  14              	  _constant_ "wchar", wchar, 0
  14              	>  header "wchar",wchar
  14              	>>  _header_ "wchar",wchar
  14              	>>>  .section .data
  14 0d80 740D0000 	>>>  .int _thread
  14              	>>>  .set _thread,.
  14              	>>> 8:
  14              	>>>  hstring "wchar"
  14 0d84 05       	>>>>  .byte lex+9f-(.+1)
  14 0d85 77636861 	>>>>  .ascii "wchar"
  14      72
  14              	>>>> 9:
  14 0d8a 0000     	>>>>  .balign 4,0
  14              	>>>  .set lex,0
  14 0d8c DC140000 	>>>  .int wchar
  14              	>>>  .previous
  14 14d6 0000     	>>  .balign 4,0
  14 14d8 840D0000 	>>  .int _thread
  14              	> wchar:
  14              	>  rpush lr
  14 14dc 4CF804ED 	>>  str lr,[rp,#-4]!
  14 14e0 FEF74AFF 	>  bl dovar
  14 14e4 00000000 	>  .int 0
  15              	
  16              	@ ------------------------------------------------------------------------
  17              	@ skip leading characters equal to c1 within a string
  18              	
  19              	@     ( a1 n1 c1 --- a2 n2 )
  20              	
  21              	code "skip", skip
  21              	>  header "skip",skip
  21              	>>  _header_ "skip",skip
  21              	>>>  .section .data
  21 0d90 840D0000 	>>>  .int _thread
  21              	>>>  .set _thread,.
  21              	>>> 8:
  21              	>>>  hstring "skip"
  21 0d94 04       	>>>>  .byte lex+9f-(.+1)
  21 0d95 736B6970 	>>>>  .ascii "skip"
  21              	>>>> 9:
  21 0d99 000000   	>>>>  .balign 4,0
  21              	>>>  .set lex,0
  21 0d9c EC140000 	>>>  .int skip
  21              	>>>  .previous
  21              	>>  .balign 4,0
  21 14e8 940D0000 	>>  .int _thread
  21              	> skip:
  22 14ec 06BC     	  pop { r1, r2 }
  23 14ee 0029     	  cmp r1, #0                @ zero length?
  24 14f0 07D0     	  beq 1f
  25              	
  26              	0:
  27 14f2 02BF     	  ittt eq
  28 14f4 0132     	  addeq r2, r2, #1          @ address++
  29 14f6 B1F10101 	  subseq r1, r1, #1         @ count--
  30 14fa 02E0     	  beq 1f
  31              	
  32 14fc 1378     	  ldrb r3, [r2]             @ is next char same as skip char?
  33 14fe 8342     	  cmp r3, r0
  34 1500 F7D0     	  beq 0b
  35              	
  36              	1:
  37 1502 04B4     	  push { r2 }               @ addr of first char not equal to skip
  38 1504 0846     	  mov r0, r1                @ new length of string
  39              	  next
  39 1506 7047     	>  bx lr
  40              	
  41              	@ ------------------------------------------------------------------------
  42              	@ scan string for specified character
  43              	
  44              	@     ( a1 n1 c1 --- a2 n2 )
  45              	
  46              	code "scan", scan
  46              	>  header "scan",scan
  46              	>>  _header_ "scan",scan
  46              	>>>  .section .data
  46 0da0 940D0000 	>>>  .int _thread
  46              	>>>  .set _thread,.
  46              	>>> 8:
  46              	>>>  hstring "scan"
  46 0da4 04       	>>>>  .byte lex+9f-(.+1)
  46 0da5 7363616E 	>>>>  .ascii "scan"
  46              	>>>> 9:
  46 0da9 000000   	>>>>  .balign 4,0
  46              	>>>  .set lex,0
  46 0dac 0C150000 	>>>  .int scan
  46              	>>>  .previous
  46              	>>  .balign 4,0
  46 1508 A40D0000 	>>  .int _thread
  46              	> scan:
  47 150c 06BC     	  pop { r1, r2 }
  48 150e 0029     	  cmp r1, #0                @ zero length scan?
  49 1510 06D0     	  beq 1f
  50              	
  51              	0:
  52 1512 1378     	  ldrb r3, [r2]             @ compare next char of string to c1
  53 1514 8342     	  cmp r3, r0
  54 1516 1EBF     	  ittt ne
  55 1518 0132     	  addne r2, r2, #1          @ advance address
  56 151a B1F10101 	  subsne r1, r1, #1         @ length--
  57 151e F8E7     	  bne 0b
  58              	
  59              	1:
  60 1520 04B4     	  push { r2 }               @ return address of char (or end of string)
  61 1522 0846     	  mov r0, r1                @ number of chars from addr to end of string
  62              	  next
  62 1524 7047     	>  bx lr
  63              	
  64              	@ ------------------------------------------------------------------------
  65              	
  66              	@     ( a1 n1 n2 --- a2 n2 )
  67              	
  68              	@code "dscan", dscan
  69              	@  pop { r1, r2 }            @ pop length and address
  70              	@  cmp r1, #0                @ zero length scan?
  71              	@  beq 1f
  72              	@
  73              	@0:
  74              	@  ldr r3, [r2]              @ compare next cell of data to n2
  75              	@  cmp r3, r0
  76              	@  itt ne
  77              	@  addne r2, r2, #4          @ advance address
  78              	@  subsne r1, r1, #1         @ length--
  79              	@  bne 0b
  80              	@
  81              	@1:
  82              	@  push { r2 }               @ address of found item (or end)
  83              	@  mov r0, r1                @ number of cells from addr to end of string
  84              	@  next
  85              	
  86              	@ ------------------------------------------------------------------------
  87              	
  88              	@     ( a1 n1 c1 --- a2 n2 )
  89              	
  90              	code "scan-word", scan_word
  90              	>  header "scan-word",scan_word
  90              	>>  _header_ "scan-word",scan_word
  90              	>>>  .section .data
  90 0db0 A40D0000 	>>>  .int _thread
  90              	>>>  .set _thread,.
  90              	>>> 8:
  90              	>>>  hstring "scan-word"
  90 0db4 09       	>>>>  .byte lex+9f-(.+1)
  90 0db5 7363616E 	>>>>  .ascii "scan-word"
  90      2D776F72 
  90      64
  90              	>>>> 9:
  90 0dbe 0000     	>>>>  .balign 4,0
  90              	>>>  .set lex,0
  90 0dc0 2C150000 	>>>  .int scan_word
  90              	>>>  .previous
  90 1526 0000     	>>  .balign 4,0
  90 1528 B40D0000 	>>  .int _thread
  90              	> scan_word:
  91 152c 06BC     	  pop { r1, r2 }
  92 152e 0029     	  cmp r1, #0
  93 1530 0AD0     	  beq 2f
  94              	
  95              	0:
  96 1532 1378     	  ldrb r3, [r2]
  97 1534 8342     	  cmp r3, r0
  98 1536 07D0     	  beq 2f
  99              	
 100 1538 2028     	  cmp r0, #0x20           @ if we are scanning for blanks then include
 101 153a 08BF     	  it eq
 102 153c 092B     	  cmpeq r3, #0x09         @ the evil tab
 103 153e 03D0     	  beq 2f
 104 1540 0132     	  adds r2, r2, #1
 105 1542 0139     	  subs r1, r1, #1
 106 1544 F5D1     	  bne 0b
 107 1546 0B46     	  mov r3, r1              @ we did not delimit, we ran out of string
 108              	
 109              	2:
 110 1548 04B4     	  push { r2 }
 111              	
 112 154a AFF27002 	  adr r2, wchar
 113 154e 9360     	  str r3, [r2, #BODY]
 114 1550 0846     	  mov r0, r1
 115              	  next
 115 1552 7047     	>  bx lr
 116              	
 117              	@ ========================================================================
 319              	  .include "number.s"       @ number input words
   1              	@ number.s      - convert parsed in string to a number in specified base
   2              	@ ------------------------------------------------------------------------
   3              	
   4              	  _var_ "base", base, 10    @ default radix is decimal
   4              	>  header "base",base
   4              	>>  _header_ "base",base
   4              	>>>  .section .data
   4 0dc4 B40D0000 	>>>  .int _thread
   4              	>>>  .set _thread,.
   4              	>>> 8:
   4              	>>>  hstring "base"
   4 0dc8 04       	>>>>  .byte lex+9f-(.+1)
   4 0dc9 62617365 	>>>>  .ascii "base"
   4              	>>>> 9:
   4 0dcd 000000   	>>>>  .balign 4,0
   4              	>>>  .set lex,0
   4 0dd0 58150000 	>>>  .int base
   4              	>>>  .previous
   4              	>>  .balign 4,0
   4 1554 C80D0000 	>>  .int _thread
   4              	> base:
   4              	>  rpush lr
   4 1558 4CF804ED 	>>  str lr,[rp,#-4]!
   4 155c FEF70CFF 	>  bl dovar
   4 1560 0A000000 	>  .int 10
   5              	
   6              	@ ------------------------------------------------------------------------
   7              	@ see if char c1 is a valid digit in specified number base
   8              	
   9              	@     ( base c1 --- n1 t | f )
  10              	
  11              	digit:
  12 1564 02BC     	  pop { r1 }                @ get radix in r1
  13 1566 3038     	  subs r0, #'0'             @ de-asciify the character
  14 1568 0AD3     	  blo 2f                    @ if char was < '0' then not a digit
  15 156a 0928     	  cmp r0, #9                @ else if char < '9' then digit ok
  16 156c 02D9     	  bls 1f
  17 156e 1128     	  cmp r0, #17               @ if char < 'A' then not a digit
  18 1570 06D3     	  blo 2f
  19 1572 0738     	  subs r0, #7
  20              	1:
  21 1574 8842     	  cmp r0, r1                @ if char >= radix then not a digit
  22 1576 03D2     	  bhs 2f
  23 1578 01B4     	  push { r0 }               @ char is a digit, retutn the value of the
  24 157a 6FF00000 	  mvn r0, #0                @ char and a true result
  25              	  next
  25 157e 7047     	>  bx lr
  26              	2:                          @ char is not a digit
  27 1580 0020     	  movs r0, #0               @ return false result
  28              	  next
  28 1582 7047     	>  bx lr
  29              	
  30              	@ ------------------------------------------------------------------------
  31              	
  32              	@     ( a1 n1 radix --- n1 t | f )
  33              	
  34              	pnumber:
  35              	  rpush lr
  35 1584 4CF804ED 	>  str lr,[rp,#-4]!
  36              	  cliteral 0                @ result = 0
  36 1588 01B4     	>  push { r0 }
  36 158a 0020     	>  movs r0,#0
  37 158c FEF7D2FF 	  bl twoswap                @ ( radix result a1 n1 --- )
  38 1590 00F01AFD 	  bl bounds                 @ get a1 a2 of string to convert
  39 1594 00F0A4FC 	  bl pdo
  40 1598 4700     	  .hword (2f - .) + 1
  41              	0:                          @ ( radix result --- )
  42 159a FEF7E3FF 	  bl over
  43 159e 00F0C3FC 	  bl i                      @ get next char of string to convert
  44 15a2 FFF721F9 	  bl cfetch
  45 15a6 FFF78FFA 	  bl upc                    @ make the char upper case
  46 15aa FFF7DBFF 	  bl digit                  @ is it a valid digit?
  47 15ae FFF795FC 	  bl not
  48 15b2 00F05BFC 	  bl qbranch
  49 15b6 1300     	  .hword (1f - .) + 1
  50 15b8 FEF7CEFF 	  bl threedrop              @ if not clean up
  51 15bc 00F05EFC 	  bl undo                   @ abort the loop
  52 15c0 FFF772FC 	  bl false                  @ and return failure
  53              	  exit
  53              	>  rpop pc
  53 15c4 5CF804FB 	>>  ldr pc,[rp],#4
  54              	1:
  55 15c8 FEF7AEFF 	  bl swap                   @ ( radix n1 result --- )
  56 15cc FEF7DAFF 	  bl pluck                  @ multiply result by radix
  57 15d0 FFF776FB 	  bl star                   @ and add it value of digit n1
  58 15d4 FFF7D0FA 	  bl plus
  59 15d8 00F066FC 	  bl ploop
  60 15dc BFFF     	  .hword (0b - .) + 1
  61              	2:
  62 15de FEF7C7FF 	  bl nip                    @ ( --- result true )
  63 15e2 FFF759FC 	  bl true
  64              	  exit
  64              	>  rpop pc
  64 15e6 5CF804FB 	>>  ldr pc,[rp],#4
  65              	
  66              	@ ------------------------------------------------------------------------
  67              	
  68              	@     ( sign a1 n1 radix --- n1 t | f )
  69              	
  70              	pnum:
  71              	  rpush lr
  71 15ea 4CF804ED 	>  str lr,[rp,#-4]!
  72 15ee FFF7C9FF 	  bl pnumber              @ attempt conversion of string to number
  73 15f2 FEF787FF 	  bl dup                  @ if we did not succeed returl false
  74 15f6 FFF771FC 	  bl not
  75 15fa FEF7A5FE 	  bl qexit
  76 15fe FEF7D9FF 	  bl tor                  @ otherwise save true flag
  77 1602 FEF791FF 	  bl swap                 @ ( n1 sign --- n1 )
  78 1606 FFF719FB 	  bl qnegate              @ conditionally negate the result
  79 160a FEF7E3FF 	  bl rto                  @ return result and true flag
  80              	  exit
  80              	>  rpop pc
  80 160e 5CF804FB 	>>  ldr pc,[rp],#4
  81              	
  82              	@ ------------------------------------------------------------------------
  83              	@ return character number 'c'
  84              	
  85              	@     ( sign a1 n1 --- n1 t | f )
  86              	
  87              	chrnum:
  88              	  rpush lr
  88 1612 4CF804ED 	>  str lr,[rp,#-4]!
  89 1616 FEF7A5FF 	  bl over                 @ must have the closing tick
  90 161a FFF7F3FA 	  bl twoplus
  91 161e FFF7E3F8 	  bl cfetch
  92              	  cliteral 0x27
  92 1622 01B4     	>  push { r0 }
  92 1624 2720     	>  movs r0,#0x27
  93 1626 FFF771FC 	  bl equals
  94 162a FFF757FC 	  bl not
  95 162e FFF747FE 	  bl pabortq              @ or else
  96              	  hstring "Missing '"
  96 1632 09       	>  .byte lex+9f-(.+1)
  96 1633 4D697373 	>  .ascii "Missing '"
  96      696E6720 
  96      27
  96              	> 9:
  96              	>  .balign 4,0
  97 163c FEF782FF 	  bl drop                 @ discard string length
  98 1640 FFF7D8FA 	  bl oneplus              @ fetch the charcater from between the ticks
  99 1644 FFF7D0F8 	  bl cfetch
 100 1648 FEF76EFF 	  bl swap                 @ conditionally negate the char
 101 164c FFF7F6FA 	  bl qnegate
 102 1650 FFF722FC 	  bl true                 @ reeturn result and true
 103              	  exit
 103              	>  rpop pc
 103 1654 5CF804FB 	>>  ldr pc,[rp],#4
 104              	
 105              	@ ------------------------------------------------------------------------
 106              	
 107              	@     ( sign a1 n1 --- n1 t | f )
 108              	
 109              	binnum:
 110              	  rpush lr
 110 1658 4CF804ED 	>  str lr,[rp,#-4]!
 111              	  cliteral 1              @ scan past the % prefix
 111 165c 01B4     	>  push { r0 }
 111 165e 0120     	>  movs r0,#1
 112 1660 FFF75EFE 	  bl sstring
 113              	  cliteral 2              @ convert string to number using binary as
 113 1664 01B4     	>  push { r0 }
 113 1666 0220     	>  movs r0,#2
 114 1668 FFF7BFFF 	  bl pnum                 @ the radix
 115              	  exit
 115              	>  rpop pc
 115 166c 5CF804FB 	>>  ldr pc,[rp],#4
 116              	
 117              	@ ------------------------------------------------------------------------
 118              	
 119              	@     ( sign a1 n1 --- n1 t | f )
 120              	
 121              	octnum:
 122              	  rpush lr
 122 1670 4CF804ED 	>  str lr,[rp,#-4]!
 123              	  cliteral 1              @ scan past the \ prefix
 123 1674 01B4     	>  push { r0 }
 123 1676 0120     	>  movs r0,#1
 124 1678 FFF752FE 	  bl sstring
 125              	  cliteral 8              @ convert the string to a number using octal as
 125 167c 01B4     	>  push { r0 }
 125 167e 0820     	>  movs r0,#8
 126 1680 FFF7B3FF 	  bl pnum                 @ the radix
 127              	  exit
 127              	>  rpop pc
 127 1684 5CF804FB 	>>  ldr pc,[rp],#4
 128              	
 129              	@ ------------------------------------------------------------------------
 130              	
 131              	@     ( sign a1 n1 --- n1 t | f )
 132              	
 133              	hexnum:
 134              	  rpush lr
 134 1688 4CF804ED 	>  str lr,[rp,#-4]!
 135              	  cliteral 1              @ scan past the $ prefix
 135 168c 01B4     	>  push { r0 }
 135 168e 0120     	>  movs r0,#1
 136 1690 FFF746FE 	  bl sstring
 137              	  cliteral 16             @ convert the string to a number using hex as
 137 1694 01B4     	>  push { r0 }
 137 1696 1020     	>  movs r0,#16
 138 1698 FFF7A7FF 	  bl pnum                 @ the radix
 139              	  exit
 139              	>  rpop pc
 139 169c 5CF804FB 	>>  ldr pc,[rp],#4
 140              	
 141              	@ ------------------------------------------------------------------------
 142              	
 143              	defnum:
 144              	  rpush lr
 144 16a0 4CF804ED 	>  str lr,[rp,#-4]!
 145 16a4 FFF758FF 	  bl base
 146 16a8 FFF79FFF 	  bl pnum
 147              	  exit
 147              	>  rpop pc
 147 16ac 5CF804FB 	>>  ldr pc,[rp],#4
 148              	
 149              	@ ------------------------------------------------------------------------
 150              	@ see if string has a '-' prefix
 151              	
 152              	@     ( a1 n1 --- sign a1' n1' )
 153              	
 154              	qnegative:
 155              	  rpush lr
 155 16b0 4CF804ED 	>  str lr,[rp,#-4]!
 156 16b4 FEF756FF 	  bl over                 @ fetch first character of the string
 157 16b8 FFF796F8 	  bl cfetch
 158              	  cliteral '-'            @ compare it with a '-' character
 158 16bc 01B4     	>  push { r0 }
 158 16be 2D20     	>  movs r0,#45
 159 16c0 FFF724FC 	  bl equals
 160 16c4 FEF770FF 	  bl drot                 @ save result for later but...
 161 16c8 FEF75CFF 	  bl pluck                @ make a copy of the result to test here too
 162 16cc 00F0CEFB 	  bl qbranch
 163 16d0 0B00     	  .hword (1f - .) + 1     @ if the number did have a '-' prefix then
 164              	  cliteral 1              @ skip past this prefix
 164 16d2 01B4     	>  push { r0 }
 164 16d4 0120     	>  movs r0,#1
 165 16d6 FFF723FE 	  bl sstring
 166              	1:
 167              	  exit
 167              	>  rpop pc
 167 16da 5CF804FB 	>>  ldr pc,[rp],#4
 168              	
 169              	@ ------------------------------------------------------------------------
 170              	@ attempt to convert parsed in input to a number (input is at address a1)
 171              	
 172              	@     ( a1 --- n1 t | f )
 173              	
 174              	colon "number", number
 174              	>  header "number",number
 174              	>>  _header_ "number",number
 174              	>>>  .section .data
 174 0dd4 C80D0000 	>>>  .int _thread
 174              	>>>  .set _thread,.
 174              	>>> 8:
 174              	>>>  hstring "number"
 174 0dd8 06       	>>>>  .byte lex+9f-(.+1)
 174 0dd9 6E756D62 	>>>>  .ascii "number"
 174      6572
 174              	>>>> 9:
 174 0ddf 00       	>>>>  .balign 4,0
 174              	>>>  .set lex,0
 174 0de0 E4160000 	>>>  .int number
 174              	>>>  .previous
 174 16de 0000     	>>  .balign 4,0
 174 16e0 D80D0000 	>>  .int _thread
 174              	> number:
 174 16e4 AFF30080 	>  nop.w
 174              	>  rpush lr
 174 16e8 4CF804ED 	>>  str lr,[rp,#-4]!
 175 16ec FFF7F8F8 	  bl count                @ get address and length of string
 176 16f0 FFF7DEFF 	  bl qnegative            @ test if input specifies a negative value
 177 16f4 FEF736FF 	  bl over                 @ get first character of number string
 178 16f8 FFF776F8 	  bl cfetch               @ to see if it is a radix prefix
 179 16fc 00F04AFB 	  bl docase
 180 1700 2C170000 	  .int 1f                 @ case exit point
 181 1704 A0160000 	  .int defnum             @ defalt when no radix prefix specified
 182 1708 04000000 	  .int 4                  @ case option count
 183 170c 24000000 	  .int '$', hexnum
 183      88160000 
 184 1714 5C000000 	  .int '\\', octnum
 184      70160000 
 185 171c 25000000 	  .int '%', binnum
 185      58160000 
 186 1724 27000000 	  .int 0x27, chrnum
 186      12160000 
 187              	1:
 188              	  exit
 188              	>  rpop pc
 188 172c 5CF804FB 	>>  ldr pc,[rp],#4
 189              	
 190              	@ ========================================================================
 320              	  .include "interpret.s"    @ interpreting input
   1              	@ interpret.s   - the inner interpreter
   2              	@ ------------------------------------------------------------------------
   3              	
   4              	@ ------------------------------------------------------------------------
   5              	
   6              	  _defer_ "quit", quit, pquit
   6              	>  header "quit",quit
   6              	>>  _header_ "quit",quit
   6              	>>>  .section .data
   6 0de4 D80D0000 	>>>  .int _thread
   6              	>>>  .set _thread,.
   6              	>>> 8:
   6              	>>>  hstring "quit"
   6 0de8 04       	>>>>  .byte lex+9f-(.+1)
   6 0de9 71756974 	>>>>  .ascii "quit"
   6              	>>>> 9:
   6 0ded 000000   	>>>>  .balign 4,0
   6              	>>>  .set lex,0
   6 0df0 34170000 	>>>  .int quit
   6              	>>>  .previous
   6              	>>  .balign 4,0
   6 1730 E80D0000 	>>  .int _thread
   6              	> quit:
   6              	>  rpush lr
   6 1734 4CF804ED 	>>  str lr,[rp,#-4]!
   6 1738 FEF714FE 	>  bl dodefer
   6 173c 181A0000 	>  .int pquit
   7              	  _defer_ "abort", abort, pabort
   7              	>  header "abort",abort
   7              	>>  _header_ "abort",abort
   7              	>>>  .section .data
   7 0df4 E80D0000 	>>>  .int _thread
   7              	>>>  .set _thread,.
   7              	>>> 8:
   7              	>>>  hstring "abort"
   7 0df8 05       	>>>>  .byte lex+9f-(.+1)
   7 0df9 61626F72 	>>>>  .ascii "abort"
   7      74
   7              	>>>> 9:
   7 0dfe 0000     	>>>>  .balign 4,0
   7              	>>>  .set lex,0
   7 0e00 44170000 	>>>  .int abort
   7              	>>>  .previous
   7              	>>  .balign 4,0
   7 1740 F80D0000 	>>  .int _thread
   7              	> abort:
   7              	>  rpush lr
   7 1744 4CF804ED 	>>  str lr,[rp,#-4]!
   7 1748 FEF70CFE 	>  bl dodefer
   7 174c 481A0000 	>  .int pabort
   8              	  _defer_ "(interpret)", pinterpret, pxinterpret
   8              	>  header "(interpret)",pinterpret
   8              	>>  _header_ "(interpret)",pinterpret
   8              	>>>  .section .data
   8 0e04 F80D0000 	>>>  .int _thread
   8              	>>>  .set _thread,.
   8              	>>> 8:
   8              	>>>  hstring "(interpret)"
   8 0e08 0B       	>>>>  .byte lex+9f-(.+1)
   8 0e09 28696E74 	>>>>  .ascii "(interpret)"
   8      65727072 
   8      657429
   8              	>>>> 9:
   8              	>>>>  .balign 4,0
   8              	>>>  .set lex,0
   8 0e14 54170000 	>>>  .int pinterpret
   8              	>>>  .previous
   8              	>>  .balign 4,0
   8 1750 080E0000 	>>  .int _thread
   8              	> pinterpret:
   8              	>  rpush lr
   8 1754 4CF804ED 	>>  str lr,[rp,#-4]!
   8 1758 FEF704FE 	>  bl dodefer
   8 175c 88190000 	>  .int pxinterpret
   9              	  _defer_ ".status", dotstatus, noop
   9              	>  header ".status",dotstatus
   9              	>>  _header_ ".status",dotstatus
   9              	>>>  .section .data
   9 0e18 080E0000 	>>>  .int _thread
   9              	>>>  .set _thread,.
   9              	>>> 8:
   9              	>>>  hstring ".status"
   9 0e1c 07       	>>>>  .byte lex+9f-(.+1)
   9 0e1d 2E737461 	>>>>  .ascii ".status"
   9      747573
   9              	>>>> 9:
   9              	>>>>  .balign 4,0
   9              	>>>  .set lex,0
   9 0e24 64170000 	>>>  .int dotstatus
   9              	>>>  .previous
   9              	>>  .balign 4,0
   9 1760 1C0E0000 	>>  .int _thread
   9              	> dotstatus:
   9              	>  rpush lr
   9 1764 4CF804ED 	>>  str lr,[rp,#-4]!
   9 1768 FEF7FCFD 	>  bl dodefer
   9 176c 28030000 	>  .int noop
  10              	  _defer_ ".line#", dotl, noop
  10              	>  header ".line#",dotl
  10              	>>  _header_ ".line#",dotl
  10              	>>>  .section .data
  10 0e28 1C0E0000 	>>>  .int _thread
  10              	>>>  .set _thread,.
  10              	>>> 8:
  10              	>>>  hstring ".line#"
  10 0e2c 06       	>>>>  .byte lex+9f-(.+1)
  10 0e2d 2E6C696E 	>>>>  .ascii ".line#"
  10      6523
  10              	>>>> 9:
  10 0e33 00       	>>>>  .balign 4,0
  10              	>>>  .set lex,0
  10 0e34 74170000 	>>>  .int dotl
  10              	>>>  .previous
  10              	>>  .balign 4,0
  10 1770 2C0E0000 	>>  .int _thread
  10              	> dotl:
  10              	>  rpush lr
  10 1774 4CF804ED 	>>  str lr,[rp,#-4]!
  10 1778 FEF7F4FD 	>  bl dodefer
  10 177c 28030000 	>  .int noop
  11              	  _var_ "ok?",     qok, -1
  11              	>  header "ok?",qok
  11              	>>  _header_ "ok?",qok
  11              	>>>  .section .data
  11 0e38 2C0E0000 	>>>  .int _thread
  11              	>>>  .set _thread,.
  11              	>>> 8:
  11              	>>>  hstring "ok?"
  11 0e3c 03       	>>>>  .byte lex+9f-(.+1)
  11 0e3d 6F6B3F   	>>>>  .ascii "ok?"
  11              	>>>> 9:
  11              	>>>>  .balign 4,0
  11              	>>>  .set lex,0
  11 0e40 84170000 	>>>  .int qok
  11              	>>>  .previous
  11              	>>  .balign 4,0
  11 1780 3C0E0000 	>>  .int _thread
  11              	> qok:
  11              	>  rpush lr
  11 1784 4CF804ED 	>>  str lr,[rp,#-4]!
  11 1788 FEF7F6FD 	>  bl dovar
  11 178c FFFFFFFF 	>  .int -1
  12              	
  13              	@ ------------------------------------------------------------------------
  14              	
  15              	colon "parse", parse
  15              	>  header "parse",parse
  15              	>>  _header_ "parse",parse
  15              	>>>  .section .data
  15 0e44 3C0E0000 	>>>  .int _thread
  15              	>>>  .set _thread,.
  15              	>>> 8:
  15              	>>>  hstring "parse"
  15 0e48 05       	>>>>  .byte lex+9f-(.+1)
  15 0e49 70617273 	>>>>  .ascii "parse"
  15      65
  15              	>>>> 9:
  15 0e4e 0000     	>>>>  .balign 4,0
  15              	>>>  .set lex,0
  15 0e50 94170000 	>>>  .int parse
  15              	>>>  .previous
  15              	>>  .balign 4,0
  15 1790 480E0000 	>>  .int _thread
  15              	> parse:
  15 1794 AFF30080 	>  nop.w
  15              	>  rpush lr
  15 1798 4CF804ED 	>>  str lr,[rp,#-4]!
  16 179c FEF70AFF 	  bl tor                    @ i did not write these two words but took
  17 17a0 FFF77AFC 	  bl source                 @ them from tom zillers FPC.  He took them
  18 17a4 FFF7B0FC 	  bl toin                   @ from laxen and perrys F83.
  19 17a8 FFF7BAFD 	  bl sstring                @ im seriously considering rewriting them
  20 17ac FEF7DAFE 	  bl over                   @ because they are very clever with how
  21 17b0 FEF7BAFE 	  bl swap                   @ they work making them almost completely
  22 17b4 FEF70EFF 	  bl rto                    @ unreadable.
  23 17b8 FFF7B8FE 	  bl scan_word
  24 17bc FEF7FAFE 	  bl tor
  25 17c0 FEF7D0FE 	  bl over
  26 17c4 FFF7DEF9 	  bl minus
  27 17c8 FEF79CFE 	  bl dup
  28 17cc FEF702FF 	  bl rto
  29 17d0 FFF794FB 	  bl znotequ
  30 17d4 FFF7D6F9 	  bl minus
  31 17d8 FFF72AF8 	  bl zplusstoreto
  32 17dc FFF794FC 	  bl toin
  33              	  exit
  33              	>  rpop pc
  33 17e0 5CF804FB 	>>  ldr pc,[rp],#4
  34              	
  35              	@ ------------------------------------------------------------------------
  36              	
  37              	colon "parse-word", parseword
  37              	>  header "parse-word",parseword
  37              	>>  _header_ "parse-word",parseword
  37              	>>>  .section .data
  37 0e54 480E0000 	>>>  .int _thread
  37              	>>>  .set _thread,.
  37              	>>> 8:
  37              	>>>  hstring "parse-word"
  37 0e58 0A       	>>>>  .byte lex+9f-(.+1)
  37 0e59 70617273 	>>>>  .ascii "parse-word"
  37      652D776F 
  37      7264
  37              	>>>> 9:
  37 0e63 00       	>>>>  .balign 4,0
  37              	>>>  .set lex,0
  37 0e64 E8170000 	>>>  .int parseword
  37              	>>>  .previous
  37              	>>  .balign 4,0
  37 17e4 580E0000 	>>  .int _thread
  37              	> parseword:
  37 17e8 AFF30080 	>  nop.w
  37              	>  rpush lr
  37 17ec 4CF804ED 	>>  str lr,[rp,#-4]!
  38 17f0 FEF7E0FE 	  bl tor
  39 17f4 FFF750FC 	  bl source
  40 17f8 FEF7BEFE 	  bl tuck
  41 17fc FFF784FC 	  bl toin
  42 1800 FFF78EFD 	  bl sstring
  43 1804 FEF700FF 	  bl rfetch
  44 1808 FFF770FE 	  bl skip
  45 180c FEF7AAFE 	  bl over
  46 1810 FEF78AFE 	  bl swap
  47 1814 FEF7DEFE 	  bl rto
  48 1818 FFF788FE 	  bl scan_word
  49 181c FEF7CAFE 	  bl tor
  50 1820 FEF7A0FE 	  bl over
  51 1824 FFF7AEF9 	  bl minus
  52 1828 FEF7B8FE 	  bl rot
  53 182c FEF7D2FE 	  bl rto
  54 1830 FEF768FE 	  bl dup
  55 1834 FFF762FB 	  bl znotequ
  56 1838 FFF79EF9 	  bl plus
  57 183c FFF7A2F9 	  bl minus
  58 1840 FEF7E6FF 	  bl zstoreto
  59 1844 FFF760FC 	  bl toin
  60              	  exit
  60              	>  rpop pc
  60 1848 5CF804FB 	>>  ldr pc,[rp],#4
  61              	
  62              	@ ------------------------------------------------------------------------
  63              	@ return numer of charcters left to parse out of input buffers
  64              	
  65              	@     ( --- n1 )
  66              	
  67              	colon "left", left
  67              	>  header "left",left
  67              	>>  _header_ "left",left
  67              	>>>  .section .data
  67 0e68 580E0000 	>>>  .int _thread
  67              	>>>  .set _thread,.
  67              	>>> 8:
  67              	>>>  hstring "left"
  67 0e6c 04       	>>>>  .byte lex+9f-(.+1)
  67 0e6d 6C656674 	>>>>  .ascii "left"
  67              	>>>> 9:
  67 0e71 000000   	>>>>  .balign 4,0
  67              	>>>  .set lex,0
  67 0e74 50180000 	>>>  .int left
  67              	>>>  .previous
  67              	>>  .balign 4,0
  67 184c 6C0E0000 	>>  .int _thread
  67              	> left:
  67 1850 AFF30080 	>  nop.w
  67              	>  rpush lr
  67 1854 4CF804ED 	>>  str lr,[rp,#-4]!
  68 1858 FFF74EFC 	  bl numtib                 @ get total number of characters in tib
  69 185c FFF754FC 	  bl toin                   @ get current parse point
  70 1860 FFF790F9 	  bl minus                  @ compute difference
  71              	  exit
  71              	>  rpop pc
  71 1864 5CF804FB 	>>  ldr pc,[rp],#4
  72              	
  73              	@ ------------------------------------------------------------------------
  74              	@ refill terminal input buffer if there is nothing left to parse
  75              	
  76              	colon "?refill", qrefill
  76              	>  header "?refill",qrefill
  76              	>>  _header_ "?refill",qrefill
  76              	>>>  .section .data
  76 0e78 6C0E0000 	>>>  .int _thread
  76              	>>>  .set _thread,.
  76              	>>> 8:
  76              	>>>  hstring "?refill"
  76 0e7c 07       	>>>>  .byte lex+9f-(.+1)
  76 0e7d 3F726566 	>>>>  .ascii "?refill"
  76      696C6C
  76              	>>>> 9:
  76              	>>>>  .balign 4,0
  76              	>>>  .set lex,0
  76 0e84 6C180000 	>>>  .int qrefill
  76              	>>>  .previous
  76              	>>  .balign 4,0
  76 1868 7C0E0000 	>>  .int _thread
  76              	> qrefill:
  76 186c AFF30080 	>  nop.w
  76              	>  rpush lr
  76 1870 4CF804ED 	>>  str lr,[rp,#-4]!
  77 1874 FFF7ECFF 	  bl left                   @ get number of chars left to parse
  78 1878 FEF766FD 	  bl qexit                  @ if its not zero then exit
  79 187c FFF714FC 	  bl refill                 @ otherwise refill tib
  80              	  exit
  80              	>  rpop pc
  80 1880 5CF804FB 	>>  ldr pc,[rp],#4
  81              	
  82              	@ ------------------------------------------------------------------------
  83              	@ parse next c1 delimited token out of the input buffer
  84              	
  85              	@     ( c1 --- )
  86              	
  87              	colon "word", word_
  87              	>  header "word",word_
  87              	>>  _header_ "word",word_
  87              	>>>  .section .data
  87 0e88 7C0E0000 	>>>  .int _thread
  87              	>>>  .set _thread,.
  87              	>>> 8:
  87              	>>>  hstring "word"
  87 0e8c 04       	>>>>  .byte lex+9f-(.+1)
  87 0e8d 776F7264 	>>>>  .ascii "word"
  87              	>>>> 9:
  87 0e91 000000   	>>>>  .balign 4,0
  87              	>>>  .set lex,0
  87 0e94 88180000 	>>>  .int word_
  87              	>>>  .previous
  87              	>>  .balign 4,0
  87 1884 8C0E0000 	>>  .int _thread
  87              	> word_:
  87 1888 AFF30080 	>  nop.w
  87              	>  rpush lr
  87 188c 4CF804ED 	>>  str lr,[rp,#-4]!
  88 1890 FFF7ECFF 	  bl qrefill                @ first: refill if we have to
  89 1894 FFF7A8FF 	  bl parseword              @ parse c1 delimited string from tib
  90 1898 00F0F2FB 	  bl hhere                  @ copy the parsed string to hhere as a counted
  91 189c FFF738F9 	  bl strstore               @ string
  92              	  exit
  92              	>  rpop pc
  92 18a0 5CF804FB 	>>  ldr pc,[rp],#4
  93              	
  94              	@ ------------------------------------------------------------------------
  95              	@ search context for next space delimited token from input stream
  96              	
  97              	@     ( --- cfa f1 | false )
  98              	
  99              	colon "defined", defined
  99              	>  header "defined",defined
  99              	>>  _header_ "defined",defined
  99              	>>>  .section .data
  99 0e98 8C0E0000 	>>>  .int _thread
  99              	>>>  .set _thread,.
  99              	>>> 8:
  99              	>>>  hstring "defined"
  99 0e9c 07       	>>>>  .byte lex+9f-(.+1)
  99 0e9d 64656669 	>>>>  .ascii "defined"
  99      6E6564
  99              	>>>> 9:
  99              	>>>>  .balign 4,0
  99              	>>>  .set lex,0
  99 0ea4 A8180000 	>>>  .int defined
  99              	>>>  .previous
  99              	>>  .balign 4,0
  99 18a4 9C0E0000 	>>  .int _thread
  99              	> defined:
  99 18a8 AFF30080 	>  nop.w
  99              	>  rpush lr
  99 18ac 4CF804ED 	>>  str lr,[rp,#-4]!
 100 18b0 FFF7EAFB 	  bl bl_                    @ parse next space delimited token out of
 101 18b4 FFF7E8FF 	  bl word_                  @ the input stream
 102 18b8 00F0C8FC 	  bl find                   @ see if a word with this name is defined
 103              	  exit                      @ and in context
 103              	>  rpop pc
 103 18bc 5CF804FB 	>>  ldr pc,[rp],#4
 104              	
 105              	@ ------------------------------------------------------------------------
 106              	@ abort if parsed string is not a known word
 107              	
 108              	@     ( f1 --- )
 109              	
 110              	colon "?missing", qmissing
 110              	>  header "?missing",qmissing
 110              	>>  _header_ "?missing",qmissing
 110              	>>>  .section .data
 110 0ea8 9C0E0000 	>>>  .int _thread
 110              	>>>  .set _thread,.
 110              	>>> 8:
 110              	>>>  hstring "?missing"
 110 0eac 08       	>>>>  .byte lex+9f-(.+1)
 110 0ead 3F6D6973 	>>>>  .ascii "?missing"
 110      73696E67 
 110              	>>>> 9:
 110 0eb5 000000   	>>>>  .balign 4,0
 110              	>>>  .set lex,0
 110 0eb8 C4180000 	>>>  .int qmissing
 110              	>>>  .previous
 110              	>>  .balign 4,0
 110 18c0 AC0E0000 	>>  .int _thread
 110              	> qmissing:
 110 18c4 AFF30080 	>  nop.w
 110              	>  rpush lr
 110 18c8 4CF804ED 	>>  str lr,[rp,#-4]!
 111 18cc FFF706FB 	  bl not                    @ if f1 is false word is defined
 112 18d0 FEF73AFD 	  bl qexit                  @ so exit
 113 18d4 00F0D4FB 	  bl hhere                  @ otherwise emit the offending string
 114 18d8 FFF702F8 	  bl count
 115 18dc FFF7BEFC 	  bl space
 116 18e0 FFF7F2FB 	  bl type
 117 18e4 FFF7D8FA 	  bl true                   @ force an unconditional abort
 118 18e8 FFF7EAFC 	  bl pabortq                @ and display the following string
 119              	  hstring " ?"
 119 18ec 02       	>  .byte lex+9f-(.+1)
 119 18ed 203F     	>  .ascii " ?"
 119              	> 9:
 119 18ef 00       	>  .balign 4,0
 120              	@ exit
 121              	
 122              	@ ------------------------------------------------------------------------
 123              	@ search context for next token from input stream, abort if not found
 124              	
 125              	@     ( --- a1 )
 126              	
 127              	colon "'", tick
 127              	>  header "'",tick
 127              	>>  _header_ "'",tick
 127              	>>>  .section .data
 127 0ebc AC0E0000 	>>>  .int _thread
 127              	>>>  .set _thread,.
 127              	>>> 8:
 127              	>>>  hstring "'"
 127 0ec0 01       	>>>>  .byte lex+9f-(.+1)
 127 0ec1 27       	>>>>  .ascii "'"
 127              	>>>> 9:
 127 0ec2 0000     	>>>>  .balign 4,0
 127              	>>>  .set lex,0
 127 0ec4 F4180000 	>>>  .int tick
 127              	>>>  .previous
 127              	>>  .balign 4,0
 127 18f0 C00E0000 	>>  .int _thread
 127              	> tick:
 127 18f4 AFF30080 	>  nop.w
 127              	>  rpush lr
 127 18f8 4CF804ED 	>>  str lr,[rp,#-4]!
 128 18fc FFF7D4FF 	  bl defined                @ parse token, search dictionary
 129 1900 FFF7ECFA 	  bl not                    @ invert flag indicating success or failure
 130 1904 FFF7DEFF 	  bl qmissing               @ abort if parsed string is not a known word
 131              	  exit
 131              	>  rpop pc
 131 1908 5CF804FB 	>>  ldr pc,[rp],#4
 132              	
 133              	@ ------------------------------------------------------------------------
 134              	@ compile a number or return its value
 135              	
 136              	@       ( n1 --- n1 | )
 137              	
 138              	colon "?comp#", qcompnum
 138              	>  header "?comp#",qcompnum
 138              	>>  _header_ "?comp#",qcompnum
 138              	>>>  .section .data
 138 0ec8 C00E0000 	>>>  .int _thread
 138              	>>>  .set _thread,.
 138              	>>> 8:
 138              	>>>  hstring "?comp#"
 138 0ecc 06       	>>>>  .byte lex+9f-(.+1)
 138 0ecd 3F636F6D 	>>>>  .ascii "?comp#"
 138      7023
 138              	>>>> 9:
 138 0ed3 00       	>>>>  .balign 4,0
 138              	>>>  .set lex,0
 138 0ed4 10190000 	>>>  .int qcompnum
 138              	>>>  .previous
 138              	>>  .balign 4,0
 138 190c CC0E0000 	>>  .int _thread
 138              	> qcompnum:
 138 1910 AFF30080 	>  nop.w
 138              	>  rpush lr
 138 1914 4CF804ED 	>>  str lr,[rp,#-4]!
 139 1918 00F0B6F8 	  bl state                  @ if we are currently in interpret mode then
 140 191c FFF7DEFA 	  bl not                    @ return n1
 141 1920 FEF712FD 	  bl qexit
 142 1924 00F098F9 	  bl literal                @ otherwise compile it as a literal
 143              	  exit
 143              	>  rpop pc
 143 1928 5CF804FB 	>>  ldr pc,[rp],#4
 144              	
 145              	@ ------------------------------------------------------------------------
 146              	@ input not a know word. is it a valid number in current radix?
 147              	
 148              	@       ( --- n1 | )
 149              	
 150              	colon "?#", qnum
 150              	>  header "?#",qnum
 150              	>>  _header_ "?#",qnum
 150              	>>>  .section .data
 150 0ed8 CC0E0000 	>>>  .int _thread
 150              	>>>  .set _thread,.
 150              	>>> 8:
 150              	>>>  hstring "?#"
 150 0edc 02       	>>>>  .byte lex+9f-(.+1)
 150 0edd 3F23     	>>>>  .ascii "?#"
 150              	>>>> 9:
 150 0edf 00       	>>>>  .balign 4,0
 150              	>>>  .set lex,0
 150 0ee0 30190000 	>>>  .int qnum
 150              	>>>  .previous
 150              	>>  .balign 4,0
 150 192c DC0E0000 	>>  .int _thread
 150              	> qnum:
 150 1930 AFF30080 	>  nop.w
 150              	>  rpush lr
 150 1934 4CF804ED 	>>  str lr,[rp,#-4]!
 151 1938 00F0A2FB 	  bl hhere                  @ null input is not a number nor an error
 152 193c FEF754FF 	  bl cfetch
 153 1940 FFF7D0FA 	  bl zequals
 154 1944 FEF700FD 	  bl qexit
 155 1948 00F09AFB 	  bl hhere                  @ input is not null, pass string to number
 156 194c FFF7CAFE 	  bl number                 @ ( --- n1 t | f )
 157 1950 FFF7C4FA 	  bl not                    @ if number was not found then
 158 1954 FFF7B6FF 	  bl qmissing               @ abort
 159 1958 FFF7DAFF 	  bl qcompnum               @ otherwise return number or compile it
 160              	  exit
 160              	>  rpop pc
 160 195c 5CF804FB 	>>  ldr pc,[rp],#4
 161              	
 162              	@ ------------------------------------------------------------------------
 163              	@ input is a known word. compile it or execute it
 164              	
 165              	@       ( xt [ t | 1 ] --- )
 166              	
 167              	colon "?exec", qexec
 167              	>  header "?exec",qexec
 167              	>>  _header_ "?exec",qexec
 167              	>>>  .section .data
 167 0ee4 DC0E0000 	>>>  .int _thread
 167              	>>>  .set _thread,.
 167              	>>> 8:
 167              	>>>  hstring "?exec"
 167 0ee8 05       	>>>>  .byte lex+9f-(.+1)
 167 0ee9 3F657865 	>>>>  .ascii "?exec"
 167      63
 167              	>>>> 9:
 167 0eee 0000     	>>>>  .balign 4,0
 167              	>>>  .set lex,0
 167 0ef0 64190000 	>>>  .int qexec
 167              	>>>  .previous
 167              	>>  .balign 4,0
 167 1960 E80E0000 	>>  .int _thread
 167              	> qexec:
 167 1964 AFF30080 	>  nop.w
 167              	>  rpush lr
 167 1968 4CF804ED 	>>  str lr,[rp,#-4]!
 168 196c 00F08CF8 	  bl state                @ if current state is interpret not compile
 169 1970 FFF7AEFA 	  bl xor                  @ or if the word is immediate
 170              	
 171 1974 00F04AFA 	  bl qcolon
 172 1978 FEF7EEFC 	  bl execute              @ then execute the word
 173 197c 00F0D6F8 	  bl commaxt              @ else compile an xt to it
 174              	  exit
 174              	>  rpop pc
 174 1980 5CF804FB 	>>  ldr pc,[rp],#4
 175              	
 176              	@ ------------------------------------------------------------------------
 177              	
 178              	@       ( xt [t | 1] | f --- n1 | )
 179              	
 180              	colon "(xinterpret)", pxinterpret
 180              	>  header "(xinterpret)",pxinterpret
 180              	>>  _header_ "(xinterpret)",pxinterpret
 180              	>>>  .section .data
 180 0ef4 E80E0000 	>>>  .int _thread
 180              	>>>  .set _thread,.
 180              	>>> 8:
 180              	>>>  hstring "(xinterpret)"
 180 0ef8 0C       	>>>>  .byte lex+9f-(.+1)
 180 0ef9 2878696E 	>>>>  .ascii "(xinterpret)"
 180      74657270 
 180      72657429 
 180              	>>>> 9:
 180 0f05 000000   	>>>>  .balign 4,0
 180              	>>>  .set lex,0
 180 0f08 88190000 	>>>  .int pxinterpret
 180              	>>>  .previous
 180              	>>  .balign 4,0
 180 1984 F80E0000 	>>  .int _thread
 180              	> pxinterpret:
 180 1988 AFF30080 	>  nop.w
 180              	>  rpush lr
 180 198c 4CF804ED 	>>  str lr,[rp,#-4]!
 181 1990 FEF7B2FD 	  bl qdup                 @ was the word found?
 182 1994 00F03AFA 	  bl qcolon
 183 1998 FFF7E4FF 	  bl qexec                @ if so execute or compile it
 184 199c FFF7C8FF 	  bl qnum                 @ else see if its a number
 185              	  exit
 185              	>  rpop pc
 185 19a0 5CF804FB 	>>  ldr pc,[rp],#4
 186              	
 187              	@ ------------------------------------------------------------------------
 188              	@ interpret all input till no input left in buffer
 189              	
 190              	colon "interpret", interpret
 190              	>  header "interpret",interpret
 190              	>>  _header_ "interpret",interpret
 190              	>>>  .section .data
 190 0f0c F80E0000 	>>>  .int _thread
 190              	>>>  .set _thread,.
 190              	>>> 8:
 190              	>>>  hstring "interpret"
 190 0f10 09       	>>>>  .byte lex+9f-(.+1)
 190 0f11 696E7465 	>>>>  .ascii "interpret"
 190      72707265 
 190      74
 190              	>>>> 9:
 190 0f1a 0000     	>>>>  .balign 4,0
 190              	>>>  .set lex,0
 190 0f1c A8190000 	>>>  .int interpret
 190              	>>>  .previous
 190              	>>  .balign 4,0
 190 19a4 100F0000 	>>  .int _thread
 190              	> interpret:
 190 19a8 AFF30080 	>  nop.w
 190              	>  rpush lr
 190 19ac 4CF804ED 	>>  str lr,[rp,#-4]!
 191              	0:
 192 19b0 FFF77AFF 	  bl defined              @ parse space delimited token out, find it
 193 19b4 FFF7CEFE 	  bl pinterpret           @ interpret or compile it
 194 19b8 FEF78AFE 	  bl qstack               @ check stack for under/overflow
 195 19bc FFF748FF 	  bl left                 @ is there is anything left in the input stream
 196 19c0 FFF790FA 	  bl zequals
 197 19c4 00F052FA 	  bl qbranch              @ repeat until nothing left
 198 19c8 E9FF     	  .hword (0b - .) + 1
 199              	  exit
 199              	>  rpop pc
 199 19ca 5CF804FB 	>>  ldr pc,[rp],#4
 200              	
 201              	@ ------------------------------------------------------------------------
 202              	
 203              	colon ".ok", dotok
 203              	>  header ".ok",dotok
 203              	>>  _header_ ".ok",dotok
 203              	>>>  .section .data
 203 0f20 100F0000 	>>>  .int _thread
 203              	>>>  .set _thread,.
 203              	>>> 8:
 203              	>>>  hstring ".ok"
 203 0f24 03       	>>>>  .byte lex+9f-(.+1)
 203 0f25 2E6F6B   	>>>>  .ascii ".ok"
 203              	>>>> 9:
 203              	>>>>  .balign 4,0
 203              	>>>  .set lex,0
 203 0f28 D4190000 	>>>  .int dotok
 203              	>>>  .previous
 203 19ce 0000     	>>  .balign 4,0
 203 19d0 240F0000 	>>  .int _thread
 203              	> dotok:
 203 19d4 AFF30080 	>  nop.w
 203              	>  rpush lr
 203 19d8 4CF804ED 	>>  str lr,[rp,#-4]!
 204 19dc 00F080FC 	  bl floads                 @ dont display oks if floading
 205 19e0 FEF7B2FC 	  bl qexit
 206 19e4 00F050F8 	  bl state                  @ or if in compile mode
 207 19e8 FFF778FA 	  bl not
 208 19ec FFF7CAFE 	  bl qok                    @ or if there was an abort
 209 19f0 FFF762FA 	  bl and_
 210 19f4 00F03AFA 	  bl qbranch
 211 19f8 0D00     	  .hword (1f - .) + 1
 212 19fa FFF747FC 	  bl pdotq
 213              	  hstring " ok"
 213 19fe 03       	>  .byte lex+9f-(.+1)
 213 19ff 206F6B   	>  .ascii " ok"
 213              	> 9:
 213 1a02 0000     	>  .balign 4,0
 214              	1:
 215 1a04 FFF70EFC 	  bl cr_
 216 1a08 FEF748FF 	  bl zonto                  @ clear any previous abort condition
 217 1a0c FFF7BAFE 	  bl qok
 218              	  exit
 218              	>  rpop pc
 218 1a10 5CF804FB 	>>  ldr pc,[rp],#4
 219              	
 220              	@ ------------------------------------------------------------------------
 221              	@ forths inner interpret loop
 222              	
 223              	colon "(quit)", pquit
 223              	>  header "(quit)",pquit
 223              	>>  _header_ "(quit)",pquit
 223              	>>>  .section .data
 223 0f2c 240F0000 	>>>  .int _thread
 223              	>>>  .set _thread,.
 223              	>>> 8:
 223              	>>>  hstring "(quit)"
 223 0f30 06       	>>>>  .byte lex+9f-(.+1)
 223 0f31 28717569 	>>>>  .ascii "(quit)"
 223      7429
 223              	>>>> 9:
 223 0f37 00       	>>>>  .balign 4,0
 223              	>>>  .set lex,0
 223 0f38 181A0000 	>>>  .int pquit
 223              	>>>  .previous
 223              	>>  .balign 4,0
 223 1a14 300F0000 	>>  .int _thread
 223              	> pquit:
 223 1a18 AFF30080 	>  nop.w
 223              	>  rpush lr
 223 1a1c 4CF804ED 	>>  str lr,[rp,#-4]!
 224 1a20 00F044F9 	  bl lbracket               @ turn compile state off
 225 1a24 FEF760FD 	  bl rp0                    @ reset the return stack
 226 1a28 FEF706FE 	  bl rpstore
 227 1a2c FEF754FD 	  bl sp0                    @ reset the parameter stack
 228 1a30 FEF7F6FD 	  bl spstore
 229              	0:                          @ an infinite loop
 230 1a34 FFF796FE 	  bl dotstatus              @ display status line (an extension)
 231 1a38 FFF7CCFF 	  bl dotok                  @ display ok (maybe)
 232 1a3c FFF7B4FF 	  bl interpret              @ interpret next line of imput
 233 1a40 F8E7     	  b 0b                      @ only an abort can break out of this
 234              	
 235              	@ ------------------------------------------------------------------------
 236              	
 237              	colon "(abort)", pabort
 237              	>  header "(abort)",pabort
 237              	>>  _header_ "(abort)",pabort
 237              	>>>  .section .data
 237 0f3c 300F0000 	>>>  .int _thread
 237              	>>>  .set _thread,.
 237              	>>> 8:
 237              	>>>  hstring "(abort)"
 237 0f40 07       	>>>>  .byte lex+9f-(.+1)
 237 0f41 2861626F 	>>>>  .ascii "(abort)"
 237      727429
 237              	>>>> 9:
 237              	>>>>  .balign 4,0
 237              	>>>  .set lex,0
 237 0f48 481A0000 	>>>  .int pabort
 237              	>>>  .previous
 237 1a42 0000     	>>  .balign 4,0
 237 1a44 400F0000 	>>  .int _thread
 237              	> pabort:
 237 1a48 AFF30080 	>  nop.w
 237              	>  rpush lr
 237 1a4c 4CF804ED 	>>  str lr,[rp,#-4]!
 238 1a50 FFF790FE 	  bl dotl                   @ kludgy. display line number of abort
 239              	0:                          @ break out of all floads
 240 1a54 00F044FC 	  bl floads                 @ while we are still floading something
 241 1a58 00F008FA 	  bl qbranch
 242 1a5c 0D00     	  .hword (1f - .) + 1
 243 1a5e 00F01BFD 	  bl abort_fload            @ abort current file
 244 1a62 00F0F9F9 	  bl branch                 @ and repeat
 245 1a66 EFFF     	  .hword (0b - .) + 1
 246              	1:
 247 1a68 FEF72AFF 	  bl zoffto                 @ clear tib
 248 1a6c FFF744FB 	  bl numtib
 249 1a70 FEF726FF 	  bl zoffto                 @ reset interpret index
 250 1a74 FFF748FB 	  bl toin
 251 1a78 FEF722FF 	  bl zoffto                 @ an abort is never ok
 252 1a7c FFF782FE 	  bl qok
 253 1a80 FFF758FE 	  bl quit                   @ jump back into main interpret loop
 254              	
 255              	@ ========================================================================
 321              	
 322              	  _compiler_
 322              	>  .if voc!=compiler
 322              	>  .if voc==forth
 322              	>  .set forth_link,_thread
 322              	>  .endif
 322              	> 
 322              	>  .if voc==root
 322              	>  .set root_link,_thread
 322              	>  .endif
 322              	> 
 322              	>  .set voc,compiler
 322              	>  .set _thread,comp_link
 322              	>  .endif
 323              	
 324              	  .include "compile.s"      @ creating and compiling
   1              	@ compile.s
   2              	@ ------------------------------------------------------------------------
   3              	
   4              	@ ------------------------------------------------------------------------
   5              	
   6              	  _var_ "state",   state, 0       @ current compile state
   6              	>  header "state",state
   6              	>>  _header_ "state",state
   6              	>>>  .section .data
   6 0f4c 00000000 	>>>  .int _thread
   6              	>>>  .set _thread,.
   6              	>>> 8:
   6              	>>>  hstring "state"
   6 0f50 05       	>>>>  .byte lex+9f-(.+1)
   6 0f51 73746174 	>>>>  .ascii "state"
   6      65
   6              	>>>> 9:
   6 0f56 0000     	>>>>  .balign 4,0
   6              	>>>  .set lex,0
   6 0f58 881A0000 	>>>  .int state
   6              	>>>  .previous
   6              	>>  .balign 4,0
   6 1a84 500F0000 	>>  .int _thread
   6              	> state:
   6              	>  rpush lr
   6 1a88 4CF804ED 	>>  str lr,[rp,#-4]!
   6 1a8c FEF774FC 	>  bl dovar
   6 1a90 00000000 	>  .int 0
   7              	  _var_ "last",    last, last_hdr @ nfa of most recently created word
   7              	>  header "last",last
   7              	>>  _header_ "last",last
   7              	>>>  .section .data
   7 0f5c 500F0000 	>>>  .int _thread
   7              	>>>  .set _thread,.
   7              	>>> 8:
   7              	>>>  hstring "last"
   7 0f60 04       	>>>>  .byte lex+9f-(.+1)
   7 0f61 6C617374 	>>>>  .ascii "last"
   7              	>>>> 9:
   7 0f65 000000   	>>>>  .balign 4,0
   7              	>>>  .set lex,0
   7 0f68 981A0000 	>>>  .int last
   7              	>>>  .previous
   7              	>>  .balign 4,0
   7 1a94 600F0000 	>>  .int _thread
   7              	> last:
   7              	>  rpush lr
   7 1a98 4CF804ED 	>>  str lr,[rp,#-4]!
   7 1a9c FEF76CFC 	>  bl dovar
   7 1aa0 AC150000 	>  .int last_hdr
   8              	  _var_ "thread",  thread, 0      @ which voc thread to attach word to
   8              	>  header "thread",thread
   8              	>>  _header_ "thread",thread
   8              	>>>  .section .data
   8 0f6c 600F0000 	>>>  .int _thread
   8              	>>>  .set _thread,.
   8              	>>> 8:
   8              	>>>  hstring "thread"
   8 0f70 06       	>>>>  .byte lex+9f-(.+1)
   8 0f71 74687265 	>>>>  .ascii "thread"
   8      6164
   8              	>>>> 9:
   8 0f77 00       	>>>>  .balign 4,0
   8              	>>>  .set lex,0
   8 0f78 A81A0000 	>>>  .int thread
   8              	>>>  .previous
   8              	>>  .balign 4,0
   8 1aa4 700F0000 	>>  .int _thread
   8              	> thread:
   8              	>  rpush lr
   8 1aa8 4CF804ED 	>>  str lr,[rp,#-4]!
   8 1aac FEF764FC 	>  bl dovar
   8 1ab0 00000000 	>  .int 0
   9              	
  10              	  @ last_hdr above is defined in the linker script
  11              	
  12              	@ ------------------------------------------------------------------------
  13              	@ clear instruction cache for a given range
  14              	
  15              	@   ( end start --- )
  16              	
  17              	code "clrcache", clrcache   @ reveal automatically does this
  17              	>  header "clrcache",clrcache
  17              	>>  _header_ "clrcache",clrcache
  17              	>>>  .section .data
  17 0f7c 700F0000 	>>>  .int _thread
  17              	>>>  .set _thread,.
  17              	>>> 8:
  17              	>>>  hstring "clrcache"
  17 0f80 08       	>>>>  .byte lex+9f-(.+1)
  17 0f81 636C7263 	>>>>  .ascii "clrcache"
  17      61636865 
  17              	>>>> 9:
  17 0f89 000000   	>>>>  .balign 4,0
  17              	>>>  .set lex,0
  17 0f8c B81A0000 	>>>  .int clrcache
  17              	>>>  .previous
  17              	>>  .balign 4,0
  17 1ab4 800F0000 	>>  .int _thread
  17              	> clrcache:
  18 1ab8 02BC     	  pop { r1 }                @ get end address to clear icache for
  19 1aba 40F20207 	  movw r7, 0x02             @ funky syscall number
  20 1abe C0F20F07 	  movt r7, 0x0f
  21 1ac2 0022     	  movs r2, #0
  22 1ac4 00DF     	  swi 0
  23 1ac6 01BC     	  pop { r0 }
  24              	  next
  24 1ac8 7047     	>  bx lr
  25              	
  26              	@ ------------------------------------------------------------------------
  27              	@ align address a1 to 4 byte boundry
  28              	
  29              	@     ( a1 --- a2 )
  30              	
  31              	code "align", align
  31              	>  header "align",align
  31              	>>  _header_ "align",align
  31              	>>>  .section .data
  31 0f90 800F0000 	>>>  .int _thread
  31              	>>>  .set _thread,.
  31              	>>> 8:
  31              	>>>  hstring "align"
  31 0f94 05       	>>>>  .byte lex+9f-(.+1)
  31 0f95 616C6967 	>>>>  .ascii "align"
  31      6E
  31              	>>>> 9:
  31 0f9a 0000     	>>>>  .balign 4,0
  31              	>>>  .set lex,0
  31 0f9c D01A0000 	>>>  .int align
  31              	>>>  .previous
  31 1aca 0000     	>>  .balign 4,0
  31 1acc 940F0000 	>>  .int _thread
  31              	> align:
  32 1ad0 0330     	  adds r0, r0, #3
  33 1ad2 20F00300 	  bic r0, r0, #3
  34              	  next
  34 1ad6 7047     	>  bx lr
  35              	
  36              	@ ------------------------------------------------------------------------
  37              	@ like (lit) but different
  38              	
  39              	@ not used in this thumb2 kernel
  40              	
  41              	@ code "param", param
  42              	@   push { r0 }               @ save top of stack
  43              	@   rpop r2                   @ get return address
  44              	@   bic r2, #1                @ return addresses are always odd
  45              	@   ldrh r0, [r2]             @ fetch 32 bit xt as 2 16 bit reads
  46              	@   ldrh r1, [r2, #2]         @ because 32 bit fetches must be 32 bit aligned
  47              	@   add r0, r0, r1, lsl #16   @ combine the two 16 bit fetches
  48              	@   add r2, r2, #5            @ make sure return address is odd
  49              	@   rpush r2                  @ return address was advanced past data
  50              	@   next
  51              	
  52              	@ ------------------------------------------------------------------------
  53              	@ at address a2, compile a bl opcode to address a1
  54              	
  55              	@ 1111 0... .... .... 11.1 .... .... ....   template
  56              	@ .... .SII IIII IIII ..J. Jiii iiii iiii   opcode
  57              	@ .... .... SJJI IIII IIII Iiii iiii iiii   address / 2
  58              	
  59              	@     ( a1 a2 --- )
  60              	
  61              	code "call!", callstore
  61              	>  header "call!",callstore
  61              	>>  _header_ "call!",callstore
  61              	>>>  .section .data
  61 0fa0 940F0000 	>>>  .int _thread
  61              	>>>  .set _thread,.
  61              	>>> 8:
  61              	>>>  hstring "call!"
  61 0fa4 05       	>>>>  .byte lex+9f-(.+1)
  61 0fa5 63616C6C 	>>>>  .ascii "call!"
  61      21
  61              	>>>> 9:
  61 0faa 0000     	>>>>  .balign 4,0
  61              	>>>  .set lex,0
  61 0fac DC1A0000 	>>>  .int callstore
  61              	>>>  .previous
  61              	>>  .balign 4,0
  61 1ad8 A40F0000 	>>  .int _thread
  61              	> callstore:
  62 1adc 02BC     	  pop { r1 }                @ get target address
  63 1ade 4DF20007 	  movw r7, #0xd000          @ template for bl opcode
  64 1ae2 CFF20007 	  movt r7, #0xf000
  65              	
  66 1ae6 091A     	  subs r1, r1, r0           @ calculate branch delta
  67 1ae8 0439     	  subs r1, r1, #4
  68 1aea 4910     	  asrs r1, r1, #1
  69              	
  70 1aec C1F30A02 	  ubfx r2, r1, #0, #11      @ R2 = I11
  71 1af0 C1F3C923 	  ubfx r3, r1, #11, #10     @ R3 = I10
  72 1af4 C1F34054 	  ubfx r4, r1, #21, #1      @ R4 = I2
  73 1af8 C1F38055 	  ubfx r5, r1, #22, #1      @ R5 = I1
  74 1afc C1F3C076 	  ubfx r6, r1, #31, #1      @ R6 = S
  75              	
  76 1b00 7440     	  eors r4, r4, r6           @ J1 = !(S ^ I1)
  77 1b02 7540     	  eors r5, r5, r6           @ J2 = !(S ^ I2)
  78 1b04 E443     	  mvns r4, r4
  79 1b06 ED43     	  mvns r5, r5
  80              	
  81 1b08 62F30A07 	  bfi r7, r2, #0, #11       @ stitch it all together
  82 1b0c 63F31947 	  bfi r7, r3, #16, #10
  83 1b10 64F3CB27 	  bfi r7, r4, #11, #1
  84 1b14 65F34D37 	  bfi r7, r5, #13, #1
  85 1b18 66F39A67 	  bfi r7, r6, #26, #1
  86              	
  87 1b1c 4780     	  strh r7, [r0, #2]         @ write opcode
  88 1b1e 3E0C     	  lsrs r6, r7, #16
  89 1b20 0680     	  strh r6, [r0]
  90              	
  91 1b22 01BC     	  pop { r0 }
  92              	  next
  92 1b24 7047     	>  bx lr
  93              	
  94              	@ ------------------------------------------------------------------------
  95              	@ compile a bl to address a1 at 'here'
  96              	
  97              	@     ( a1 --- )
  98              	
  99              	colon ",xt", commaxt
  99              	>  header ",xt",commaxt
  99              	>>  _header_ ",xt",commaxt
  99              	>>>  .section .data
  99 0fb0 A40F0000 	>>>  .int _thread
  99              	>>>  .set _thread,.
  99              	>>> 8:
  99              	>>>  hstring ",xt"
  99 0fb4 03       	>>>>  .byte lex+9f-(.+1)
  99 0fb5 2C7874   	>>>>  .ascii ",xt"
  99              	>>>> 9:
  99              	>>>>  .balign 4,0
  99              	>>>  .set lex,0
  99 0fb8 2C1B0000 	>>>  .int commaxt
  99              	>>>  .previous
  99 1b26 0000     	>>  .balign 4,0
  99 1b28 B40F0000 	>>  .int _thread
  99              	> commaxt:
  99 1b2c AFF30080 	>  nop.w
  99              	>  rpush lr
  99 1b30 4CF804ED 	>>  str lr,[rp,#-4]!
 100 1b34 00F09CFA 	  bl here                   @ get address to compile
 101 1b38 FEF7F8FD 	  bl cell                   @ allocate one cell for opcode
 102 1b3c 00F056FA 	  bl allot
 103 1b40 FFF7CCFF 	  bl callstore              @ compile bl to address a1
 104              	  exit
 104              	>  rpop pc
 104 1b44 5CF804FB 	>>  ldr pc,[rp],#4
 105              	
 106              	@ ------------------------------------------------------------------------
 107              	@ disassemble a bl opcode into its target address
 108              	
 109              	@   ( a1 --- a2 )
 110              	
 111              	code "xt@", xtfetch
 111              	>  header "xt@",xtfetch
 111              	>>  _header_ "xt@",xtfetch
 111              	>>>  .section .data
 111 0fbc B40F0000 	>>>  .int _thread
 111              	>>>  .set _thread,.
 111              	>>> 8:
 111              	>>>  hstring "xt@"
 111 0fc0 03       	>>>>  .byte lex+9f-(.+1)
 111 0fc1 787440   	>>>>  .ascii "xt@"
 111              	>>>> 9:
 111              	>>>>  .balign 4,0
 111              	>>>  .set lex,0
 111 0fc4 4C1B0000 	>>>  .int xtfetch
 111              	>>>  .previous
 111              	>>  .balign 4,0
 111 1b48 C00F0000 	>>  .int _thread
 111              	> xtfetch:
 112 1b4c 0100     	  movs r1, r0               @ <bl wants r1 = address of bl opcode
 113 1b4e 0A88     	  ldrh r2, [r1]             @ fetch xt opcode
 114 1b50 4B88     	  ldrh r3, [r1, #2]
 115 1b52 03EB0240 	  add r0, r3, r2, lsl #16
 116              	
 117 1b56 00B5     	  push { lr }
 118 1b58 00F03EF9 	  bl from_bl                @ this does the actual work (in loops.s)
 119 1b5c 5DF804EB 	  pop { lr }
 120              	
 121 1b60 01EB0200 	  add r0, r1, r2            @ add branch delta to branch address
 122 1b64 00F10500 	  add r0, r0, #5
 123              	  next
 123 1b68 7047     	>  bx lr
 124              	
 125              	@ ------------------------------------------------------------------------
 126              	@ fetch xt to be compiled. xt is a bl opcode, we need the target address
 127              	
 128              	@     ( --- a1 )
 129              	
 130              	colon "(compile)", pcompile
 130              	>  header "(compile)",pcompile
 130              	>>  _header_ "(compile)",pcompile
 130              	>>>  .section .data
 130 0fc8 C00F0000 	>>>  .int _thread
 130              	>>>  .set _thread,.
 130              	>>> 8:
 130              	>>>  hstring "(compile)"
 130 0fcc 09       	>>>>  .byte lex+9f-(.+1)
 130 0fcd 28636F6D 	>>>>  .ascii "(compile)"
 130      70696C65 
 130      29
 130              	>>>> 9:
 130 0fd6 0000     	>>>>  .balign 4,0
 130              	>>>  .set lex,0
 130 0fd8 701B0000 	>>>  .int pcompile
 130              	>>>  .previous
 130 1b6a 0000     	>>  .balign 4,0
 130 1b6c CC0F0000 	>>  .int _thread
 130              	> pcompile:
 130 1b70 AFF30080 	>  nop.w
 130              	>  rpush lr
 130 1b74 4CF804ED 	>>  str lr,[rp,#-4]!
 131 1b78 01B4     	  push { r0 }               @ save top of stack
 132 1b7a DCF80400 	  ldr r0, [rp, #4]          @ fetch our callers return address
 133 1b7e 021D     	  adds r2, r0, #4           @ advance it past the xt to be compiled
 134 1b80 CCF80420 	  str r2, [rp, #4]
 135 1b84 20F00100 	  bic r0, #1                @ de-thumbificate the address
 136 1b88 FFF7E0FF 	  bl xtfetch                @ fetch and disassemble bl opcode
 137              	  exit
 137              	>  rpop pc
 137 1b8c 5CF804FB 	>>  ldr pc,[rp],#4
 138              	
 139              	@ ------------------------------------------------------------------------
 140              	
 141              	@     ( --- )
 142              	
 143              	colon "compile", compile
 143              	>  header "compile",compile
 143              	>>  _header_ "compile",compile
 143              	>>>  .section .data
 143 0fdc CC0F0000 	>>>  .int _thread
 143              	>>>  .set _thread,.
 143              	>>> 8:
 143              	>>>  hstring "compile"
 143 0fe0 07       	>>>>  .byte lex+9f-(.+1)
 143 0fe1 636F6D70 	>>>>  .ascii "compile"
 143      696C65
 143              	>>>> 9:
 143              	>>>>  .balign 4,0
 143              	>>>  .set lex,0
 143 0fe8 941B0000 	>>>  .int compile
 143              	>>>  .previous
 143              	>>  .balign 4,0
 143 1b90 E00F0000 	>>  .int _thread
 143              	> compile:
 143 1b94 AFF30080 	>  nop.w
 143              	>  rpush lr
 143 1b98 4CF804ED 	>>  str lr,[rp,#-4]!
 144 1b9c FFF7E8FF 	  bl pcompile               @ fetch address to bl to (to call)
 145 1ba0 FFF7C4FF 	  bl commaxt                @ compile call to target address at 'here'
 146              	  exit
 146              	>  rpop pc
 146 1ba4 5CF804FB 	>>  ldr pc,[rp],#4
 147              	
 148              	@ ------------------------------------------------------------------------
 149              	@ compile next space delimited token from input stream as an xt
 150              	
 151              	  _imm_
 151              	>  .set lex,IMM
 152              	
 153              	colon "[compile]", bcompile
 153              	>  header "[compile]",bcompile
 153              	>>  _header_ "[compile]",bcompile
 153              	>>>  .section .data
 153 0fec E00F0000 	>>>  .int _thread
 153              	>>>  .set _thread,.
 153              	>>> 8:
 153              	>>>  hstring "[compile]"
 153 0ff0 89       	>>>>  .byte lex+9f-(.+1)
 153 0ff1 5B636F6D 	>>>>  .ascii "[compile]"
 153      70696C65 
 153      5D
 153              	>>>> 9:
 153 0ffa 0000     	>>>>  .balign 4,0
 153              	>>>  .set lex,0
 153 0ffc AC1B0000 	>>>  .int bcompile
 153              	>>>  .previous
 153              	>>  .balign 4,0
 153 1ba8 F00F0000 	>>  .int _thread
 153              	> bcompile:
 153 1bac AFF30080 	>  nop.w
 153              	>  rpush lr
 153 1bb0 4CF804ED 	>>  str lr,[rp,#-4]!
 154 1bb4 FFF79EFE 	  bl tick                   @ parse input stream, find address of word
 155 1bb8 FFF7B8FF 	  bl commaxt                @ compile a bl to this address
 156              	  exit
 156              	>  rpop pc
 156 1bbc 5CF804FB 	>>  ldr pc,[rp],#4
 157              	
 158              	@ ------------------------------------------------------------------------
 159              	@ same as above but does not comma in an xt but an address (no bl opcode)
 160              	
 161              	@ in some forths this would be how [compile] would be defined
 162              	
 163              	colon "['],", btcomma
 163              	>  header "['],",btcomma
 163              	>>  _header_ "['],",btcomma
 163              	>>>  .section .data
 163 1000 F00F0000 	>>>  .int _thread
 163              	>>>  .set _thread,.
 163              	>>> 8:
 163              	>>>  hstring "['],"
 163 1004 04       	>>>>  .byte lex+9f-(.+1)
 163 1005 5B275D2C 	>>>>  .ascii "['],"
 163              	>>>> 9:
 163 1009 000000   	>>>>  .balign 4,0
 163              	>>>  .set lex,0
 163 100c C41B0000 	>>>  .int btcomma
 163              	>>>  .previous
 163              	>>  .balign 4,0
 163 1bc0 04100000 	>>  .int _thread
 163              	> btcomma:
 163 1bc4 AFF30080 	>  nop.w
 163              	>  rpush lr
 163 1bc8 4CF804ED 	>>  str lr,[rp,#-4]!
 164 1bcc FFF792FE 	  bl tick                   @ parse input stream, find address of word
 165 1bd0 00F028FA 	  bl comma                  @ compile this address (not as a bl opcode)
 166              	  exit
 166              	>  rpop pc
 166 1bd4 5CF804FB 	>>  ldr pc,[rp],#4
 167              	
 168              	@ ------------------------------------------------------------------------
 169              	@ construct a movw or a movt opcode
 170              	
 171              	@     ( w1 op-bit ---- opcode )
 172              	
 173              	@ OPBIT ------------V
 174              	@ MOVT  = 1111 0.10 1100 .... 0... rrrr .... ....
 175              	@ MOVW  = 1111 0.10 0100 .... 0... rrrr .... ....
 176              	
 177              	code"(literal)", pliteral
 177              	>  header "(literal)",pliteral
 177              	>>  _header_ "(literal)",pliteral
 177              	>>>  .section .data
 177 1010 04100000 	>>>  .int _thread
 177              	>>>  .set _thread,.
 177              	>>> 8:
 177              	>>>  hstring "(literal)"
 177 1014 09       	>>>>  .byte lex+9f-(.+1)
 177 1015 286C6974 	>>>>  .ascii "(literal)"
 177      6572616C 
 177      29
 177              	>>>> 9:
 177 101e 0000     	>>>>  .balign 4,0
 177              	>>>  .set lex,0
 177 1020 DC1B0000 	>>>  .int pliteral
 177              	>>>  .previous
 177              	>>  .balign 4,0
 177 1bd8 14100000 	>>  .int _thread
 177              	> pliteral:
 178 1bdc 02BC     	  pop { r1 }                @ get literal w1
 179 1bde 0027     	  movs r7, #0               @ r7 = opcode template
 180 1be0 4FF24027 	  movw r7, #0xf240
 181              	
 182 1be4 C1F30702 	  ubfx r2, r1, #0, #8       @ r2 = imm8
 183 1be8 C1F30223 	  ubfx r3, r1, #8, #3       @ r3 = imm3
 184 1bec C1F3C024 	  ubfx r4, r1, #11, #1      @ r5 = imm1
 185 1bf0 C1F30335 	  ubfx r5, r1, #12, #4      @ r4 = imm4
 186              	
 187 1bf4 60F3C717 	  bfi r7, r0, #7, #1        @ insert op-bit (movw = 0, movt = 1)
 188 1bf8 62F31747 	  bfi r7, r2, #16, #8       @ insert imm8
 189 1bfc 63F31E77 	  bfi r7, r3, #28, #3       @ insert imm3
 190 1c00 64F38A27 	  bfi r7, r4, #10, #1       @ insert imm1
 191 1c04 65F30307 	  bfi r7, r5, #0, #4        @ insert imm4
 192              	
 193 1c08 3800     	  movs r0, r7
 194              	  next
 194 1c0a 7047     	>  bx lr
 195              	
 196              	@ when using movw and movt opcodes you must do the movw operation first
 197              	@ as movw is zero extending.
 198              	
 199              	@ ------------------------------------------------------------------------
 200              	@ compile an inline 16 bit literal
 201              	
 202              	@     ( w1 --- )
 203              	
 204              	wliteral:
 205              	  rpush lr
 205 1c0c 4CF804ED 	>  str lr,[rp,#-4]!
 206              	  cliteral 0              @ op-bit for movw
 206 1c10 01B4     	>  push { r0 }
 206 1c12 0020     	>  movs r0,#0
 207              	1:
 208 1c14 FFF7E2FF 	  bl pliteral             @ construct opcode
 209 1c18 00F004FA 	  bl comma                @ compile opcode
 210              	  exit
 210              	>  rpop pc
 210 1c1c 5CF804FB 	>>  ldr pc,[rp],#4
 211              	
 212              	@ ------------------------------------------------------------------------
 213              	@ compile an inline 32 bit literal
 214              	
 215              	@     ( n1 --- )
 216              	
 217              	dliteral:
 218              	  rpush lr
 218 1c20 4CF804ED 	>  str lr,[rp,#-4]!
 219 1c24 FEF76EFC 	  bl dup                  @ compile a movw r0, #n1.low16
 220 1c28 FFF7F0FF 	  bl wliteral
 221              	  cliteral 16             @ shift upper 16 bits of literal down
 221 1c2c 01B4     	>  push { r0 }
 221 1c2e 1020     	>  movs r0,#16
 222 1c30 FEF7BAFF 	  bl shrr
 223              	  cliteral 1              @ op-bit for movt
 223 1c34 01B4     	>  push { r0 }
 223 1c36 0120     	>  movs r0,#1
 224 1c38 ECE7     	  b 1b
 225              	
 226              	@ ------------------------------------------------------------------------
 227              	@ compile an 8 bit literal
 228              	
 229              	@     ( c1 --- )
 230              	
 231              	cliteral:
 232              	  rpush lr
 232 1c3a 4CF804ED 	>  str lr,[rp,#-4]!
 233 1c3e 42F20001 	  movw r1, #0x2000        @ opcode template
 234 1c42 10F0FF00 	  ands r0, #0xff          @ movs r0, #0xNN
 235 1c46 40EA0100 	  orr r0, r1
 236 1c4a 00F0E3F9 	  bl wcomma
 237              	  exit
 237              	>  rpop pc
 237 1c4e 5CF804FB 	>>  ldr pc,[rp],#4
 238              	
 239              	@ ------------------------------------------------------------------------
 240              	
 241              	  _imm_
 241              	>  .set lex,IMM
 242              	
 243              	colon "literal", literal
 243              	>  header "literal",literal
 243              	>>  _header_ "literal",literal
 243              	>>>  .section .data
 243 1024 14100000 	>>>  .int _thread
 243              	>>>  .set _thread,.
 243              	>>> 8:
 243              	>>>  hstring "literal"
 243 1028 87       	>>>>  .byte lex+9f-(.+1)
 243 1029 6C697465 	>>>>  .ascii "literal"
 243      72616C
 243              	>>>> 9:
 243              	>>>>  .balign 4,0
 243              	>>>  .set lex,0
 243 1030 581C0000 	>>>  .int literal
 243              	>>>  .previous
 243 1c52 0000     	>>  .balign 4,0
 243 1c54 28100000 	>>  .int _thread
 243              	> literal:
 243 1c58 AFF30080 	>  nop.w
 243              	>  rpush lr
 243 1c5c 4CF804ED 	>>  str lr,[rp,#-4]!
 244 1c60 00F0FCF9 	  bl wlitc                  @ compile a push r0
 245 1c64 01B4     	  push { r0 }
 246              	
 247 1c66 FEF74DFC 	  bl dup                    @ pick most efficient coding for the literal
 248              	  wliteral 0x100
 248 1c6a 01B4     	>  push { r0 }
 248 1c6c 40F20010 	>  movw r0,#0x100
 249 1c70 FFF76AF9 	  bl uless
 250 1c74 00F0FAF8 	  bl qbranch
 251 1c78 0B00     	  .hword (1f - .) + 1
 252 1c7a FFF7DEFF 	  bl cliteral               @ mov r0, #literal
 253              	  exit
 253              	>  rpop pc
 253 1c7e 5CF804FB 	>>  ldr pc,[rp],#4
 254              	
 255              	1:
 256 1c82 FEF73FFC 	  bl dup                    @ test if literal fits in 16 bits
 257              	  wliteral 0xffff
 257 1c86 01B4     	>  push { r0 }
 257 1c88 4FF6FF70 	>  movw r0,#0xffff
 258 1c8c FFF762F9 	  bl ugreater
 259 1c90 00F0ECF8 	  bl qbranch
 260 1c94 0B00     	  .hword (2f - .) + 1
 261 1c96 FFF7C3FF 	  bl dliteral               @ compile a 32 bit literal movw/movt
 262              	  exit
 262              	>  rpop pc
 262 1c9a 5CF804FB 	>>  ldr pc,[rp],#4
 263              	
 264              	2:
 265 1c9e FFF7B5FF 	  bl wliteral               @ compile a 16 bit literal (movw r0, #lit)
 266              	  exit
 266              	>  rpop pc
 266 1ca2 5CF804FB 	>>  ldr pc,[rp],#4
 267              	
 268              	@ ------------------------------------------------------------------------
 269              	@ switch into interpret mode
 270              	
 271              	  _imm_
 271              	>  .set lex,IMM
 272              	
 273              	code "[", lbracket
 273              	>  header "[",lbracket
 273              	>>  _header_ "[",lbracket
 273              	>>>  .section .data
 273 1034 28100000 	>>>  .int _thread
 273              	>>>  .set _thread,.
 273              	>>> 8:
 273              	>>>  hstring "["
 273 1038 81       	>>>>  .byte lex+9f-(.+1)
 273 1039 5B       	>>>>  .ascii "["
 273              	>>>> 9:
 273 103a 0000     	>>>>  .balign 4,0
 273              	>>>  .set lex,0
 273 103c AC1C0000 	>>>  .int lbracket
 273              	>>>  .previous
 273 1ca6 0000     	>>  .balign 4,0
 273 1ca8 38100000 	>>  .int _thread
 273              	> lbracket:
 274 1cac 0022     	  movs r2, #0               @ turn state off
 275              	0:
 276 1cae AFF22821 	  adr r1, state             @ point to state variable
 277 1cb2 8A60     	  str r2, [r1, #BODY]
 278              	  next
 278 1cb4 7047     	>  bx lr
 279              	
 280              	@ ------------------------------------------------------------------------
 281              	@ switch into compile mode
 282              	
 283              	code "]", rbracket
 283              	>  header "]",rbracket
 283              	>>  _header_ "]",rbracket
 283              	>>>  .section .data
 283 1040 38100000 	>>>  .int _thread
 283              	>>>  .set _thread,.
 283              	>>> 8:
 283              	>>>  hstring "]"
 283 1044 01       	>>>>  .byte lex+9f-(.+1)
 283 1045 5D       	>>>>  .ascii "]"
 283              	>>>> 9:
 283 1046 0000     	>>>>  .balign 4,0
 283              	>>>  .set lex,0
 283 1048 BC1C0000 	>>>  .int rbracket
 283              	>>>  .previous
 283 1cb6 0000     	>>  .balign 4,0
 283 1cb8 44100000 	>>  .int _thread
 283              	> rbracket:
 284 1cbc 6FF00002 	  mvn r2, #0                @ turn state on
 285 1cc0 F5E7     	  b 0b
 286              	
 287              	@ ------------------------------------------------------------------------
 288              	@ compile an rpush lr
 289              	
 290              	@     ( a1 --- a2 )
 291              	
 292              	rpushlr:                    @ this needs to be balign 4
 293 1cc2 4FF64C01 	  movw r1, #0xf84c          @ rpush lr
 294 1cc6 CEF60451 	  movt r1, #0xed04
 295 1cca 40F8041B 	  str r1, [r0], #4          @ first word of CFA = push return address
 296              	  next
 296 1cce 7047     	>  bx lr
 297              	
 298              	@ ------------------------------------------------------------------------
 299              	@ patch most recent words cfa to be a call word following ;uses
 300              	
 301              	colon ";uses", suses
 301              	>  header ";uses",suses
 301              	>>  _header_ ";uses",suses
 301              	>>>  .section .data
 301 104c 44100000 	>>>  .int _thread
 301              	>>>  .set _thread,.
 301              	>>> 8:
 301              	>>>  hstring ";uses"
 301 1050 05       	>>>>  .byte lex+9f-(.+1)
 301 1051 3B757365 	>>>>  .ascii ";uses"
 301      73
 301              	>>>> 9:
 301 1056 0000     	>>>>  .balign 4,0
 301              	>>>  .set lex,0
 301 1058 D41C0000 	>>>  .int suses
 301              	>>>  .previous
 301              	>>  .balign 4,0
 301 1cd0 50100000 	>>  .int _thread
 301              	> suses:
 301 1cd4 AFF30080 	>  nop.w
 301              	>  rpush lr
 301 1cd8 4CF804ED 	>>  str lr,[rp,#-4]!
 302 1cdc FFF748FF 	  bl pcompile               @ fetch address to "use"
 303              	1:
 304 1ce0 FFF7DAFE 	  bl last                   @ get nfa of word to be patched
 305 1ce4 00F0F0F9 	  bl nameto                 @ to cfa
 306 1ce8 FFF7EBFF 	  bl rpushlr                @ compile an rpush lr
 307 1cec FFF7F6FE 	  bl callstore              @ second word of CFA = call to handler
 308              	  exit
 308              	>  rpop pc
 308 1cf0 5CF804FB 	>>  ldr pc,[rp],#4
 309              	
 310              	@ ------------------------------------------------------------------------
 311              	@ patch most recent words cfa to be a call to asm directly after ;code
 312              	
 313              	@ this is an implied exit
 314              	
 315              	code ";code", scode
 315              	>  header ";code",scode
 315              	>>  _header_ ";code",scode
 315              	>>>  .section .data
 315 105c 50100000 	>>>  .int _thread
 315              	>>>  .set _thread,.
 315              	>>> 8:
 315              	>>>  hstring ";code"
 315 1060 05       	>>>>  .byte lex+9f-(.+1)
 315 1061 3B636F64 	>>>>  .ascii ";code"
 315      65
 315              	>>>> 9:
 315 1066 0000     	>>>>  .balign 4,0
 315              	>>>  .set lex,0
 315 1068 F81C0000 	>>>  .int scode
 315              	>>>  .previous
 315              	>>  .balign 4,0
 315 1cf4 60100000 	>>  .int _thread
 315              	> scode:
 316 1cf8 01B4     	  push { r0 }               @ get address of code to "use"
 317 1cfa 5FEA0E00 	  movs r0, lr
 318 1cfe 20F00100 	  bic r0, #1                @ de-thumbificate the address
 319 1d02 EDE7     	  b 1b                      @ patch most recent cfa to call this addres
 320              	
 321              	@ ------------------------------------------------------------------------
 322              	@ make most recently created word an immediate word
 323              	
 324              	colon "immediate", immediate
 324              	>  header "immediate",immediate
 324              	>>  _header_ "immediate",immediate
 324              	>>>  .section .data
 324 106c 60100000 	>>>  .int _thread
 324              	>>>  .set _thread,.
 324              	>>> 8:
 324              	>>>  hstring "immediate"
 324 1070 09       	>>>>  .byte lex+9f-(.+1)
 324 1071 696D6D65 	>>>>  .ascii "immediate"
 324      64696174 
 324      65
 324              	>>>> 9:
 324 107a 0000     	>>>>  .balign 4,0
 324              	>>>  .set lex,0
 324 107c 081D0000 	>>>  .int immediate
 324              	>>>  .previous
 324              	>>  .balign 4,0
 324 1d04 70100000 	>>  .int _thread
 324              	> immediate:
 324 1d08 AFF30080 	>  nop.w
 324              	>  rpush lr
 324 1d0c 4CF804ED 	>>  str lr,[rp,#-4]!
 325              	  cliteral IMM              @ seting bit 7 of the words NFA count byte
 325 1d10 01B4     	>  push { r0 }
 325 1d12 8020     	>  movs r0,#IMM
 326 1d14 FFF7C0FE 	  bl last                   @ makes the word immediate
 327 1d18 FEF712FE 	  bl cset
 328              	  exit
 328              	>  rpop pc
 328 1d1c 5CF804FB 	>>  ldr pc,[rp],#4
 329              	
 330              	@ ------------------------------------------------------------------------
 331              	@ create a new word.  this is always assumed to be a variable
 332              	
 333              	colon "create", create
 333              	>  header "create",create
 333              	>>  _header_ "create",create
 333              	>>>  .section .data
 333 1080 70100000 	>>>  .int _thread
 333              	>>>  .set _thread,.
 333              	>>> 8:
 333              	>>>  hstring "create"
 333 1084 06       	>>>>  .byte lex+9f-(.+1)
 333 1085 63726561 	>>>>  .ascii "create"
 333      7465
 333              	>>>> 9:
 333 108b 00       	>>>>  .balign 4,0
 333              	>>>  .set lex,0
 333 108c 241D0000 	>>>  .int create
 333              	>>>  .previous
 333              	>>  .balign 4,0
 333 1d20 84100000 	>>  .int _thread
 333              	> create:
 333 1d24 AFF30080 	>  nop.w
 333              	>  rpush lr
 333 1d28 4CF804ED 	>>  str lr,[rp,#-4]!
 334 1d2c 00F022FA 	  bl headcomma              @ create a new word header
 335              	
 336              	  cliteral BODY             @ allocate cfa
 336 1d30 01B4     	>  push { r0 }
 336 1d32 0820     	>  movs r0,#BODY
 337 1d34 00F05AF9 	  bl allot
 338 1d38 FFF7CCFF 	  bl suses                  @ compile dovariable into cfa of created word
 339 1d3c FEF726FB 	  bl dovariable
 340 1d40 00F026FA 	  bl reveal                 @ reveal newly created word to the world
 341              	  exit
 341              	>  rpop pc
 341 1d44 5CF804FB 	>>  ldr pc,[rp],#4
 342              	
 343              	@ ------------------------------------------------------------------------
 344              	@ create a new high level (colon) definition
 345              	
 346              	colon ":", colon
 346              	>  header ":",colon
 346              	>>  _header_ ":",colon
 346              	>>>  .section .data
 346 1090 84100000 	>>>  .int _thread
 346              	>>>  .set _thread,.
 346              	>>> 8:
 346              	>>>  hstring ":"
 346 1094 01       	>>>>  .byte lex+9f-(.+1)
 346 1095 3A       	>>>>  .ascii ":"
 346              	>>>> 9:
 346 1096 0000     	>>>>  .balign 4,0
 346              	>>>  .set lex,0
 346 1098 4C1D0000 	>>>  .int colon
 346              	>>>  .previous
 346              	>>  .balign 4,0
 346 1d48 94100000 	>>  .int _thread
 346              	> colon:
 346 1d4c AFF30080 	>  nop.w
 346              	>  rpush lr
 346 1d50 4CF804ED 	>>  str lr,[rp,#-4]!
 347 1d54 00F00EFA 	  bl headcomma              @ create a header for the : def
 348 1d58 00F072F9 	  bl litc                   @ compile its cfa (two opcodes)
 349 1d5c AFF30080 	  nop.w                     @ first opcode is a nop for colon definitions
 350 1d60 00F06EF9 	  bl litc
 351              	  rpush lr                  @ second opcode is a push lr
 351 1d64 4CF804ED 	>  str lr,[rp,#-4]!
 352 1d68 FFF7A8FF 	  bl rbracket               @ sewitch into compile mode
 353              	  exit
 353              	>  rpop pc
 353 1d6c 5CF804FB 	>>  ldr pc,[rp],#4
 354              	
 355              	@ ------------------------------------------------------------------------
 356              	@ complete a high level definition
 357              	
 358              	  _imm_
 358              	>  .set lex,IMM
 359              	
 360              	colon ";" semi
 360              	>  header ";",semi
 360              	>>  _header_ ";",semi
 360              	>>>  .section .data
 360 109c 94100000 	>>>  .int _thread
 360              	>>>  .set _thread,.
 360              	>>> 8:
 360              	>>>  hstring ";"
 360 10a0 81       	>>>>  .byte lex+9f-(.+1)
 360 10a1 3B       	>>>>  .ascii ";"
 360              	>>>> 9:
 360 10a2 0000     	>>>>  .balign 4,0
 360              	>>>  .set lex,0
 360 10a4 741D0000 	>>>  .int semi
 360              	>>>  .previous
 360              	>>  .balign 4,0
 360 1d70 A0100000 	>>  .int _thread
 360              	> semi:
 360 1d74 AFF30080 	>  nop.w
 360              	>  rpush lr
 360 1d78 4CF804ED 	>>  str lr,[rp,#-4]!
 361 1d7c 00F060F9 	  bl litc                   @ compile an exit opcode onto end of : def
 362              	  exit
 362              	>  rpop pc
 362 1d80 5CF804FB 	>>  ldr pc,[rp],#4
 363 1d84 FFF792FF 	  bl lbracket               @ switch out of compile mode
 364 1d88 00F002FA 	  bl reveal                 @ reveal it to the word and clear the
 365              	  exit                      @ instruction cache so it can be executed
 365              	>  rpop pc
 365 1d8c 5CF804FB 	>>  ldr pc,[rp],#4
 366              	
 367              	@ ========================================================================
 368              	
 325              	  .include "loops.s"        @ branching and looping
   1              	@ loops.s
   2              	@ ------------------------------------------------------------------------
   3              	
   4              	@ ------------------------------------------------------------------------
   5              	
   6              	@     ( n1 --- )
   7              	
   8              	code "docase", docase
   8              	>  header "docase",docase
   8              	>>  _header_ "docase",docase
   8              	>>>  .section .data
   8 10a8 A0100000 	>>>  .int _thread
   8              	>>>  .set _thread,.
   8              	>>> 8:
   8              	>>>  hstring "docase"
   8 10ac 06       	>>>>  .byte lex+9f-(.+1)
   8 10ad 646F6361 	>>>>  .ascii "docase"
   8      7365
   8              	>>>> 9:
   8 10b3 00       	>>>>  .balign 4,0
   8              	>>>  .set lex,0
   8 10b4 941D0000 	>>>  .int docase
   8              	>>>  .previous
   8              	>>  .balign 4,0
   8 1d90 AC100000 	>>  .int _thread
   8              	> docase:
   9 1d94 2EF0010E 	  bic lr, #1
  10              	
  11 1d98 0EF1030E 	  add lr, lr, #3            @ following items are cell alligned for
  12 1d9c 2EF0030E 	  bic lr, lr, #3            @  ease of fetching them
  13              	
  14 1da0 5EF8047B 	  ldr r7, [lr], #4          @ case exit point
  15 1da4 5EF8046B 	  ldr r6, [lr], #4          @ default vector
  16 1da8 5EF8045B 	  ldr r5, [lr], #4          @ case count
  17              	
  18              	0:
  19 1dac 5EF8041B 	  ldr r1, [lr], #4          @ get case option
  20 1db0 8842     	  cmp r0, r1                @ same as n1?
  21 1db2 12BF     	  itee ne
  22 1db4 5EF8041B 	  ldrne r1, [lr], #4
  23 1db8 5EF8046B 	  ldreq r6, [lr], #4
  24 1dbc 02E0     	  beq 1f
  25 1dbe 013D     	  subs r5, r5, #1
  26 1dc0 F4D1     	  bne 0b
  27              	
  28              	  @ n1 is not an option, take default if there is one
  29              	
  30 1dc2 26B1     	  cbz r6, 2f                @ do we have a default vector?
  31              	1:
  32 1dc4 01BC     	  pop { r0 }
  33 1dc6 07F1010E 	  add lr, r7, #1            @ set lr = case exit point
  34 1dca 0136     	  adds r6, r6, #1
  35 1dcc 3047     	  bx r6
  36              	
  37              	2:
  38 1dce 01BC     	  pop { r0 }                @ branch to case exit point
  39 1dd0 3847     	  bx r7
  40              	
  41              	@ ------------------------------------------------------------------------
  42              	@ get target address from bl opcode
  43              	
  44              	@       65              4  32               register
  45              	@ .... .SII IIII IIII ..J. Jiii iiii iiii   opcode
  46              	@ .... .... SJJI IIII IIII Iiii iiii iiii   address / 2
  47              	
  48              	@ r0 = bl opcode on entry
  49              	@ r1 = address of bl opcode
  50              	
  51              	@ r2 = offset to bl target on exit
  52              	
  53              	@ does not alter r0 or r1
  54              	
  55              	code "<bl", from_bl
  55              	>  header "<bl",from_bl
  55              	>>  _header_ "<bl",from_bl
  55              	>>>  .section .data
  55 10b8 AC100000 	>>>  .int _thread
  55              	>>>  .set _thread,.
  55              	>>> 8:
  55              	>>>  hstring "<bl"
  55 10bc 03       	>>>>  .byte lex+9f-(.+1)
  55 10bd 3C626C   	>>>>  .ascii "<bl"
  55              	>>>> 9:
  55              	>>>>  .balign 4,0
  55              	>>>  .set lex,0
  55 10c0 D81D0000 	>>>  .int from_bl
  55              	>>>  .previous
  55 1dd2 0000     	>>  .balign 4,0
  55 1dd4 BC100000 	>>  .int _thread
  55              	> from_bl:
  56 1dd8 0246     	  mov r2, r0                @ R2 = I11
  57              	
  58 1dda C0F3C023 	  ubfx r3, r0, #11, #1      @ R3 = J2
  59 1dde C0F34034 	  ubfx r4, r0, #13, #1      @ R4 = J1
  60 1de2 C0F30945 	  ubfx r5, r0, #16, #10     @ R5 = I10
  61 1de6 C0F38066 	  ubfx r6, r0, #26, #1      @ R6 = S
  62              	
  63 1dea 7340     	  eors r3, r3, r6           @ J2 = !(J2 ^ S)
  64 1dec 7440     	  eors r4, r4, r6           @ J1 = !(J1 ^ S)
  65 1dee DB43     	  mvns r3, r3
  66 1df0 E443     	  mvns r4, r4
  67              	
  68 1df2 65F3D422 	  bfi r2, r5, #11, #10      @ add I10 to result
  69 1df6 63F35552 	  bfi r2, r3, #21, #1       @ add J2  to result
  70 1dfa 64F39652 	  bfi r2, r4, #22, #1       @ add J1  to result
  71 1dfe 66F3D752 	  bfi r2, r6, #23, #1
  72              	
  73 1e02 1202     	  lsls r2, #8               @ propogate sign bit and
  74 1e04 D211     	  asrs r2, #7               @ multiply result by 2
  75              	
  76              	  @ return offset from bl opcode to its target address
  77              	
  78 1e06 7047     	  bx lr
  79              	
  80              	@ ------------------------------------------------------------------------
  81              	@ execute one or other of next two xts
  82              	
  83              	@     ( n1 --- )
  84              	
  85              	code "?:", qcolon
  85              	>  header "?:",qcolon
  85              	>>  _header_ "?:",qcolon
  85              	>>>  .section .data
  85 10c4 BC100000 	>>>  .int _thread
  85              	>>>  .set _thread,.
  85              	>>> 8:
  85              	>>>  hstring "?:"
  85 10c8 02       	>>>>  .byte lex+9f-(.+1)
  85 10c9 3F3A     	>>>>  .ascii "?:"
  85              	>>>> 9:
  85 10cb 00       	>>>>  .balign 4,0
  85              	>>>  .set lex,0
  85 10cc 0C1E0000 	>>>  .int qcolon
  85              	>>>  .previous
  85              	>>  .balign 4,0
  85 1e08 C8100000 	>>  .int _thread
  85              	> qcolon:
  86 1e0c 7146     	  mov r1, lr                @ advance return address past true/false
  87 1e0e 0EF1080E 	  add lr, lr, #8            @ vectors, point r1 at true vector
  88 1e12 21F00101 	  bic r1, #1
  89 1e16 0028     	  cmp r0, #0                @ is n1 false?
  90              	
  91 1e18 08BF     	  it eq
  92 1e1a 0431     	  addeq r1, r1, #4          @ if so, point r0 at false vector
  93              	
  94 1e1c 0A88     	  ldrh r2, [r1]             @ get xt to execute (actually a bl to it)
  95 1e1e 4B88     	  ldrh r3, [r1, #2]
  96 1e20 03EB0240 	  add r0, r3, r2, lsl #16   @ r0 = full 32 bit bl opcode
  97              	
  98 1e24 00B5     	  push { lr }
  99 1e26 FFF7D7FF 	  bl from_bl                @ extract address
 100 1e2a 5DF804EB 	  pop { lr }
 101              	
 102 1e2e 0A44     	  add r2, r2, r1
 103 1e30 0532     	  adds r2, r2, #5           @ 4 for pipe, 1 for thumb
 104              	
 105 1e32 01BC     	  pop { r0 }
 106 1e34 1047     	  bx r2
 107              	
 108              	@ ------------------------------------------------------------------------
 109              	@ executte n1th xt after exec:. this is an implied exit
 110              	
 111              	@ like ?: this word is somewhat inefficient in thumb2 due to the ammount
 112              	@ of work it has to do just to calculate the target address of the bl
 113              	@ opcode selected
 114              	
 115              	@     ( n1 --- )
 116              	
 117              	code "exec:", execc
 117              	>  header "exec:",execc
 117              	>>  _header_ "exec:",execc
 117              	>>>  .section .data
 117 10d0 C8100000 	>>>  .int _thread
 117              	>>>  .set _thread,.
 117              	>>> 8:
 117              	>>>  hstring "exec:"
 117 10d4 05       	>>>>  .byte lex+9f-(.+1)
 117 10d5 65786563 	>>>>  .ascii "exec:"
 117      3A
 117              	>>>> 9:
 117 10da 0000     	>>>>  .balign 4,0
 117              	>>>  .set lex,0
 117 10dc 3C1E0000 	>>>  .int execc
 117              	>>>  .previous
 117 1e36 0000     	>>  .balign 4,0
 117 1e38 D4100000 	>>  .int _thread
 117              	> execc:
 118 1e3c 2EF0010E 	  bic lr, #1
 119 1e40 0EEB8000 	  add r0, lr, r0, lsl #2    @ point r1 at xt to execute
 120 1e44 FFF782FE 	  bl xtfetch                @ get target address of chosen xt
 121              	  rpop lr                   @ exec: is an implied unnest
 121 1e48 5CF804EB 	>  ldr lr,[rp],#4
 122 1e4c 0100     	  movs r1, r0
 123 1e4e 01BC     	  pop { r0 }
 124 1e50 0847     	  bx r1
 125              	
 126              	@ ------------------------------------------------------------------------
 127              	
 128              	code "branch", branch
 128              	>  header "branch",branch
 128              	>>  _header_ "branch",branch
 128              	>>>  .section .data
 128 10e0 D4100000 	>>>  .int _thread
 128              	>>>  .set _thread,.
 128              	>>> 8:
 128              	>>>  hstring "branch"
 128 10e4 06       	>>>>  .byte lex+9f-(.+1)
 128 10e5 6272616E 	>>>>  .ascii "branch"
 128      6368
 128              	>>>> 9:
 128 10eb 00       	>>>>  .balign 4,0
 128              	>>>  .set lex,0
 128 10ec 581E0000 	>>>  .int branch
 128              	>>>  .previous
 128 1e52 0000     	>>  .balign 4,0
 128 1e54 E4100000 	>>  .int _thread
 128              	> branch:
 129 1e58 2EF0010E 	  bic lr, #1                @ clear odd bit from lr
 130 1e5c BEF80010 	  ldrh r1, [lr]             @ lr points to branch vector
 131 1e60 0EFA81FE 	  sxtah lr, lr, r1
 132              	  next
 132 1e64 7047     	>  bx lr
 133              	
 134              	@ ------------------------------------------------------------------------
 135              	
 136              	code "?branch", qbranch
 136              	>  header "?branch",qbranch
 136              	>>  _header_ "?branch",qbranch
 136              	>>>  .section .data
 136 10f0 E4100000 	>>>  .int _thread
 136              	>>>  .set _thread,.
 136              	>>> 8:
 136              	>>>  hstring "?branch"
 136 10f4 07       	>>>>  .byte lex+9f-(.+1)
 136 10f5 3F627261 	>>>>  .ascii "?branch"
 136      6E6368
 136              	>>>> 9:
 136              	>>>>  .balign 4,0
 136              	>>>  .set lex,0
 136 10fc 6C1E0000 	>>>  .int qbranch
 136              	>>>  .previous
 136 1e66 0000     	>>  .balign 4,0
 136 1e68 F4100000 	>>  .int _thread
 136              	> qbranch:
 137 1e6c 0028     	  cmp r0, #0
 138 1e6e 01BC     	  pop { r0 }
 139 1e70 F2D0     	  beq branch
 140 1e72 0EF1020E 	  add lr, lr, #2
 141              	  next
 141 1e76 7047     	>  bx lr
 142              	
 143              	@ ------------------------------------------------------------------------
 144              	
 145              	code "undo", undo
 145              	>  header "undo",undo
 145              	>>  _header_ "undo",undo
 145              	>>>  .section .data
 145 1100 F4100000 	>>>  .int _thread
 145              	>>>  .set _thread,.
 145              	>>> 8:
 145              	>>>  hstring "undo"
 145 1104 04       	>>>>  .byte lex+9f-(.+1)
 145 1105 756E646F 	>>>>  .ascii "undo"
 145              	>>>> 9:
 145 1109 000000   	>>>>  .balign 4,0
 145              	>>>  .set lex,0
 145 110c 7C1E0000 	>>>  .int undo
 145              	>>>  .previous
 145              	>>  .balign 4,0
 145 1e78 04110000 	>>  .int _thread
 145              	> undo:
 146 1e7c 0CF10C0C 	  add rp, rp, #12
 147              	  next
 147 1e80 7047     	>  bx lr
 148              	
 149              	@ ------------------------------------------------------------------------
 150              	
 151              	code "(leave)", pleave
 151              	>  header "(leave)",pleave
 151              	>>  _header_ "(leave)",pleave
 151              	>>>  .section .data
 151 1110 04110000 	>>>  .int _thread
 151              	>>>  .set _thread,.
 151              	>>> 8:
 151              	>>>  hstring "(leave)"
 151 1114 07       	>>>>  .byte lex+9f-(.+1)
 151 1115 286C6561 	>>>>  .ascii "(leave)"
 151      766529
 151              	>>>> 9:
 151              	>>>>  .balign 4,0
 151              	>>>  .set lex,0
 151 111c 881E0000 	>>>  .int pleave
 151              	>>>  .previous
 151 1e82 0000     	>>  .balign 4,0
 151 1e84 14110000 	>>  .int _thread
 151              	> pleave:
 152 1e88 0CF1080C 	  add rp, rp, #8
 153              	  exit
 153              	>  rpop pc
 153 1e8c 5CF804FB 	>>  ldr pc,[rp],#4
 154              	
 155              	@ -----------------------------------------------------------------------
 156              	
 157              	code "(?leave)", pqleave
 157              	>  header "(?leave)",pqleave
 157              	>>  _header_ "(?leave)",pqleave
 157              	>>>  .section .data
 157 1120 14110000 	>>>  .int _thread
 157              	>>>  .set _thread,.
 157              	>>> 8:
 157              	>>>  hstring "(?leave)"
 157 1124 08       	>>>>  .byte lex+9f-(.+1)
 157 1125 283F6C65 	>>>>  .ascii "(?leave)"
 157      61766529 
 157              	>>>> 9:
 157 112d 000000   	>>>>  .balign 4,0
 157              	>>>  .set lex,0
 157 1130 941E0000 	>>>  .int pqleave
 157              	>>>  .previous
 157              	>>  .balign 4,0
 157 1e90 24110000 	>>  .int _thread
 157              	> pqleave:
 158 1e94 0028     	  cmp r0, #0
 159 1e96 01BC     	  pop { r0 }
 160 1e98 1CBF     	  itt ne
 161 1e9a 0CF1080C 	  addne rp, rp, #8
 162 1e9e 5CF804FB 	  ldmfdne rp!, { pc }
 163              	  next
 163 1ea2 7047     	>  bx lr
 164              	
 165              	@ ------------------------------------------------------------------------
 166              	
 167              	code "(loop)", ploop
 167              	>  header "(loop)",ploop
 167              	>>  _header_ "(loop)",ploop
 167              	>>>  .section .data
 167 1134 24110000 	>>>  .int _thread
 167              	>>>  .set _thread,.
 167              	>>> 8:
 167              	>>>  hstring "(loop)"
 167 1138 06       	>>>>  .byte lex+9f-(.+1)
 167 1139 286C6F6F 	>>>>  .ascii "(loop)"
 167      7029
 167              	>>>> 9:
 167 113f 00       	>>>>  .balign 4,0
 167              	>>>  .set lex,0
 167 1140 A81E0000 	>>>  .int ploop
 167              	>>>  .previous
 167              	>>  .balign 4,0
 167 1ea4 38110000 	>>  .int _thread
 167              	> ploop:
 168 1ea8 DCF80010 	  ldr r1, [rp]              @ increment loop index
 169 1eac 0131     	  adds r1, r1, #1
 170 1eae 10D6     	  bvs 2f                    @ exit loop on overflow
 171              	1:
 172 1eb0 CCF80010 	  str r1, [rp]              @ else store back new loop index
 173 1eb4 2EF0010E 	  bic lr, #1                @ and branch back to start of loop
 174 1eb8 BEF80010 	  ldrh r1, [lr]             @ lr points to branch vector
 175 1ebc 0EFA81FE 	  sxtah lr, lr, r1
 176              	  next
 176 1ec0 7047     	>  bx lr
 177              	
 178              	@ ------------------------------------------------------------------------
 179              	
 180              	@     ( n1 --- )
 181              	
 182              	code "(+loop)", pploop
 182              	>  header "(+loop)",pploop
 182              	>>  _header_ "(+loop)",pploop
 182              	>>>  .section .data
 182 1144 38110000 	>>>  .int _thread
 182              	>>>  .set _thread,.
 182              	>>> 8:
 182              	>>>  hstring "(+loop)"
 182 1148 07       	>>>>  .byte lex+9f-(.+1)
 182 1149 282B6C6F 	>>>>  .ascii "(+loop)"
 182      6F7029
 182              	>>>> 9:
 182              	>>>>  .balign 4,0
 182              	>>>  .set lex,0
 182 1150 C81E0000 	>>>  .int pploop
 182              	>>>  .previous
 182 1ec2 0000     	>>  .balign 4,0
 182 1ec4 48110000 	>>  .int _thread
 182              	> pploop:
 183 1ec8 DCF80010 	  ldr r1, [rp]              @ add n1 to loop index
 184 1ecc 0918     	  adds r1, r1, r0
 185 1ece 01BC     	  pop { r0 }                @ pop new top of stack
 186 1ed0 EED7     	  bvc 1b                    @ branch back to start of loop if no overflow
 187              	2:
 188 1ed2 0CF1080C 	  add rp, rp, #8            @ else clean loop parameters off stack
 189              	  exit                      @ and branch to loop exit point
 189              	>  rpop pc
 189 1ed6 5CF804FB 	>>  ldr pc,[rp],#4
 190              	
 191              	@ ------------------------------------------------------------------------
 192              	
 193              	code "(do)", pdo
 193              	>  header "(do)",pdo
 193              	>>  _header_ "(do)",pdo
 193              	>>>  .section .data
 193 1154 48110000 	>>>  .int _thread
 193              	>>>  .set _thread,.
 193              	>>> 8:
 193              	>>>  hstring "(do)"
 193 1158 04       	>>>>  .byte lex+9f-(.+1)
 193 1159 28646F29 	>>>>  .ascii "(do)"
 193              	>>>> 9:
 193 115d 000000   	>>>>  .balign 4,0
 193              	>>>  .set lex,0
 193 1160 E01E0000 	>>>  .int pdo
 193              	>>>  .previous
 193 1eda 0000     	>>  .balign 4,0
 193 1edc 58110000 	>>  .int _thread
 193              	> pdo:
 194 1ee0 02BC     	  pop { r1 }                @ r0 = start index, r1 = end index
 195              	_do:
 196 1ee2 2EF0010E 	  bic lr, #1
 197 1ee6 BEF80020 	  ldrh r2, [lr]             @ fetch compiled in loop exit point
 198 1eea 12B2     	  sxth r2, r2               @ sign extend 16 bit relative branch vector
 199 1eec 7244     	  add r2, r2, lr
 200 1eee 0EF1030E 	  add lr, lr, #3
 201              	  rpush r2                  @ push it to the return stack
 201 1ef2 4CF8042D 	>  str r2,[rp,#-4]!
 202 1ef6 01F10041 	  add r1, r1, #0x80000000   @ fudge loop indicies
 203 1efa 401A     	  subs r0, r0, r1
 204              	  rpush r1
 204 1efc 4CF8041D 	>  str r1,[rp,#-4]!
 205              	  rpush r0
 205 1f00 4CF8040D 	>  str r0,[rp,#-4]!
 206 1f04 01BC     	  pop { r0 }
 207              	  next
 207 1f06 7047     	>  bx lr
 208              	
 209              	@ ------------------------------------------------------------------------
 210              	
 211              	@     ( n1 n2 --- )
 212              	
 213              	code "(?do)", pqdo
 213              	>  header "(?do)",pqdo
 213              	>>  _header_ "(?do)",pqdo
 213              	>>>  .section .data
 213 1164 58110000 	>>>  .int _thread
 213              	>>>  .set _thread,.
 213              	>>> 8:
 213              	>>>  hstring "(?do)"
 213 1168 05       	>>>>  .byte lex+9f-(.+1)
 213 1169 283F646F 	>>>>  .ascii "(?do)"
 213      29
 213              	>>>> 9:
 213 116e 0000     	>>>>  .balign 4,0
 213              	>>>  .set lex,0
 213 1170 0C1F0000 	>>>  .int pqdo
 213              	>>>  .previous
 213              	>>  .balign 4,0
 213 1f08 68110000 	>>  .int _thread
 213              	> pqdo:
 214 1f0c 02BC     	  pop { r1 }
 215 1f0e 8842     	  cmp r0, r1
 216 1f10 E7D1     	  bne _do
 217 1f12 01BC     	  pop { r0 }
 218              	
 219 1f14 2EF0010E 	  bic lr, #1
 220 1f18 BEF80010 	  ldrh r1, [lr]             @ lr points to branch vector
 221 1f1c 0EFA81FE 	  sxtah lr, lr, r1
 222              	  next
 222 1f20 7047     	>  bx lr
 223              	
 224              	@ ------------------------------------------------------------------------
 225              	
 226              	code "i", i
 226              	>  header "i",i
 226              	>>  _header_ "i",i
 226              	>>>  .section .data
 226 1174 68110000 	>>>  .int _thread
 226              	>>>  .set _thread,.
 226              	>>> 8:
 226              	>>>  hstring "i"
 226 1178 01       	>>>>  .byte lex+9f-(.+1)
 226 1179 69       	>>>>  .ascii "i"
 226              	>>>> 9:
 226 117a 0000     	>>>>  .balign 4,0
 226              	>>>  .set lex,0
 226 117c 281F0000 	>>>  .int i
 226              	>>>  .previous
 226 1f22 0000     	>>  .balign 4,0
 226 1f24 78110000 	>>  .int _thread
 226              	> i:
 227 1f28 0022     	  movs r2, #0
 228              	ijk:
 229 1f2a 01B4     	  push { r0 }
 230 1f2c 6244     	  add r2, rp
 231 1f2e 52F8040B 	  ldr r0, [r2], #4
 232 1f32 1268     	  ldr r2, [r2]
 233 1f34 1044     	  add r0, r2
 234              	  next
 234 1f36 7047     	>  bx lr
 235              	
 236              	@ ------------------------------------------------------------------------
 237              	
 238              	code "j", j
 238              	>  header "j",j
 238              	>>  _header_ "j",j
 238              	>>>  .section .data
 238 1180 78110000 	>>>  .int _thread
 238              	>>>  .set _thread,.
 238              	>>> 8:
 238              	>>>  hstring "j"
 238 1184 01       	>>>>  .byte lex+9f-(.+1)
 238 1185 6A       	>>>>  .ascii "j"
 238              	>>>> 9:
 238 1186 0000     	>>>>  .balign 4,0
 238              	>>>  .set lex,0
 238 1188 3C1F0000 	>>>  .int j
 238              	>>>  .previous
 238              	>>  .balign 4,0
 238 1f38 84110000 	>>  .int _thread
 238              	> j:
 239 1f3c 0C22     	  movs r2, #12
 240 1f3e F4E7     	  b ijk
 241              	
 242              	@ ------------------------------------------------------------------------
 243              	
 244              	code "k", k
 244              	>  header "k",k
 244              	>>  _header_ "k",k
 244              	>>>  .section .data
 244 118c 84110000 	>>>  .int _thread
 244              	>>>  .set _thread,.
 244              	>>> 8:
 244              	>>>  hstring "k"
 244 1190 01       	>>>>  .byte lex+9f-(.+1)
 244 1191 6B       	>>>>  .ascii "k"
 244              	>>>> 9:
 244 1192 0000     	>>>>  .balign 4,0
 244              	>>>  .set lex,0
 244 1194 441F0000 	>>>  .int k
 244              	>>>  .previous
 244              	>>  .balign 4,0
 244 1f40 90110000 	>>  .int _thread
 244              	> k:
 245 1f44 1822     	  movs r2, #24
 246 1f46 F0E7     	  b ijk
 247              	
 248              	@ ------------------------------------------------------------------------
 249              	
 250              	@     ( n1 --- )
 251              	
 252              	code "dofor", dofor
 252              	>  header "dofor",dofor
 252              	>>  _header_ "dofor",dofor
 252              	>>>  .section .data
 252 1198 90110000 	>>>  .int _thread
 252              	>>>  .set _thread,.
 252              	>>> 8:
 252              	>>>  hstring "dofor"
 252 119c 05       	>>>>  .byte lex+9f-(.+1)
 252 119d 646F666F 	>>>>  .ascii "dofor"
 252      72
 252              	>>>> 9:
 252 11a2 0000     	>>>>  .balign 4,0
 252              	>>>  .set lex,0
 252 11a4 4C1F0000 	>>>  .int dofor
 252              	>>>  .previous
 252              	>>  .balign 4,0
 252 1f48 9C110000 	>>  .int _thread
 252              	> dofor:
 253 1f4c 0138     	  subs r0, r0, #1           @ zero base n1
 254 1f4e 01D5     	  bpl 0f
 255 1f50 01BC     	  pop { r0 }                @ if n1 went negative branch to end of loop
 256 1f52 81E7     	  b branch
 257              	0:
 258              	  rpush r0                  @ else put loop count on r stack
 258 1f54 4CF8040D 	>  str r0,[rp,#-4]!
 259 1f58 01BC     	  pop { r0 }
 260              	  next
 260 1f5a 7047     	>  bx lr
 261              	
 262              	@ ------------------------------------------------------------------------
 263              	
 264              	code "(nxt)", pnxt
 264              	>  header "(nxt)",pnxt
 264              	>>  _header_ "(nxt)",pnxt
 264              	>>>  .section .data
 264 11a8 9C110000 	>>>  .int _thread
 264              	>>>  .set _thread,.
 264              	>>> 8:
 264              	>>>  hstring "(nxt)"
 264 11ac 05       	>>>>  .byte lex+9f-(.+1)
 264 11ad 286E7874 	>>>>  .ascii "(nxt)"
 264      29
 264              	>>>> 9:
 264 11b2 0000     	>>>>  .balign 4,0
 264              	>>>  .set lex,0
 264 11b4 601F0000 	>>>  .int pnxt
 264              	>>>  .previous
 264              	>>  .balign 4,0
 264 1f5c AC110000 	>>  .int _thread
 264              	> pnxt:
 265 1f60 DCF80010 	  ldr r1, [rp]              @ get loop count
 266 1f64 0139     	  subs r1, r1, #1           @ decrement it
 267 1f66 02D4     	  bmi 1f                    @ if it did not go negative
 268 1f68 CCF80010 	  str r1, [rp]              @ store it back
 269 1f6c 74E7     	  b branch
 270              	1:
 271 1f6e 0CF1040C 	  add rp, rp, #4            @ loops completed. discard loop count
 272 1f72 0EF1020E 	  add lr, lr, #2            @ advance lr past branch vector
 273              	  next
 273 1f76 7047     	>  bx lr
 274              	
 275              	@ ------------------------------------------------------------------------
 276              	@ execute a repeat statement (repeats code at specified cfa n1 times)
 277              	
 278              	@     ( ... n1 cfa --- )
 279              	
 280              	colon "(rep)", prep
 280              	>  header "(rep)",prep
 280              	>>  _header_ "(rep)",prep
 280              	>>>  .section .data
 280 11b8 AC110000 	>>>  .int _thread
 280              	>>>  .set _thread,.
 280              	>>> 8:
 280              	>>>  hstring "(rep)"
 280 11bc 05       	>>>>  .byte lex+9f-(.+1)
 280 11bd 28726570 	>>>>  .ascii "(rep)"
 280      29
 280              	>>>> 9:
 280 11c2 0000     	>>>>  .balign 4,0
 280              	>>>  .set lex,0
 280 11c4 7C1F0000 	>>>  .int prep
 280              	>>>  .previous
 280              	>>  .balign 4,0
 280 1f78 BC110000 	>>  .int _thread
 280              	> prep:
 280 1f7c AFF30080 	>  nop.w
 280              	>  rpush lr
 280 1f80 4CF804ED 	>>  str lr,[rp,#-4]!
 281 1f84 FEF7D0FA 	  bl swap                   @ ( ... cfa n1 --- ) get repeat count n1
 282 1f88 FFF7E0FF 	  bl dofor                  @ for n1 itterations do...
 283 1f8c 1500     	  .hword (2f - .) + 1       @ exit vector if n1 is zero
 284              	1:
 285 1f8e FEF72FFB 	  bl duptor                 @ keep copy of cfa to be repeatedly called
 286 1f92 FEF7E1F9 	  bl execute                @ call specified cfa
 287 1f96 FEF71DFB 	  bl rto                    @ get copy of cfa back
 288 1f9a FFF7E1FF 	  bl pnxt                   @ repeat till n1 goes negative
 289 1f9e F1FF     	  .hword (1b - .) + 1
 290              	2:
 291 1fa0 FEF7D0FA 	  bl drop                   @ discard cfa, were done with it now
 292              	  exit
 292              	>  rpop pc
 292 1fa4 5CF804FB 	>>  ldr pc,[rp],#4
 293              	
 294              	@ ------------------------------------------------------------------------
 295              	@ execute a compiled rep statement
 296              	
 297              	@      ( n1 --- )
 298              	
 299              	colon "dorep", dorep
 299              	>  header "dorep",dorep
 299              	>>  _header_ "dorep",dorep
 299              	>>>  .section .data
 299 11c8 BC110000 	>>>  .int _thread
 299              	>>>  .set _thread,.
 299              	>>> 8:
 299              	>>>  hstring "dorep"
 299 11cc 05       	>>>>  .byte lex+9f-(.+1)
 299 11cd 646F7265 	>>>>  .ascii "dorep"
 299      70
 299              	>>>> 9:
 299 11d2 0000     	>>>>  .balign 4,0
 299              	>>>  .set lex,0
 299 11d4 AC1F0000 	>>>  .int dorep
 299              	>>>  .previous
 299              	>>  .balign 4,0
 299 1fa8 CC110000 	>>  .int _thread
 299              	> dorep:
 299 1fac AFF30080 	>  nop.w
 299              	>  rpush lr
 299 1fb0 4CF804ED 	>>  str lr,[rp,#-4]!
 300 1fb4 FFF7DCFD 	  bl pcompile               @ disassemble xt of word to repeat
 301 1fb8 20F00100 	  bic r0, #1                @ dethumbificate the address
 302 1fbc FFF7DEFF 	  bl prep                   @ execute this word n1 times
 303              	  exit
 303              	>  rpop pc
 303 1fc0 5CF804FB 	>>  ldr pc,[rp],#4
 304              	
 305              	@ ------------------------------------------------------------------------
 306              	@ convert address and length to start and end addresses
 307              	
 308              	@    ( a1 n1 --- a1 a2 )
 309              	
 310              	code "bounds", bounds
 310              	>  header "bounds",bounds
 310              	>>  _header_ "bounds",bounds
 310              	>>>  .section .data
 310 11d8 CC110000 	>>>  .int _thread
 310              	>>>  .set _thread,.
 310              	>>> 8:
 310              	>>>  hstring "bounds"
 310 11dc 06       	>>>>  .byte lex+9f-(.+1)
 310 11dd 626F756E 	>>>>  .ascii "bounds"
 310      6473
 310              	>>>> 9:
 310 11e3 00       	>>>>  .balign 4,0
 310              	>>>  .set lex,0
 310 11e4 C81F0000 	>>>  .int bounds
 310              	>>>  .previous
 310              	>>  .balign 4,0
 310 1fc4 DC110000 	>>  .int _thread
 310              	> bounds:
 311 1fc8 02BC     	  pop { r1 }
 312 1fca 0844     	  add r0, r0, r1
 313 1fcc 01B4     	  push { r0 }
 314 1fce 0846     	  mov r0, r1
 315              	  next
 315 1fd0 7047     	>  bx lr
 316              	
 317              	@ ========================================================================
 326              	  .include "comma.s"        @ comma is the actual compiler
   1              	@ comma.s
   2              	@ ------------------------------------------------------------------------
   3              	
   4              	@ ------------------------------------------------------------------------
   5              	@ align dictionary pointer (possibly after compilation of a string)
   6              	
   7              	code "align,", alignc
   7              	>  header "align,",alignc
   7              	>>  _header_ "align,",alignc
   7              	>>>  .section .data
   7 11e8 DC110000 	>>>  .int _thread
   7              	>>>  .set _thread,.
   7              	>>> 8:
   7              	>>>  hstring "align,"
   7 11ec 06       	>>>>  .byte lex+9f-(.+1)
   7 11ed 616C6967 	>>>>  .ascii "align,"
   7      6E2C
   7              	>>>> 9:
   7 11f3 00       	>>>>  .balign 4,0
   7              	>>>  .set lex,0
   7 11f4 D81F0000 	>>>  .int alignc
   7              	>>>  .previous
   7 1fd2 0000     	>>  .balign 4,0
   7 1fd4 EC110000 	>>  .int _thread
   7              	> alignc:
   8 1fd8 25A1     	  adr r1, dp                @ point r1 at dictionary pointer variable
   9 1fda 8A68     	  ldr r2, [r1, #BODY]       @ fetch contents of body of variable
  10 1fdc 0332     	  adds r2, r2, #3           @ align it to cell (4 bytes)
  11 1fde 22F00302 	  bic r2, r2, #3
  12 1fe2 8A60     	  str r2, [r1, #BODY]       @ store r0 into body of variable
  13              	  next
  13 1fe4 7047     	>  bx lr
  14              	
  15              	@ ------------------------------------------------------------------------
  16              	@ allot n1 bytes of dictionary space
  17              	
  18              	@     ( n1 --- )
  19              	
  20              	code "allot", allot
  20              	>  header "allot",allot
  20              	>>  _header_ "allot",allot
  20              	>>>  .section .data
  20 11f8 EC110000 	>>>  .int _thread
  20              	>>>  .set _thread,.
  20              	>>> 8:
  20              	>>>  hstring "allot"
  20 11fc 05       	>>>>  .byte lex+9f-(.+1)
  20 11fd 616C6C6F 	>>>>  .ascii "allot"
  20      74
  20              	>>>> 9:
  20 1202 0000     	>>>>  .balign 4,0
  20              	>>>  .set lex,0
  20 1204 EC1F0000 	>>>  .int allot
  20              	>>>  .previous
  20 1fe6 0000     	>>  .balign 4,0
  20 1fe8 FC110000 	>>  .int _thread
  20              	> allot:
  21 1fec 20A1     	  adr r1, dp                @ point r1 at dictionary pointer variable
  22              	0:                          @ common entry point 1
  23 1fee 8A68     	  ldr r2, [r1, #BODY]       @ fetch contents of body of variable
  24 1ff0 1218     	  adds r2, r2, r0           @ add size to allocate to address
  25              	1:                          @ common entry point 2
  26 1ff2 8A60     	  str r2, [r1, #BODY]       @ store r2 back in body of variable
  27 1ff4 01BC     	  pop { r0 }                @ pop new top of stack
  28              	  next
  28 1ff6 7047     	>  bx lr
  29              	
  30              	@ ------------------------------------------------------------------------
  31              	@ allot n1 bytes of head space
  32              	
  33              	@     ( n1 --- )
  34              	
  35              	code "hallot", hallot
  35              	>  header "hallot",hallot
  35              	>>  _header_ "hallot",hallot
  35              	>>>  .section .data
  35 1208 FC110000 	>>>  .int _thread
  35              	>>>  .set _thread,.
  35              	>>> 8:
  35              	>>>  hstring "hallot"
  35 120c 06       	>>>>  .byte lex+9f-(.+1)
  35 120d 68616C6C 	>>>>  .ascii "hallot"
  35      6F74
  35              	>>>> 9:
  35 1213 00       	>>>>  .balign 4,0
  35              	>>>  .set lex,0
  35 1214 FC1F0000 	>>>  .int hallot
  35              	>>>  .previous
  35              	>>  .balign 4,0
  35 1ff8 0C120000 	>>  .int _thread
  35              	> hallot:
  36 1ffc 20A1     	  adr r1, hp                @ point r1 at head space pointer variable
  37 1ffe F6E7     	  b 0b                      @ run common code above
  38              	
  39              	@ ------------------------------------------------------------------------
  40              	@ compile character c1 into dictionary space
  41              	
  42              	@     ( c1 --- )
  43              	
  44              	code "c,", ccomma
  44              	>  header "c,",ccomma
  44              	>>  _header_ "c,",ccomma
  44              	>>>  .section .data
  44 1218 0C120000 	>>>  .int _thread
  44              	>>>  .set _thread,.
  44              	>>> 8:
  44              	>>>  hstring "c,"
  44 121c 02       	>>>>  .byte lex+9f-(.+1)
  44 121d 632C     	>>>>  .ascii "c,"
  44              	>>>> 9:
  44 121f 00       	>>>>  .balign 4,0
  44              	>>>  .set lex,0
  44 1220 04200000 	>>>  .int ccomma
  44              	>>>  .previous
  44              	>>  .balign 4,0
  44 2000 1C120000 	>>  .int _thread
  44              	> ccomma:
  45 2004 1AA1     	  adr r1, dp                @ point r1 at variable dp
  46 2006 8A68     	  ldr r2, [r1, #BODY]       @ fetch body of variable dp into r2
  47 2008 02F8010B 	  strb r0, [r2], #1         @ store char c1 at address r2, advance r2
  48 200c F1E7     	  b 1b
  49              	
  50              	@ ------------------------------------------------------------------------
  51              	@ compile word (16 bits) w1 into dictionary space
  52              	
  53              	@     ( w1 --- )
  54              	
  55              	code "w,", wcomma
  55              	>  header "w,",wcomma
  55              	>>  _header_ "w,",wcomma
  55              	>>>  .section .data
  55 1224 1C120000 	>>>  .int _thread
  55              	>>>  .set _thread,.
  55              	>>> 8:
  55              	>>>  hstring "w,"
  55 1228 02       	>>>>  .byte lex+9f-(.+1)
  55 1229 772C     	>>>>  .ascii "w,"
  55              	>>>> 9:
  55 122b 00       	>>>>  .balign 4,0
  55              	>>>  .set lex,0
  55 122c 14200000 	>>>  .int wcomma
  55              	>>>  .previous
  55 200e 0000     	>>  .balign 4,0
  55 2010 28120000 	>>  .int _thread
  55              	> wcomma:
  56 2014 16A1     	  adr r1, dp                @ point r1 at variable dp
  57 2016 8A68     	  ldr r2, [r1, #BODY]       @ fetch body of variable dp into r2
  58 2018 22F8020B 	  strh r0, [r2], #2         @ store w1 at address r2, advance r2
  59 201c E9E7     	  b 1b
  60              	
  61              	@ ------------------------------------------------------------------------
  62              	@ compile n1 into dictionary space
  63              	
  64              	@     ( n1 --- )
  65              	
  66              	code ",", comma
  66              	>  header ",",comma
  66              	>>  _header_ ",",comma
  66              	>>>  .section .data
  66 1230 28120000 	>>>  .int _thread
  66              	>>>  .set _thread,.
  66              	>>> 8:
  66              	>>>  hstring ","
  66 1234 01       	>>>>  .byte lex+9f-(.+1)
  66 1235 2C       	>>>>  .ascii ","
  66              	>>>> 9:
  66 1236 0000     	>>>>  .balign 4,0
  66              	>>>  .set lex,0
  66 1238 24200000 	>>>  .int comma
  66              	>>>  .previous
  66 201e 0000     	>>  .balign 4,0
  66 2020 34120000 	>>  .int _thread
  66              	> comma:
  67 2024 12A1     	  adr r1, dp                @ point r1 at variable dp
  68              	2:
  69 2026 8A68     	  ldr r2, [r1, #BODY]       @ fetch body of variable dp into r2
  70 2028 22F8020B 	  strh r0, [r2], #2         @ compile lower half of 32 bits to compile
  71 202c 000C     	  lsrs r0, #16              @ get upper half
  72 202e 22F8020B 	  strh r0, [r2], #2         @ compile that too.
  73 2032 DEE7     	  b 1b                      @ store r2 back into dp = allot space
  74              	
  75              	@ ------------------------------------------------------------------------
  76              	@ compile n1 into head space
  77              	
  78              	@     ( n1 --- )
  79              	
  80              	code "h,", hcomma
  80              	>  header "h,",hcomma
  80              	>>  _header_ "h,",hcomma
  80              	>>>  .section .data
  80 123c 34120000 	>>>  .int _thread
  80              	>>>  .set _thread,.
  80              	>>> 8:
  80              	>>>  hstring "h,"
  80 1240 02       	>>>>  .byte lex+9f-(.+1)
  80 1241 682C     	>>>>  .ascii "h,"
  80              	>>>> 9:
  80 1243 00       	>>>>  .balign 4,0
  80              	>>>  .set lex,0
  80 1244 38200000 	>>>  .int hcomma
  80              	>>>  .previous
  80              	>>  .balign 4,0
  80 2034 40120000 	>>  .int _thread
  80              	> hcomma:
  81 2038 11A1     	  adr r1, hp                @ point r1 at variable hp
  82 203a F4E7     	  b 2b
  83              	
  84              	@ ------------------------------------------------------------------------
  85              	@ fetch an inline literal and comma it
  86              	
  87              	@ this is very similar to compile but compile is used to compile execution
  88              	@ tokens which in this forth are always bl opcodes.  this does the same
  89              	@ thing as compile but does not construct a bl opcode of the item being
  90              	@ commad in
  91              	
  92              	@ this and the following word are generally used wtihin the kernel to
  93              	@ fetch an opcode that the assembler layed down and compiling it into
  94              	@ the definition currently being created.
  95              	
  96              	code "lit,", litc
  96              	>  header "lit,",litc
  96              	>>  _header_ "lit,",litc
  96              	>>>  .section .data
  96 1248 40120000 	>>>  .int _thread
  96              	>>>  .set _thread,.
  96              	>>> 8:
  96              	>>>  hstring "lit,"
  96 124c 04       	>>>>  .byte lex+9f-(.+1)
  96 124d 6C69742C 	>>>>  .ascii "lit,"
  96              	>>>> 9:
  96 1251 000000   	>>>>  .balign 4,0
  96              	>>>  .set lex,0
  96 1254 40200000 	>>>  .int litc
  96              	>>>  .previous
  96              	>>  .balign 4,0
  96 203c 4C120000 	>>  .int _thread
  96              	> litc:
  97 2040 01B4     	  push { r0 }               @ save top of stack
  98 2042 2EF0010E 	  bic lr, #1                @ thumb interworking is a PITA
  99 2046 BEF80000 	  ldrh r0, [lr]             @ fetch 32 bits. might not be 32 bit aligned
 100 204a BEF80210 	  ldrh r1, [lr, #2]         @ lr is advanced past literal
 101 204e 40EA0140 	  orr r0, r0, r1, lsl #16   @ combine two 16 but fetches
 102 2052 0EF1050E 	  add lr, lr, #5            @ lr must be odd
 103 2056 E5E7     	  b comma                   @ compile in the literal
 104              	
 105              	@ ------------------------------------------------------------------------
 106              	@ as aabove but fetches a 16 bit literal
 107              	
 108              	code "wlit," wlitc
 108              	>  header "wlit,",wlitc
 108              	>>  _header_ "wlit,",wlitc
 108              	>>>  .section .data
 108 1258 4C120000 	>>>  .int _thread
 108              	>>>  .set _thread,.
 108              	>>> 8:
 108              	>>>  hstring "wlit,"
 108 125c 05       	>>>>  .byte lex+9f-(.+1)
 108 125d 776C6974 	>>>>  .ascii "wlit,"
 108      2C
 108              	>>>> 9:
 108 1262 0000     	>>>>  .balign 4,0
 108              	>>>  .set lex,0
 108 1264 5C200000 	>>>  .int wlitc
 108              	>>>  .previous
 108              	>>  .balign 4,0
 108 2058 5C120000 	>>  .int _thread
 108              	> wlitc:
 109 205c 01B4     	  push { r0 }
 110 205e 2EF0010E 	  bic lr, #1
 111 2062 BEF80000 	  ldrh r0, [lr]
 112 2066 0EF1030E 	  add lr, lr, #3
 113 206a D3E7     	  b wcomma
 114              	
 115              	@ ========================================================================
 327              	  .include "header.s"       @ forth word header creation
   1              	@ header.s    - forth word header creating and scanning (not search)
   2              	@ ------------------------------------------------------------------------
   3              	
   4              	@ ------------------------------------------------------------------------
   5              	
   6              	  _var_ "dp",     dp, _headers      @ defined in linker script
   6              	>  header "dp",dp
   6              	>>  _header_ "dp",dp
   6              	>>>  .section .data
   6 1268 5C120000 	>>>  .int _thread
   6              	>>>  .set _thread,.
   6              	>>> 8:
   6              	>>>  hstring "dp"
   6 126c 02       	>>>>  .byte lex+9f-(.+1)
   6 126d 6470     	>>>>  .ascii "dp"
   6              	>>>> 9:
   6 126f 00       	>>>>  .balign 4,0
   6              	>>>  .set lex,0
   6 1270 70200000 	>>>  .int dp
   6              	>>>  .previous
   6              	>>  .balign 4,0
   6 206c 6C120000 	>>  .int _thread
   6              	> dp:
   6              	>  rpush lr
   6 2070 4CF804ED 	>>  str lr,[rp,#-4]!
   6 2074 FEF780F9 	>  bl dovar
   6 2078 00000000 	>  .int _headers
   7              	  _var_ "hp",     hp, 0
   7              	>  header "hp",hp
   7              	>>  _header_ "hp",hp
   7              	>>>  .section .data
   7 1274 6C120000 	>>>  .int _thread
   7              	>>>  .set _thread,.
   7              	>>> 8:
   7              	>>>  hstring "hp"
   7 1278 02       	>>>>  .byte lex+9f-(.+1)
   7 1279 6870     	>>>>  .ascii "hp"
   7              	>>>> 9:
   7 127b 00       	>>>>  .balign 4,0
   7              	>>>  .set lex,0
   7 127c 80200000 	>>>  .int hp
   7              	>>>  .previous
   7              	>>  .balign 4,0
   7 207c 78120000 	>>  .int _thread
   7              	> hp:
   7              	>  rpush lr
   7 2080 4CF804ED 	>>  str lr,[rp,#-4]!
   7 2084 FEF778F9 	>  bl dovar
   7 2088 00000000 	>  .int 0
   8              	  _var_ "old_dp", old_dp _headers   @ lower bounds to clear icache
   8              	>  header "old_dp",old_dp
   8              	>>  _header_ "old_dp",old_dp
   8              	>>>  .section .data
   8 1280 78120000 	>>>  .int _thread
   8              	>>>  .set _thread,.
   8              	>>> 8:
   8              	>>>  hstring "old_dp"
   8 1284 06       	>>>>  .byte lex+9f-(.+1)
   8 1285 6F6C645F 	>>>>  .ascii "old_dp"
   8      6470
   8              	>>>> 9:
   8 128b 00       	>>>>  .balign 4,0
   8              	>>>  .set lex,0
   8 128c 90200000 	>>>  .int old_dp
   8              	>>>  .previous
   8              	>>  .balign 4,0
   8 208c 84120000 	>>  .int _thread
   8              	> old_dp:
   8              	>  rpush lr
   8 2090 4CF804ED 	>>  str lr,[rp,#-4]!
   8 2094 FEF770F9 	>  bl dovar
   8 2098 00000000 	>  .int _headers
   9              	
  10              	  _alias_ "here", dp, here
  10              	>  .set lex,ALIAS
  10              	>  _header_ "here",dp
  10              	>>  .section .data
  10 1290 84120000 	>>  .int _thread
  10              	>>  .set _thread,.
  10              	>> 8:
  10              	>>  hstring "here"
  10 1294 44       	>>>  .byte lex+9f-(.+1)
  10 1295 68657265 	>>>  .ascii "here"
  10              	>>> 9:
  10 1299 000000   	>>>  .balign 4,0
  10              	>>  .set lex,0
  10 129c 70200000 	>>  .int dp
  10              	>>  .previous
  10              	>  .set here,dp
  11              	  _alias_ "hhere", hp, hhere
  11              	>  .set lex,ALIAS
  11              	>  _header_ "hhere",hp
  11              	>>  .section .data
  11 12a0 94120000 	>>  .int _thread
  11              	>>  .set _thread,.
  11              	>> 8:
  11              	>>  hstring "hhere"
  11 12a4 45       	>>>  .byte lex+9f-(.+1)
  11 12a5 68686572 	>>>  .ascii "hhere"
  11      65
  11              	>>> 9:
  11 12aa 0000     	>>>  .balign 4,0
  11              	>>  .set lex,0
  11 12ac 80200000 	>>  .int hp
  11              	>>  .previous
  11              	>  .set hhere,hp
  12              	
  13              	@ ------------------------------------------------------------------------
  14              	@ mask lex bits from nfa length byte
  15              	
  16              	@     ( c1 --- c2 )
  17              	
  18              	code "lexmask", lexmask
  18              	>  header "lexmask",lexmask
  18              	>>  _header_ "lexmask",lexmask
  18              	>>>  .section .data
  18 12b0 A4120000 	>>>  .int _thread
  18              	>>>  .set _thread,.
  18              	>>> 8:
  18              	>>>  hstring "lexmask"
  18 12b4 07       	>>>>  .byte lex+9f-(.+1)
  18 12b5 6C65786D 	>>>>  .ascii "lexmask"
  18      61736B
  18              	>>>> 9:
  18              	>>>>  .balign 4,0
  18              	>>>  .set lex,0
  18 12bc A0200000 	>>>  .int lexmask
  18              	>>>  .previous
  18              	>>  .balign 4,0
  18 209c B4120000 	>>  .int _thread
  18              	> lexmask:
  19 20a0 00F03F00 	  and r0, r0, #LEXMASK
  20              	  next
  20 20a4 7047     	>  bx lr
  21              	
  22              	@ ------------------------------------------------------------------------
  23              	@ given cfa compute body address
  24              	
  25              	@     ( a1 --- a2 )
  26              	
  27              	code ">body", tobody
  27              	>  header ">body",tobody
  27              	>>  _header_ ">body",tobody
  27              	>>>  .section .data
  27 12c0 B4120000 	>>>  .int _thread
  27              	>>>  .set _thread,.
  27              	>>> 8:
  27              	>>>  hstring ">body"
  27 12c4 05       	>>>>  .byte lex+9f-(.+1)
  27 12c5 3E626F64 	>>>>  .ascii ">body"
  27      79
  27              	>>>> 9:
  27 12ca 0000     	>>>>  .balign 4,0
  27              	>>>  .set lex,0
  27 12cc AC200000 	>>>  .int tobody
  27              	>>>  .previous
  27 20a6 0000     	>>  .balign 4,0
  27 20a8 C4120000 	>>  .int _thread
  27              	> tobody:
  28 20ac 0830     	  adds r0, r0, #BODY
  29              	  next
  29 20ae 7047     	>  bx lr
  30              	
  31              	@ ------------------------------------------------------------------------
  32              	@ given body address compute cfa
  33              	
  34              	@     ( a1 --- a2 )
  35              	
  36              	code "body>", bodyto
  36              	>  header "body>",bodyto
  36              	>>  _header_ "body>",bodyto
  36              	>>>  .section .data
  36 12d0 C4120000 	>>>  .int _thread
  36              	>>>  .set _thread,.
  36              	>>> 8:
  36              	>>>  hstring "body>"
  36 12d4 05       	>>>>  .byte lex+9f-(.+1)
  36 12d5 626F6479 	>>>>  .ascii "body>"
  36      3E
  36              	>>>> 9:
  36 12da 0000     	>>>>  .balign 4,0
  36              	>>>  .set lex,0
  36 12dc B4200000 	>>>  .int bodyto
  36              	>>>  .previous
  36              	>>  .balign 4,0
  36 20b0 D4120000 	>>  .int _thread
  36              	> bodyto:
  37 20b4 0838     	  subs r0, r0, #BODY
  38              	  next
  38 20b6 7047     	>  bx lr
  39              	
  40              	@ ------------------------------------------------------------------------
  41              	@ given nfa compute lfa
  42              	
  43              	@     ( a1 --- a2 )
  44              	
  45              	  _alias_ "n>link", cellminus, ntolink
  45              	>  .set lex,ALIAS
  45              	>  _header_ "n>link",cellminus
  45              	>>  .section .data
  45 12e0 D4120000 	>>  .int _thread
  45              	>>  .set _thread,.
  45              	>> 8:
  45              	>>  hstring "n>link"
  45 12e4 46       	>>>  .byte lex+9f-(.+1)
  45 12e5 6E3E6C69 	>>>  .ascii "n>link"
  45      6E6B
  45              	>>> 9:
  45 12eb 00       	>>>  .balign 4,0
  45              	>>  .set lex,0
  45 12ec 2C0C0000 	>>  .int cellminus
  45              	>>  .previous
  45              	>  .set ntolink,cellminus
  46              	
  47              	@ ------------------------------------------------------------------------
  48              	@ given lfa compute nfa
  49              	
  50              	@     ( a1 --- a2 )
  51              	
  52              	  _alias_ "l>name", cellplus, ltoname
  52              	>  .set lex,ALIAS
  52              	>  _header_ "l>name",cellplus
  52              	>>  .section .data
  52 12f0 E4120000 	>>  .int _thread
  52              	>>  .set _thread,.
  52              	>> 8:
  52              	>>  hstring "l>name"
  52 12f4 46       	>>>  .byte lex+9f-(.+1)
  52 12f5 6C3E6E61 	>>>  .ascii "l>name"
  52      6D65
  52              	>>> 9:
  52 12fb 00       	>>>  .balign 4,0
  52              	>>  .set lex,0
  52 12fc 240C0000 	>>  .int cellplus
  52              	>>  .previous
  52              	>  .set ltoname,cellplus
  53              	
  54              	@ ------------------------------------------------------------------------
  55              	@ given cfa compute nfa
  56              	
  57              	@     ( a1 --- a2 )
  58              	
  59              	code ">name", toname
  59              	>  header ">name",toname
  59              	>>  _header_ ">name",toname
  59              	>>>  .section .data
  59 1300 F4120000 	>>>  .int _thread
  59              	>>>  .set _thread,.
  59              	>>> 8:
  59              	>>>  hstring ">name"
  59 1304 05       	>>>>  .byte lex+9f-(.+1)
  59 1305 3E6E616D 	>>>>  .ascii ">name"
  59      65
  59              	>>>> 9:
  59 130a 0000     	>>>>  .balign 4,0
  59              	>>>  .set lex,0
  59 130c BC200000 	>>>  .int toname
  59              	>>>  .previous
  59              	>>  .balign 4,0
  59 20b8 04130000 	>>  .int _thread
  59              	> toname:
  60 20bc 50F8040C 	  ldr r0, [r0, #-4]
  61              	  next
  61 20c0 7047     	>  bx lr
  62              	
  63              	@ ------------------------------------------------------------------------
  64              	@ given nfa compute cfa
  65              	
  66              	@     ( a1 --- a2)
  67              	
  68              	colon "name>", nameto
  68              	>  header "name>",nameto
  68              	>>  _header_ "name>",nameto
  68              	>>>  .section .data
  68 1310 04130000 	>>>  .int _thread
  68              	>>>  .set _thread,.
  68              	>>> 8:
  68              	>>>  hstring "name>"
  68 1314 05       	>>>>  .byte lex+9f-(.+1)
  68 1315 6E616D65 	>>>>  .ascii "name>"
  68      3E
  68              	>>>> 9:
  68 131a 0000     	>>>>  .balign 4,0
  68              	>>>  .set lex,0
  68 131c C8200000 	>>>  .int nameto
  68              	>>>  .previous
  68 20c2 0000     	>>  .balign 4,0
  68 20c4 14130000 	>>  .int _thread
  68              	> nameto:
  68 20c8 AFF30080 	>  nop.w
  68              	>  rpush lr
  68 20cc 4CF804ED 	>>  str lr,[rp,#-4]!
  69 20d0 FEF706FC 	  bl count                  @ get address and length of string
  70 20d4 FFF7E4FF 	  bl lexmask                @ mask out lex bits from count byte
  71 20d8 FEF74EFD 	  bl plus                   @ add count byte to address
  72 20dc FFF7F8FC 	  bl align                  @ align to cell boundry
  73 20e0 FEF772FB 	  bl fetch                  @ fetch address of cfa from header
  74              	  exit
  74              	>  rpop pc
  74 20e4 5CF804FB 	>>  ldr pc,[rp],#4
  75              	
  76              	@ ------------------------------------------------------------------------
  77              	
  78              	@     ( a1 n1 --- )
  79              	
  80              	colon "(head,)", phead
  80              	>  header "(head,)",phead
  80              	>>  _header_ "(head,)",phead
  80              	>>>  .section .data
  80 1320 14130000 	>>>  .int _thread
  80              	>>>  .set _thread,.
  80              	>>> 8:
  80              	>>>  hstring "(head,)"
  80 1324 07       	>>>>  .byte lex+9f-(.+1)
  80 1325 28686561 	>>>>  .ascii "(head,)"
  80      642C29
  80              	>>>> 9:
  80              	>>>>  .balign 4,0
  80              	>>>  .set lex,0
  80 132c EC200000 	>>>  .int phead
  80              	>>>  .previous
  80              	>>  .balign 4,0
  80 20e8 24130000 	>>  .int _thread
  80              	> phead:
  80 20ec AFF30080 	>  nop.w
  80              	>  rpush lr
  80 20f0 4CF804ED 	>>  str lr,[rp,#-4]!
  81 20f4 FFF770FF 	  bl alignc                 @ make sure here is balign 4
  82 20f8 FFF7C2FF 	  bl hhere                  @ keep current head space address
  83 20fc FEF75AFA 	  bl tor                    @ save lfa (see below **)
  84              	  cliteral 0                @ compile a dummy lfa into head space
  84 2100 01B4     	>  push { r0 }
  84 2102 0020     	>  movs r0,#0
  85 2104 FFF798FF 	  bl hcomma
  86 2108 FFF7BAFF 	  bl hhere                  @ this is the new headers nfa
  87 210c FEF7FAF9 	  bl dup
  88 2110 FEF77EFB 	  bl zstoreto               @ save address of most recent words nfa
  89 2114 FFF7C0FC 	  bl last
  90 2118 FEF7F4F9 	  bl dup
  91 211c FFF782FF 	  bl comma                  @ comma address of nfa into cfa -4
  92              	
  93 2120 FEF7F6FC 	  bl strstore               @ this is not allotted yet... see below
  94              	
  95 2124 00F0D2FB 	  bl current                @ get current vocabulary
  96 2128 FFF7C0FF 	  bl tobody
  97 212c FFF7A8FF 	  bl hhere                  @ compute thread for new word
  98 2130 00F04CF8 	  bl hash
  99 2134 FEF720FD 	  bl plus
 100 2138 FEF7E4F9 	  bl dup                    @ remember address of vocabulary thread
 101 213c FEF768FB 	  bl zstoreto
 102 2140 FFF7B2FC 	  bl thread                 @ we are attaching the new header to
 103              	
 104 2144 FEF740FB 	  bl fetch                  @ fetch address of previous header on this thread
 105 2148 FEF744FA 	  bl rto
 106 214c FEF744FB 	  bl store                  @ store it in our lfa (see above **)
 107              	
 108 2150 FFF796FF 	  bl hhere                  @ now allocate the nfa in head space
 109 2154 FEF748FB 	  bl cfetch
 110 2158 FEF74CFD 	  bl oneplus
 111 215c FFF7B8FC 	  bl align
 112 2160 FFF74CFF 	  bl hallot
 113 2164 FFF784FF 	  bl here                   @ compile pointer to cfa into header
 114 2168 FFF766FF 	  bl hcomma
 115              	  exit
 115              	>  rpop pc
 115 216c 5CF804FB 	>>  ldr pc,[rp],#4
 116              	
 117              	@ ------------------------------------------------------------------------
 118              	
 119              	colon "head,", headcomma
 119              	>  header "head,",headcomma
 119              	>>  _header_ "head,",headcomma
 119              	>>>  .section .data
 119 1330 24130000 	>>>  .int _thread
 119              	>>>  .set _thread,.
 119              	>>> 8:
 119              	>>>  hstring "head,"
 119 1334 05       	>>>>  .byte lex+9f-(.+1)
 119 1335 68656164 	>>>>  .ascii "head,"
 119      2C
 119              	>>>> 9:
 119 133a 0000     	>>>>  .balign 4,0
 119              	>>>  .set lex,0
 119 133c 74210000 	>>>  .int headcomma
 119              	>>>  .previous
 119              	>>  .balign 4,0
 119 2170 34130000 	>>  .int _thread
 119              	> headcomma:
 119 2174 AFF30080 	>  nop.w
 119              	>  rpush lr
 119 2178 4CF804ED 	>>  str lr,[rp,#-4]!
 120 217c FEF784FF 	  bl bl_                    @ parse the next space delimited token out of
 121 2180 FFF732FB 	  bl parseword              @ the input stream (the name for the new word)
 122 2184 FFF7B2FF 	  bl phead                  @ create a new header with this name
 123              	  exit
 123              	>  rpop pc
 123 2188 5CF804FB 	>>  ldr pc,[rp],#4
 124              	
 125              	@ ------------------------------------------------------------------------
 126              	@ reveal the most recently created word and flush the icache for it
 127              	
 128              	colon "reveal", reveal
 128              	>  header "reveal",reveal
 128              	>>  _header_ "reveal",reveal
 128              	>>>  .section .data
 128 1340 34130000 	>>>  .int _thread
 128              	>>>  .set _thread,.
 128              	>>> 8:
 128              	>>>  hstring "reveal"
 128 1344 06       	>>>>  .byte lex+9f-(.+1)
 128 1345 72657665 	>>>>  .ascii "reveal"
 128      616C
 128              	>>>> 9:
 128 134b 00       	>>>>  .balign 4,0
 128              	>>>  .set lex,0
 128 134c 90210000 	>>>  .int reveal
 128              	>>>  .previous
 128              	>>  .balign 4,0
 128 218c 44130000 	>>  .int _thread
 128              	> reveal:
 128 2190 AFF30080 	>  nop.w
 128              	>  rpush lr
 128 2194 4CF804ED 	>>  str lr,[rp,#-4]!
 129 2198 FFF77EFC 	  bl last                   @ get nfa of word we just created
 130 219c FFF784FC 	  bl thread                 @ which voc thread should we add it to
 131 21a0 FEF71AFB 	  bl store                  @ add it to thread - make it visisble
 132              	
 133              	  @ we just wrote new data (code) into memory. we now need to invalidate
 134              	  @ the instruction cache for this memory so that if we try to execute
 135              	  @ this new word the cpu will see what we just wrote
 136              	
 137 21a4 01B4     	  push { r0 }               @ point r0 at where new word starts in code
 138 21a6 AFF21812 	  adr r2, old_dp
 139 21aa 9068     	  ldr r0, [r2, #BODY]
 140 21ac AFF24011 	  adr r1, dp                @ point where new word ends in code
 141 21b0 8968     	  ldr r1, [r1, #BODY]
 142 21b2 9160     	  str r1, [r2, #BODY]       @ new end = next start
 143 21b4 40F20207 	  movw r7, #0x02
 144 21b8 C0F20F07 	  movt r7, #0x0f
 145 21bc 0022     	  movs r2, #0
 146 21be 00DF     	  swi 0
 147 21c0 01BC     	  pop { r0 }
 148              	  exit
 148              	>  rpop pc
 148 21c2 5CF804FB 	>>  ldr pc,[rp],#4
 149              	
 150              	@ ========================================================================
 328              	  .include "find.s"         @ dictionary searches
   1              	@ find.s
   2              	@ ------------------------------------------------------------------------
   3              	
   4              	@ ------------------------------------------------------------------------
   5              	@ compute hash value of nfa string
   6              	
   7              	@   ( a1 --- thread )
   8              	
   9              	code "hash", hash
   9              	>  header "hash",hash
   9              	>>  _header_ "hash",hash
   9              	>>>  .section .data
   9 1350 44130000 	>>>  .int _thread
   9              	>>>  .set _thread,.
   9              	>>> 8:
   9              	>>>  hstring "hash"
   9 1354 04       	>>>>  .byte lex+9f-(.+1)
   9 1355 68617368 	>>>>  .ascii "hash"
   9              	>>>> 9:
   9 1359 000000   	>>>>  .balign 4,0
   9              	>>>  .set lex,0
   9 135c CC210000 	>>>  .int hash
   9              	>>>  .previous
   9 21c6 0000     	>>  .balign 4,0
   9 21c8 54130000 	>>  .int _thread
   9              	> hash:
  10 21cc 10F8011B 	  ldrb r1, [r0], #1       @ r1 = name length
  11 21d0 01F03F01 	  and r1, #LEXMASK        @ mask out lex bits (immediate etc)
  12 21d4 10F8012B 	  ldrb r2, [r0], #1       @ fetch first char of word name
  13 21d8 9218     	  adds r2, r2             @ char 1 times 2
  14 21da 0129     	  cmp r1, #1              @ is there only one character in name?
  15 21dc 1EBF     	  ittt ne
  16 21de 0378     	  ldrbne r3, [r0]         @ if not fetch second char
  17 21e0 D218     	  addne r2, r3            @ add it to first char
  18 21e2 9218     	  addne r2, r2            @ multiply result by 2
  19 21e4 8818     	  adds r0, r1, r2         @ add in length
  20 21e6 00F03F00 	  and r0, #0x3f           @ mask the result to 0-63
  21 21ea 8000     	  lsls r0, #2             @ cells
  22              	  next
  22 21ec 7047     	>  bx lr
  23              	
  24              	@ ------------------------------------------------------------------------
  25              	@ search one thread of vocab for word whose name is at hhere
  26              	
  27              	@     ( thread --- cfa t | f )
  28              	
  29              	code "(find)", pfind
  29              	>  header "(find)",pfind
  29              	>>  _header_ "(find)",pfind
  29              	>>>  .section .data
  29 1360 54130000 	>>>  .int _thread
  29              	>>>  .set _thread,.
  29              	>>> 8:
  29              	>>>  hstring "(find)"
  29 1364 06       	>>>>  .byte lex+9f-(.+1)
  29 1365 2866696E 	>>>>  .ascii "(find)"
  29      6429
  29              	>>>> 9:
  29 136b 00       	>>>>  .balign 4,0
  29              	>>>  .set lex,0
  29 136c F4210000 	>>>  .int pfind
  29              	>>>  .previous
  29 21ee 0000     	>>  .balign 4,0
  29 21f0 64130000 	>>  .int _thread
  29              	> pfind:
  30 21f4 68B1     	  cbz r0, 2f                @ is specified thread empty?
  31              	
  32 21f6 AFF27812 	  adr r2, hp                @ point r2 to 'hhere'
  33 21fa 9268     	  ldr r2, [r2, #BODY]       @ r2 = name string of word to search for
  34              	
  35 21fc 12F8011B 	  ldrb r1, [r2], #1         @ r1 = length of word name to search for
  36              	0:
  37 2200 0378     	  ldrb r3, [r0]             @ r3 = length of next word in specified thread
  38 2202 03F03F08 	  and r8, r3, #LEXMASK      @ mask out lex bits from length byte
  39 2206 8845     	  cmp r8, r1                @ are lengths equal?
  40 2208 04D0     	  beq 3f
  41              	1:
  42 220a 50F8040C 	  ldr r0, [r0, #-4]         @ no.. scan back one word in thread
  43 220e 0028     	  cmp r0, #0                @ at end of thread?
  44 2210 F6D1     	  bne 0b
  45              	2:
  46              	  next                      @ not found. return r0 = false
  46 2212 7047     	>  bx lr
  47              	
  48              	  @ lengths match - compare strings...
  49              	
  50              	3:
  51 2214 441C     	  adds r4, r0, #1           @ r4 = string in dictionary thread
  52 2216 1500     	  movs r5, r2               @ r5 = string to compare with
  53              	4:
  54 2218 14F8016B 	  ldrb r6, [r4], #1         @ fetch next byte from both strings
  55 221c 15F8017B 	  ldrb r7, [r5], #1
  56 2220 BE42     	  cmp r6, r7                @ are they the same?
  57 2222 F2D1     	  bne 1b                    @ if not loop back to get next word from thread
  58 2224 B8F10108 	  subs r8, #1               @ length--
  59 2228 F6D1     	  bne 4b                    @ till at end of string
  60              	
  61              	  @ strings match - we found the word
  62              	
  63 222a 03F03F08 	  and r8, r3, #LEXMASK      @ add masked word length to nfa
  64 222e 4044     	  add r0, r8
  65 2230 0430     	  adds r0, #4               @ also count count byte as part of length
  66 2232 20F00300 	  bic r0, r0, #3            @ and align to cell
  67 2236 0168     	  ldr r1, [r0]              @ fetch cfa of word we found from header
  68 2238 02B4     	  push { r1 }               @ return the cfa
  69              	
  70 223a 13F0800F 	  tst r3, #0x80             @ is this an immediate word?
  71 223e 14BF     	  ite ne
  72 2240 0120     	  movne r0, #1              @ if not f1 = 1
  73 2242 6FF00000 	  mvneq r0, #0              @ if so f1 = -1
  74              	  next
  74 2246 7047     	>  bx lr
  75              	
  76              	@ ------------------------------------------------------------------------
  77              	@ search all in-context vocs for word whose name is at hhere
  78              	
  79              	@   ( --- cfa f1 | false )
  80              	
  81              	colon "find", find
  81              	>  header "find",find
  81              	>>  _header_ "find",find
  81              	>>>  .section .data
  81 1370 64130000 	>>>  .int _thread
  81              	>>>  .set _thread,.
  81              	>>> 8:
  81              	>>>  hstring "find"
  81 1374 04       	>>>>  .byte lex+9f-(.+1)
  81 1375 66696E64 	>>>>  .ascii "find"
  81              	>>>> 9:
  81 1379 000000   	>>>>  .balign 4,0
  81              	>>>  .set lex,0
  81 137c 4C220000 	>>>  .int find
  81              	>>>  .previous
  81              	>>  .balign 4,0
  81 2248 74130000 	>>  .int _thread
  81              	> find:
  81 224c AFF30080 	>  nop.w
  81              	>  rpush lr
  81 2250 4CF804ED 	>>  str lr,[rp,#-4]!
  82 2254 FFF714FF 	  bl hhere                @ compute hash (thread) of word name at hhere
  83 2258 FFF7B8FF 	  bl hash
  84 225c 00F092FB 	  bl tocontext
  85              	  cliteral 16
  85 2260 01B4     	>  push { r0 }
  85 2262 1020     	>  movs r0,#16
  86 2264 FEF760F9 	  bl swap
  87              	
  88 2268 FFF73AFE 	  bl pdo                  @ for each vocabulary in context do...
  89 226c 4300     	  .hword (2f - .) + 1
  90              	0:
  91 226e FEF749F9 	  bl dup                  @ keep address of vocab
  92 2272 FFF759FE 	  bl i                    @ index to next item on context stack
  93 2276 FEF771FA 	  bl cells_fetch
  94 227a FFF717FF 	  bl tobody               @ point to the body of the vocab not the cfa
  95 227e FEF781F9 	  bl pluck                @ index to correct thread within this voc
  96 2282 FEF779FC 	  bl plus
  97 2286 FEF79FFA 	  bl fetch
  98 228a FFF7B3FF 	  bl pfind                @ search thread for specified word name
  99              	
 100 228e FEF733F9 	  bl qdup
 101 2292 FFF7EBFD 	  bl qbranch              @ did we find it?
 102 2296 1300     	  .hword (1f - .) + 1
 103              	
 104              	  @ yes - word was found
 105              	
 106 2298 FFF7F0FD 	  bl undo                 @ discard loop index
 107 229c FEF74AF9 	  bl twoswap
 108 22a0 FEF754F9 	  bl twodrop
 109              	  exit
 109              	>  rpop pc
 109 22a4 5CF804FB 	>>  ldr pc,[rp],#4
 110              	
 111              	1:
 112 22a8 FFF7FEFD 	  bl ploop
 113 22ac C3FF     	  .hword (0b - .) + 1
 114              	
 115              	2:
 116 22ae FEF74DF9 	  bl twodrop
 117 22b2 FEF7F9FD 	  bl false
 118              	  exit
 118              	>  rpop pc
 118 22b6 5CF804FB 	>>  ldr pc,[rp],#4
 119              	
 120              	@ ========================================================================
 329              	@  .include "variable.s"     @ variable and constant creation etc
 330              	  .include "fload.s"        @ input from file
   1              	@ fload.s   - interpret a forth source file
   2              	@ ------------------------------------------------------------------------
   3              	
   4              	@ ------------------------------------------------------------------------
   5              	
   6              	  _var_ "fd", fd, 0         @ file handle of file being loaded
   6              	>  header "fd",fd
   6              	>>  _header_ "fd",fd
   6              	>>>  .section .data
   6 1380 74130000 	>>>  .int _thread
   6              	>>>  .set _thread,.
   6              	>>> 8:
   6              	>>>  hstring "fd"
   6 1384 02       	>>>>  .byte lex+9f-(.+1)
   6 1385 6664     	>>>>  .ascii "fd"
   6              	>>>> 9:
   6 1387 00       	>>>>  .balign 4,0
   6              	>>>  .set lex,0
   6 1388 C0220000 	>>>  .int fd
   6              	>>>  .previous
   6 22ba 0000     	>>  .balign 4,0
   6 22bc 84130000 	>>  .int _thread
   6              	> fd:
   6              	>  rpush lr
   6 22c0 4CF804ED 	>>  str lr,[rp,#-4]!
   6 22c4 FEF758F8 	>  bl dovar
   6 22c8 00000000 	>  .int 0
   7              	  _var_ "line#", linenum, 0 @ current line number of file
   7              	>  header "line#",linenum
   7              	>>  _header_ "line#",linenum
   7              	>>>  .section .data
   7 138c 84130000 	>>>  .int _thread
   7              	>>>  .set _thread,.
   7              	>>> 8:
   7              	>>>  hstring "line#"
   7 1390 05       	>>>>  .byte lex+9f-(.+1)
   7 1391 6C696E65 	>>>>  .ascii "line#"
   7      23
   7              	>>>> 9:
   7 1396 0000     	>>>>  .balign 4,0
   7              	>>>  .set lex,0
   7 1398 D0220000 	>>>  .int linenum
   7              	>>>  .previous
   7              	>>  .balign 4,0
   7 22cc 90130000 	>>  .int _thread
   7              	> linenum:
   7              	>  rpush lr
   7 22d0 4CF804ED 	>>  str lr,[rp,#-4]!
   7 22d4 FEF750F8 	>  bl dovar
   7 22d8 00000000 	>  .int 0
   8              	  _var_ "floads", floads, 0 @ current depth of floading (max = 5)
   8              	>  header "floads",floads
   8              	>>  _header_ "floads",floads
   8              	>>>  .section .data
   8 139c 90130000 	>>>  .int _thread
   8              	>>>  .set _thread,.
   8              	>>> 8:
   8              	>>>  hstring "floads"
   8 13a0 06       	>>>>  .byte lex+9f-(.+1)
   8 13a1 666C6F61 	>>>>  .ascii "floads"
   8      6473
   8              	>>>> 9:
   8 13a7 00       	>>>>  .balign 4,0
   8              	>>>  .set lex,0
   8 13a8 E0220000 	>>>  .int floads
   8              	>>>  .previous
   8              	>>  .balign 4,0
   8 22dc A0130000 	>>  .int _thread
   8              	> floads:
   8              	>  rpush lr
   8 22e0 4CF804ED 	>>  str lr,[rp,#-4]!
   8 22e4 FEF748F8 	>  bl dovar
   8 22e8 00000000 	>  .int 0
   9              	  _var_ "flsize", flsize, 0 @ file size
   9              	>  header "flsize",flsize
   9              	>>  _header_ "flsize",flsize
   9              	>>>  .section .data
   9 13ac A0130000 	>>>  .int _thread
   9              	>>>  .set _thread,.
   9              	>>> 8:
   9              	>>>  hstring "flsize"
   9 13b0 06       	>>>>  .byte lex+9f-(.+1)
   9 13b1 666C7369 	>>>>  .ascii "flsize"
   9      7A65
   9              	>>>> 9:
   9 13b7 00       	>>>>  .balign 4,0
   9              	>>>  .set lex,0
   9 13b8 F0220000 	>>>  .int flsize
   9              	>>>  .previous
   9              	>>  .balign 4,0
   9 22ec B0130000 	>>  .int _thread
   9              	> flsize:
   9              	>  rpush lr
   9 22f0 4CF804ED 	>>  str lr,[rp,#-4]!
   9 22f4 FEF740F8 	>  bl dovar
   9 22f8 00000000 	>  .int 0
  10              	  _var_ "fladdr", fladdr, 0 @ address of memory mapping
  10              	>  header "fladdr",fladdr
  10              	>>  _header_ "fladdr",fladdr
  10              	>>>  .section .data
  10 13bc B0130000 	>>>  .int _thread
  10              	>>>  .set _thread,.
  10              	>>> 8:
  10              	>>>  hstring "fladdr"
  10 13c0 06       	>>>>  .byte lex+9f-(.+1)
  10 13c1 666C6164 	>>>>  .ascii "fladdr"
  10      6472
  10              	>>>> 9:
  10 13c7 00       	>>>>  .balign 4,0
  10              	>>>  .set lex,0
  10 13c8 00230000 	>>>  .int fladdr
  10              	>>>  .previous
  10              	>>  .balign 4,0
  10 22fc C0130000 	>>  .int _thread
  10              	> fladdr:
  10              	>  rpush lr
  10 2300 4CF804ED 	>>  str lr,[rp,#-4]!
  10 2304 FEF738F8 	>  bl dovar
  10 2308 00000000 	>  .int 0
  11              	  _var_ "fl>in", fltoin, 0  @ pointer to current line of file
  11              	>  header "fl>in",fltoin
  11              	>>  _header_ "fl>in",fltoin
  11              	>>>  .section .data
  11 13cc C0130000 	>>>  .int _thread
  11              	>>>  .set _thread,.
  11              	>>> 8:
  11              	>>>  hstring "fl>in"
  11 13d0 05       	>>>>  .byte lex+9f-(.+1)
  11 13d1 666C3E69 	>>>>  .ascii "fl>in"
  11      6E
  11              	>>>> 9:
  11 13d6 0000     	>>>>  .balign 4,0
  11              	>>>  .set lex,0
  11 13d8 10230000 	>>>  .int fltoin
  11              	>>>  .previous
  11              	>>  .balign 4,0
  11 230c D0130000 	>>  .int _thread
  11              	> fltoin:
  11              	>  rpush lr
  11 2310 4CF804ED 	>>  str lr,[rp,#-4]!
  11 2314 FEF730F8 	>  bl dovar
  11 2318 00000000 	>  .int 0
  12              	
  13              	@ ------------------------------------------------------------------------
  14              	@ total number of bytes of all loaded files
  15              	
  16              	  _constant_ "ktotal", ktotal, 0
  16              	>  header "ktotal",ktotal
  16              	>>  _header_ "ktotal",ktotal
  16              	>>>  .section .data
  16 13dc D0130000 	>>>  .int _thread
  16              	>>>  .set _thread,.
  16              	>>> 8:
  16              	>>>  hstring "ktotal"
  16 13e0 06       	>>>>  .byte lex+9f-(.+1)
  16 13e1 6B746F74 	>>>>  .ascii "ktotal"
  16      616C
  16              	>>>> 9:
  16 13e7 00       	>>>>  .balign 4,0
  16              	>>>  .set lex,0
  16 13e8 20230000 	>>>  .int ktotal
  16              	>>>  .previous
  16              	>>  .balign 4,0
  16 231c E0130000 	>>  .int _thread
  16              	> ktotal:
  16              	>  rpush lr
  16 2320 4CF804ED 	>>  str lr,[rp,#-4]!
  16 2324 FEF728F8 	>  bl dovar
  16 2328 00000000 	>  .int 0
  17              	
  18              	@ ------------------------------------------------------------------------
  19              	@ assert requested file was opend ok
  20              	
  21              	@       ( n1 --- )
  22              	
  23              	colon "?open", qopen
  23              	>  header "?open",qopen
  23              	>>  _header_ "?open",qopen
  23              	>>>  .section .data
  23 13ec E0130000 	>>>  .int _thread
  23              	>>>  .set _thread,.
  23              	>>> 8:
  23              	>>>  hstring "?open"
  23 13f0 05       	>>>>  .byte lex+9f-(.+1)
  23 13f1 3F6F7065 	>>>>  .ascii "?open"
  23      6E
  23              	>>>> 9:
  23 13f6 0000     	>>>>  .balign 4,0
  23              	>>>  .set lex,0
  23 13f8 30230000 	>>>  .int qopen
  23              	>>>  .previous
  23              	>>  .balign 4,0
  23 232c F0130000 	>>  .int _thread
  23              	> qopen:
  23 2330 AFF30080 	>  nop.w
  23              	>  rpush lr
  23 2334 4CF804ED 	>>  str lr,[rp,#-4]!
  24 2338 FEF700FE 	  bl zgreater               @ if fd is not zero
  25 233c FEF704F8 	  bl qexit                  @ then exit
  26 2340 FEF770FF 	  bl cr_                    @ else display file name
  27 2344 FFF79CFE 	  bl hhere
  28 2348 FEF7CAFA 	  bl count
  29 234c FEF7BCFE 	  bl type
  30 2350 FEF7A2FD 	  bl true                   @ and abort
  31 2354 FEF7B4FF 	  bl pabortq
  32              	  hstring " Open Error"
  32 2358 0B       	>  .byte lex+9f-(.+1)
  32 2359 204F7065 	>  .ascii " Open Error"
  32      6E204572 
  32      726F72
  32              	> 9:
  32              	>  .balign 4,0
  33              	
  34              	@ ------------------------------------------------------------------------
  35              	@ get file size from fd
  36              	
  37              	@   ( fd --- zize )
  38              	
  39              	colon "?fl-size", qfs
  39              	>  header "?fl-size",qfs
  39              	>>  _header_ "?fl-size",qfs
  39              	>>>  .section .data
  39 13fc F0130000 	>>>  .int _thread
  39              	>>>  .set _thread,.
  39              	>>> 8:
  39              	>>>  hstring "?fl-size"
  39 1400 08       	>>>>  .byte lex+9f-(.+1)
  39 1401 3F666C2D 	>>>>  .ascii "?fl-size"
  39      73697A65 
  39              	>>>> 9:
  39 1409 000000   	>>>>  .balign 4,0
  39              	>>>  .set lex,0
  39 140c 68230000 	>>>  .int qfs
  39              	>>>  .previous
  39              	>>  .balign 4,0
  39 2364 00140000 	>>  .int _thread
  39              	> qfs:
  39 2368 AFF30080 	>  nop.w
  39              	>  rpush lr
  39 236c 4CF804ED 	>>  str lr,[rp,#-4]!
  40              	  cliteral 2                @ SEEK_SET
  40 2370 01B4     	>  push { r0 }
  40 2372 0220     	>  movs r0,#2
  41              	  cliteral 0                @ offset 0 = start of file
  41 2374 01B4     	>  push { r0 }
  41 2376 0020     	>  movs r0,#0
  42 2378 FEF710F9 	  bl rot                    @ fd
  43 237c FEF78CF8 	  bl sys_lseek              @ execute lseek system call
  44              	  exit
  44              	>  rpop pc
  44 2380 5CF804FB 	>>  ldr pc,[rp],#4
  45              	
  46              	@ ------------------------------------------------------------------------
  47              	@ memory map a forth sourcew file
  48              	
  49              	colon "fmmap", fmmap
  49              	>  header "fmmap",fmmap
  49              	>>  _header_ "fmmap",fmmap
  49              	>>>  .section .data
  49 1410 00140000 	>>>  .int _thread
  49              	>>>  .set _thread,.
  49              	>>> 8:
  49              	>>>  hstring "fmmap"
  49 1414 05       	>>>>  .byte lex+9f-(.+1)
  49 1415 666D6D61 	>>>>  .ascii "fmmap"
  49      70
  49              	>>>> 9:
  49 141a 0000     	>>>>  .balign 4,0
  49              	>>>  .set lex,0
  49 141c 88230000 	>>>  .int fmmap
  49              	>>>  .previous
  49              	>>  .balign 4,0
  49 2384 14140000 	>>  .int _thread
  49              	> fmmap:
  49 2388 AFF30080 	>  nop.w
  49              	>  rpush lr
  49 238c 4CF804ED 	>>  str lr,[rp,#-4]!
  50 2390 FEF716F9 	  bl twotor
  51 2394 FEF7B6F8 	  bl dup
  52 2398 FFF7E6FF 	  bl qfs
  53 239c FEF7ECF8 	  bl tuck
  54              	  cliteral 0
  54 23a0 01B4     	>  push { r0 }
  54 23a2 0020     	>  movs r0,#0
  55 23a4 FEF700F9 	  bl drot
  56 23a8 FEF71AF9 	  bl tworto
  57 23ac FEF7F6F8 	  bl rot
  58              	  cliteral 0
  58 23b0 01B4     	>  push { r0 }
  58 23b2 0020     	>  movs r0,#0
  59 23b4 FEF778F8 	  bl sys_mmap2
  60 23b8 FEF7B6F8 	  bl swap
  61              	  exit
  61              	>  rpop pc
  61 23bc 5CF804FB 	>>  ldr pc,[rp],#4
  62              	
  63              	@ ------------------------------------------------------------------------
  64              	@ list giving order of varibles to save when nesting floads
  65              	
  66              	pushlist:
  67 23c0 38110000 	  .int tib
  68 23c4 F8100000 	  .int numtib
  69 23c8 C0220000 	  .int fd
  70 23cc 08110000 	  .int toin
  71 23d0 A8100000 	  .int refill
  72 23d4 10230000 	  .int fltoin
  73 23d8 00230000 	  .int fladdr
  74 23dc F0220000 	  .int flsize
  75 23e0 D0220000 	  .int linenum
  76 23e4 00000000 	  .int 0
  77              	
  78              	@ ------------------------------------------------------------------------
  79              	@ list giving order of variables to restore when unnesting floads
  80              	
  81              	poplist:
  82 23e8 D0220000 	  .int linenum
  83 23ec F0220000 	  .int flsize
  84 23f0 00230000 	  .int fladdr
  85 23f4 10230000 	  .int fltoin
  86 23f8 A8100000 	  .int refill
  87 23fc 08110000 	  .int toin
  88 2400 C0220000 	  .int fd
  89 2404 F8100000 	  .int numtib
  90 2408 38110000 	  .int tib
  91 240c 00000000 	  .int 0
  92              	
  93              	@ ------------------------------------------------------------------------
  94              	@ safe current input state when nesting floads
  95              	
  96              	save_state:
  97 2410 AFF25401 	  adr r1, pushlist
  98 2414 40F20002 	  movw r2, #:lower16:lsp    @ point to fload stack pointer variable
  99 2418 C0F20002 	  movt r2, #:upper16:lsp
 100 241c 9368     	  ldr r3, [r2, #BODY]       @ set r3 = fload stack address
 101              	0:
 102 241e 51F8044B 	  ldr r4, [r1], #4          @ get next item from above list
 103 2422 002C     	  cmp r4, #0                @ end of list?
 104 2424 1EBF     	  ittt ne
 105 2426 A568     	  ldrne r5, [r4, #BODY]     @ if not then fetch the item it points to
 106 2428 20C3     	  stmiane r3!, { r5 }       @ push item onto fload stack
 107 242a F8E7     	  bne 0b
 108              	
 109 242c 9360     	  str r3, [r2, #BODY]       @ update stack pointer
 110              	  next
 110 242e 7047     	>  bx lr
 111              	
 112              	@ ------------------------------------------------------------------------
 113              	
 114              	restore_state:
 115 2430 AFF24C01 	  adr r1, poplist
 116 2434 40F20002 	  movw r2, #:lower16:lsp    @ point to fload stack pointer variable
 117 2438 C0F20002 	  movt r2, #:upper16:lsp
 118 243c 9368     	  ldr r3, [r2, #BODY]       @ set r4 = fload stack address
 119              	0:
 120 243e 51F8044B 	  ldr r4, [r1], #4          @ get address of next variable to restore
 121 2442 002C     	  cmp r4, #0                @ end of list?
 122              	
 123 2444 1EBF     	  ittt ne
 124 2446 53F8045D 	  ldmdbne r3!, { r5 }       @ pop item off of fload stack
 125 244a A560     	  strne r5, [r4, #BODY]     @ restore saved variable
 126 244c F7E7     	  bne 0b
 127              	
 128 244e 9360     	  str r3, [r2, #BODY]       @ update stack pointer
 129              	  next
 129 2450 7047     	>  bx lr
 130              	
 131              	@ ------------------------------------------------------------------------
 132              	
 133              	colon "end-fload", end_fload
 133              	>  header "end-fload",end_fload
 133              	>>  _header_ "end-fload",end_fload
 133              	>>>  .section .data
 133 1420 14140000 	>>>  .int _thread
 133              	>>>  .set _thread,.
 133              	>>> 8:
 133              	>>>  hstring "end-fload"
 133 1424 09       	>>>>  .byte lex+9f-(.+1)
 133 1425 656E642D 	>>>>  .ascii "end-fload"
 133      666C6F61 
 133      64
 133              	>>>> 9:
 133 142e 0000     	>>>>  .balign 4,0
 133              	>>>  .set lex,0
 133 1430 58240000 	>>>  .int end_fload
 133              	>>>  .previous
 133 2452 0000     	>>  .balign 4,0
 133 2454 24140000 	>>  .int _thread
 133              	> end_fload:
 133 2458 AFF30080 	>  nop.w
 133              	>  rpush lr
 133 245c 4CF804ED 	>>  str lr,[rp,#-4]!
 134 2460 FFF746FF 	  bl flsize
 135 2464 FEF74EF8 	  bl dup
 136 2468 FEF7E2F9 	  bl zplusstoreto
 137 246c FFF758FF 	  bl ktotal
 138 2470 FFF746FF 	  bl fladdr
 139 2474 FEF720F8 	  bl sys_munmap
 140 2478 FFF722FF 	  bl fd
 141 247c FEF704F8 	  bl sys_close
 142 2480 FEF764F8 	  bl twodrop
 143 2484 FFF7D4FF 	  bl restore_state
 144 2488 FEF7F6F9 	  bl zdecrto
 145 248c FFF728FF 	  bl floads
 146              	  exit
 146              	>  rpop pc
 146 2490 5CF804FB 	>>  ldr pc,[rp],#4
 147              	
 148              	@ ------------------------------------------------------------------------
 149              	
 150              	colon "abort-fload", abort_fload
 150              	>  header "abort-fload",abort_fload
 150              	>>  _header_ "abort-fload",abort_fload
 150              	>>>  .section .data
 150 1434 24140000 	>>>  .int _thread
 150              	>>>  .set _thread,.
 150              	>>> 8:
 150              	>>>  hstring "abort-fload"
 150 1438 0B       	>>>>  .byte lex+9f-(.+1)
 150 1439 61626F72 	>>>>  .ascii "abort-fload"
 150      742D666C 
 150      6F6164
 150              	>>>> 9:
 150              	>>>>  .balign 4,0
 150              	>>>  .set lex,0
 150 1444 98240000 	>>>  .int abort_fload
 150              	>>>  .previous
 150              	>>  .balign 4,0
 150 2494 38140000 	>>  .int _thread
 150              	> abort_fload:
 150 2498 AFF30080 	>  nop.w
 150              	>  rpush lr
 150 249c 4CF804ED 	>>  str lr,[rp,#-4]!
 151 24a0 FFF716FF 	  bl linenum
 152 24a4 FFF7D8FF 	  bl end_fload
 153 24a8 FEF7B2F9 	  bl zstoreto
 154 24ac FFF710FF 	  bl linenum
 155              	  exit
 155              	>  rpop pc
 155 24b0 5CF804FB 	>>  ldr pc,[rp],#4
 156              	
 157              	@ ------------------------------------------------------------------------
 158              	
 159              	colon "(flrefill)", pflrefill
 159              	>  header "(flrefill)",pflrefill
 159              	>>  _header_ "(flrefill)",pflrefill
 159              	>>>  .section .data
 159 1448 38140000 	>>>  .int _thread
 159              	>>>  .set _thread,.
 159              	>>> 8:
 159              	>>>  hstring "(flrefill)"
 159 144c 0A       	>>>>  .byte lex+9f-(.+1)
 159 144d 28666C72 	>>>>  .ascii "(flrefill)"
 159      6566696C 
 159      6C29
 159              	>>>> 9:
 159 1457 00       	>>>>  .balign 4,0
 159              	>>>  .set lex,0
 159 1458 B8240000 	>>>  .int pflrefill
 159              	>>>  .previous
 159              	>>  .balign 4,0
 159 24b4 4C140000 	>>  .int _thread
 159              	> pflrefill:
 159 24b8 AFF30080 	>  nop.w
 159              	>  rpush lr
 159 24bc 4CF804ED 	>>  str lr,[rp,#-4]!
 160 24c0 FEF7C8F9 	  bl zincrto                @ count total lines interpreted
 161 24c4 FFF704FF 	  bl linenum
 162 24c8 FFF722FF 	  bl fltoin                 @ set tib = address of next line of file
 163 24cc FEF71AF8 	  bl dup
 164 24d0 FEF79EF9 	  bl zstoreto
 165 24d4 FEF730FE 	  bl tib
 166              	@ TODO: make this #chars left in file not 1023
 167              	  wliteral 1024             @ scan for end of line
 167 24d8 01B4     	>  push { r0 }
 167 24da 40F20040 	>  movw r0,#1024
 168              	  cliteral 0x0a
 168 24de 01B4     	>  push { r0 }
 168 24e0 0A20     	>  movs r0,#0x0a
 169 24e2 FFF713F8 	  bl scan
 170 24e6 FEF7FDFC 	  bl zequals                @ coder needs a new ENTER key
 171 24ea FEF7E9FE 	  bl pabortq
 172              	  hstring "Fload Line Too Long"
 172 24ee 13       	>  .byte lex+9f-(.+1)
 172 24ef 466C6F61 	>  .ascii "Fload Line Too Long"
 172      64204C69 
 172      6E652054 
 172      6F6F204C 
 172      6F6E67
 172              	> 9:
 172 2502 0000     	>  .balign 4,0
 173 2504 FDF7FEFF 	  bl dup
 174 2508 FEF774FB 	  bl oneplus                @ point past end of line
 175 250c FEF70CF8 	  bl swap
 176 2510 FFF7FEFE 	  bl fltoin                 @ calculate length of line
 177 2514 FEF736FB 	  bl minus
 178 2518 FEF77AF9 	  bl zstoreto
 179 251c FEF7ECFD 	  bl numtib                 @ set #tib = length of line
 180 2520 FEF776F9 	  bl zstoreto               @ point fl>in to next line to interpret
 181 2524 FFF7F4FE 	  bl fltoin
 182 2528 FEF7CAF9 	  bl zoffto
 183 252c FEF7ECFD 	  bl toin                 @ reset interpret point on new line
 184              	  exit
 184              	>  rpop pc
 184 2530 5CF804FB 	>>  ldr pc,[rp],#4
 185              	
 186              	@ ------------------------------------------------------------------------
 187              	
 188              	colon "flrefill", flrefill
 188              	>  header "flrefill",flrefill
 188              	>>  _header_ "flrefill",flrefill
 188              	>>>  .section .data
 188 145c 4C140000 	>>>  .int _thread
 188              	>>>  .set _thread,.
 188              	>>> 8:
 188              	>>>  hstring "flrefill"
 188 1460 08       	>>>>  .byte lex+9f-(.+1)
 188 1461 666C7265 	>>>>  .ascii "flrefill"
 188      66696C6C 
 188              	>>>> 9:
 188 1469 000000   	>>>>  .balign 4,0
 188              	>>>  .set lex,0
 188 146c 38250000 	>>>  .int flrefill
 188              	>>>  .previous
 188              	>>  .balign 4,0
 188 2534 60140000 	>>  .int _thread
 188              	> flrefill:
 188 2538 AFF30080 	>  nop.w
 188              	>  rpush lr
 188 253c 4CF804ED 	>>  str lr,[rp,#-4]!
 189 2540 FFF7DEFE 	  bl fladdr                 @ if file address plus file size
 190 2544 FFF7D4FE 	  bl flsize
 191 2548 FEF716FB 	  bl plus
 192 254c FFF7E0FE 	  bl fltoin                 @ is equal to our file parse address
 193 2550 FEF7DCFC 	  bl equals
 194 2554 FFF78AFC 	  bl qbranch
 195 2558 0B00     	  .hword (1f - .) + 1
 196 255a FFF77DFF 	  bl end_fload              @ then were done with this file
 197              	  exit
 197              	>  rpop pc
 197 255e 5CF804FB 	>>  ldr pc,[rp],#4
 198              	1:
 199 2562 FFF7A9FF 	  bl pflrefill              @ else refill from this file
 200              	  exit
 200              	>  rpop pc
 200 2566 5CF804FB 	>>  ldr pc,[rp],#4
 201              	
 202              	@ ------------------------------------------------------------------------
 203              	@ set refill to use floads refill mechanism
 204              	
 205              	@    ( fd map-addr size --- )
 206              	
 207              	colon "fstate", fstate
 207              	>  header "fstate",fstate
 207              	>>  _header_ "fstate",fstate
 207              	>>>  .section .data
 207 1470 60140000 	>>>  .int _thread
 207              	>>>  .set _thread,.
 207              	>>> 8:
 207              	>>>  hstring "fstate"
 207 1474 06       	>>>>  .byte lex+9f-(.+1)
 207 1475 66737461 	>>>>  .ascii "fstate"
 207      7465
 207              	>>>> 9:
 207 147b 00       	>>>>  .balign 4,0
 207              	>>>  .set lex,0
 207 147c 70250000 	>>>  .int fstate
 207              	>>>  .previous
 207 256a 0000     	>>  .balign 4,0
 207 256c 74140000 	>>  .int _thread
 207              	> fstate:
 207 2570 AFF30080 	>  nop.w
 207              	>  rpush lr
 207 2574 4CF804ED 	>>  str lr,[rp,#-4]!
 208 2578 01B4     	  push { r0 }
 209 257a AFF24400 	  adr r0, flrefill          @ make fload-refill the refill method
 210 257e FEF747F9 	  bl zstoreto
 211 2582 FEF791FD 	  bl refill
 212 2586 FEF743F9 	  bl zstoreto               @ remember size of file mapping
 213 258a FFF7B1FE 	  bl flsize
 214 258e FDF7B9FF 	  bl dup
 215 2592 FEF73DF9 	  bl zstoreto               @ set address of mapping
 216 2596 FFF7B3FE 	  bl fladdr
 217 259a FEF739F9 	  bl zstoreto
 218 259e FFF7B7FE 	  bl fltoin
 219 25a2 FEF735F9 	  bl zstoreto
 220 25a6 FFF78BFE 	  bl fd                     @ save file descriptor
 221 25aa FEF753F9 	  bl zincrto
 222 25ae FFF797FE 	  bl floads
 223 25b2 FEF785F9 	  bl zoffto                 @ reset current line numbr
 224 25b6 FFF78BFE 	  bl linenum
 225              	  exit
 225              	>  rpop pc
 225 25ba 5CF804FB 	>>  ldr pc,[rp],#4
 226              	
 227              	@ ------------------------------------------------------------------------
 228              	
 229              	colon "?fdepth", qfdepth
 229              	>  header "?fdepth",qfdepth
 229              	>>  _header_ "?fdepth",qfdepth
 229              	>>>  .section .data
 229 1480 74140000 	>>>  .int _thread
 229              	>>>  .set _thread,.
 229              	>>> 8:
 229              	>>>  hstring "?fdepth"
 229 1484 07       	>>>>  .byte lex+9f-(.+1)
 229 1485 3F666465 	>>>>  .ascii "?fdepth"
 229      707468
 229              	>>>> 9:
 229              	>>>>  .balign 4,0
 229              	>>>  .set lex,0
 229 148c C4250000 	>>>  .int qfdepth
 229              	>>>  .previous
 229 25be 0000     	>>  .balign 4,0
 229 25c0 84140000 	>>  .int _thread
 229              	> qfdepth:
 229 25c4 AFF30080 	>  nop.w
 229              	>  rpush lr
 229 25c8 4CF804ED 	>>  str lr,[rp,#-4]!
 230 25cc FFF788FE 	  bl floads                 @ nesting floads deeper than 2 is dumb
 231              	  cliteral 5
 231 25d0 01B4     	>  push { r0 }
 231 25d2 0520     	>  movs r0,#5
 232 25d4 FEF79AFC 	  bl equals
 233 25d8 FEF772FE 	  bl pabortq
 234              	  hstring "Floads Nested Too Deep"
 234 25dc 16       	>  .byte lex+9f-(.+1)
 234 25dd 466C6F61 	>  .ascii "Floads Nested Too Deep"
 234      6473204E 
 234      65737465 
 234      6420546F 
 234      6F204465 
 234              	> 9:
 234 25f3 00       	>  .balign 4,0
 235              	  exit
 235              	>  rpop pc
 235 25f4 5CF804FB 	>>  ldr pc,[rp],#4
 236              	
 237              	@ ------------------------------------------------------------------------
 238              	
 239              	colon "(fload)", pfload
 239              	>  header "(fload)",pfload
 239              	>>  _header_ "(fload)",pfload
 239              	>>>  .section .data
 239 1490 84140000 	>>>  .int _thread
 239              	>>>  .set _thread,.
 239              	>>> 8:
 239              	>>>  hstring "(fload)"
 239 1494 07       	>>>>  .byte lex+9f-(.+1)
 239 1495 28666C6F 	>>>>  .ascii "(fload)"
 239      616429
 239              	>>>> 9:
 239              	>>>>  .balign 4,0
 239              	>>>  .set lex,0
 239 149c FC250000 	>>>  .int pfload
 239              	>>>  .previous
 239              	>>  .balign 4,0
 239 25f8 94140000 	>>  .int _thread
 239              	> pfload:
 239 25fc AFF30080 	>  nop.w
 239              	>  rpush lr
 239 2600 4CF804ED 	>>  str lr,[rp,#-4]!
 240 2604 FDF738FF 	  bl sys_open3              @ attempt to open specified file
 241 2608 FDF77CFF 	  bl dup                    @ abort if not opened
 242 260c FFF790FE 	  bl qopen
 243 2610 FDF778FF 	  bl dup
 244              	  cliteral 2                @ map private
 244 2614 01B4     	>  push { r0 }
 244 2616 0220     	>  movs r0,#2
 245              	  cliteral 3                @ prot read
 245 2618 01B4     	>  push { r0 }
 245 261a 0320     	>  movs r0,#3
 246 261c FFF7B4FE 	  bl fmmap                  @ memory map the file
 247 2620 FFF7F6FE 	  bl save_state             @ save state of previous fload if any
 248 2624 FFF7A4FF 	  bl fstate                 @ set state to floading
 249 2628 FEF73EFD 	  bl refill                 @ do initial refill for fload
 250              	  exit
 250              	>  rpop pc
 250 262c 5CF804FB 	>>  ldr pc,[rp],#4
 251              	
 252              	@ ------------------------------------------------------------------------
 253              	
 254              	colon "fload", fload
 254              	>  header "fload",fload
 254              	>>  _header_ "fload",fload
 254              	>>>  .section .data
 254 14a0 94140000 	>>>  .int _thread
 254              	>>>  .set _thread,.
 254              	>>> 8:
 254              	>>>  hstring "fload"
 254 14a4 05       	>>>>  .byte lex+9f-(.+1)
 254 14a5 666C6F61 	>>>>  .ascii "fload"
 254      64
 254              	>>>> 9:
 254 14aa 0000     	>>>>  .balign 4,0
 254              	>>>  .set lex,0
 254 14ac 34260000 	>>>  .int fload
 254              	>>>  .previous
 254              	>>  .balign 4,0
 254 2630 A4140000 	>>  .int _thread
 254              	> fload:
 254 2634 AFF30080 	>  nop.w
 254              	>  rpush lr
 254 2638 4CF804ED 	>>  str lr,[rp,#-4]!
 255 263c FFF7C2FF 	  bl qfdepth                @ assert floads not nested too deep
 256              	  cliteral 0                @ file permissions and flags
 256 2640 01B4     	>  push { r0 }
 256 2642 0020     	>  movs r0,#0
 257 2644 FDF75EFF 	  bl dup
 258 2648 FEF71EFD 	  bl bl_                    @ parse in file name
 259 264c FFF71CF9 	  bl word_
 260 2650 FFF716FD 	  bl hhere                  @ make it ascii z
 261 2654 FEF744F9 	  bl count
 262 2658 FEF752FA 	  bl s2z
 263 265c FFF7CEFF 	  bl pfload
 264              	  exit
 264              	>  rpop pc
 264 2660 5CF804FB 	>>  ldr pc,[rp],#4
 265              	
 266              	@ ========================================================================
 331              	
 332              	  _root_
 332              	>  .if voc!=root
 332              	>  .if voc==forth
 332              	>  .set forth_link,_thread
 332              	>  .endif
 332              	> 
 332              	>  .if voc==compiler
 332              	>  .set comp_link,_thread
 332              	>  .endif
 332              	> 
 332              	>  .set voc,root
 332              	>  .set _thread,root_link
 332              	>  .endif
 333              	
 334              	  .include "reloc.s"        @ header relocation
   1              	@ reloc.s     - relocate word headers (on load and fsave)
   2              	@ ------------------------------------------------------------------------
   3              	
   4              	@ when forth loads the memory map looks like the following
   5              	
   6              	@ +------+------+-------------+
   7              	@ | list | head | empty space |
   8              	@ +------+------+-------------+
   9              	@
  10              	@ but we need it to look like this
  11              	@
  12              	@ +------+-------+------+-------+
  13              	@ | list | empty | head | empty |
  14              	@ +------+-------+------+-------+
  15              	@
  16              	@ so we can append new code to list space and new headers to head space
  17              	@ when we save out the kernel we need to relocate everything back to the
  18              	@ compacted map state.
  19              	
  20              	@ ------------------------------------------------------------------------
  21              	
  22              	@ r5  = source
  23              	@ r6  = destination
  24              	@ r7  = address of last header
  25              	@ r8  = header we just relocated
  26              	@ r9  = location header was moved to
  27              	
  28              	@ ------------------------------------------------------------------------
  29              	
  30              	@ we just relocated a header.  if the relocated headers original address
  31              	@ is pointed to by a thread of any vocabulary then we need to adjust
  32              	@ that thread pointer within the vocabulary to reflect the new address of
  33              	@ the header
  34              	
  35              	rethread:
  36 2664 95A2     	  adr r2, voclink           @ point r2 at list of vocabularies
  37 2666 9268     	  ldr r2, [r2, #BODY]
  38              	0:
  39 2668 0832     	  adds r2, r2, #BODY
  40 266a 4023     	  movs r3, #64              @ threads per vocabulary
  41              	1:
  42 266c 1468     	  ldr r4, [r2]              @ compare each thread of vocabulary with
  43 266e 4445     	  cmp r4, r8                @ source address of header we just relocated
  44 2670 08BF     	  it eq
  45 2672 C2F80090 	  streq r9, [r2]            @ if equal, set thread pointing to destination
  46 2676 05D0     	  beq 2f                    @ and break out of loop
  47 2678 0432     	  adds r2, r2, #4           @ else point to next thread in vocab
  48 267a 013B     	  subs r3, r3, #1           @ and loop till all 64 threads are checked
  49 267c F6D1     	  bne 1b
  50 267e 1268     	  ldr r2, [r2]              @ reached end of vocab, point to next vocab
  51 2680 002A     	  cmp r2, #0                @ in chain and loop if not at end of chain
  52 2682 F1D1     	  bne 0b
  53              	2:
  54 2684 7047     	  bx lr
  55              	
  56              	@ ------------------------------------------------------------------------
  57              	@ relocate one header
  58              	
  59              	@   r5 = source
  60              	@   r6 = destination
  61              	@   r9 = nfa of destination
  62              	
  63              	@ returns
  64              	@   r8 = address of next header to relocate
  65              	
  66              	hreloc:
  67 2686 2968     	  ldr r1, [r5]              @ look in lfa of header to relocate
  68 2688 0029     	  cmp r1, #0                @ is there a previous header in the chain?
  69 268a 18BF     	  it ne
  70 268c 51F8041C 	  ldrne r1, [r1, #-4]       @ yes. fetch the relocated address of prev hdr
  71              	
  72 2690 46F8041B 	  str r1, [r6], #4          @ write new lfa to destination header
  73 2694 45F8046B 	  str r6, [r5], #4          @ save relocated address of current header
  74              	
  75 2698 A846     	  mov r8, r5                @ used by caller to check for reloc complete
  76 269a B146     	  mov r9, r6                @ save dst nfa address (used below)
  77              	
  78 269c 2978     	  ldrb r1, [r5]             @ get nfa count byte
  79 269e 0B46     	  mov r3, r1                @ make copy of lex bits
  80 26a0 01F03F01 	  and r1, r1, #LEXMASK      @ and mask them out of the length counter
  81 26a4 0131     	  adds r1, r1, #1           @ make length include length byte
  82              	
  83              	1:                          @ relocate headers nfa
  84 26a6 15F8012B 	  ldrb r2, [r5], #1
  85 26aa 06F8012B 	  strb r2, [r6], #1
  86 26ae 0139     	  subs r1, r1, #1
  87 26b0 F9D1     	  bne 1b
  88              	
  89 26b2 0335     	  adds r5, r5, #3            @ align src and dst to the cell
  90 26b4 25F00305 	  bic r5, r5, #3
  91 26b8 0336     	  adds r6, r6, #3
  92 26ba 26F00306 	  bic r6, r6, #3
  93              	
  94 26be 55F8041B 	  ldr r1, [r5], #4          @ relocate headers CFA pointer
  95 26c2 46F8041B 	  str r1, [r6], #4
  96 26c6 13F04003 	  ands r3, #0x40            @ test lex bits saved above. is this an alias?
  97 26ca 08BF     	  it eq
  98 26cc 41F8049C 	  streq r9, [r1, #-4]       @ if not an alias, adjust NFA pointer at CFA-4
  99 26d0 7047     	  bx lr                     @ to point to the relocated NFA
 100              	
 101              	@ ------------------------------------------------------------------------
 102              	@ relocate all headers
 103              	
 104              	relocate:
 105 26d2 00B5     	  push { lr }
 106              	0:
 107 26d4 FFF7D7FF 	  bl hreloc                 @ relocate one header
 108 26d8 FFF7C4FF 	  bl rethread               @ adjust vocab thread need be
 109 26dc B845     	  cmp r8, r7                @ did we just relocate the LAST header?
 110 26de F9D1     	  bne 0b                    @ loop till done blah blah
 111 26e0 00BD     	  pop { pc }
 112              	
 113              	@ ------------------------------------------------------------------------
 114              	@ special verison of unpack for kernel
 115              	
 116              	kunpack:
 117              	  rpush lr
 117 26e2 4CF804ED 	>  str lr,[rp,#-4]!
 118 26e6 40F20005 	  movw r5, #:lower16:unpack
 119 26ea C0F20005 	  movt r5, #:upper16:unpack
 120 26ee 0FF23006 	  adr r6, eunpack
 121 26f2 AE60     	  str r6, [r5, #BODY]
 122              	
 123 26f4 AFF28865 	  adr r5, dp               @ point to source data
 124 26f8 AD68     	  ldr r5, [r5, #BODY]
 125 26fa 40F20006 	  movw r6, #:lower16:bhead @ point to destination address
 126 26fe C0F20006 	  movt r6, #:upper16:bhead
 127 2702 B668     	  ldr r6, [r6, #BODY]
 128 2704 AFF67047 	  adr r7, last             @ point to last header
 129 2708 BF68     	  ldr r7, [r7, #BODY]
 130              	
 131 270a FFF7E2FF 	  bl relocate               @ relocate all headers
 132              	
 133 270e AFF29061 	  adr r1, hp               @ set address of hhere
 134 2712 8E60     	  str r6, [r1, #BODY]
 135 2714 AFF68041 	  adr r1, last
 136 2718 C1F80890 	  str r9, [r1, #BODY]
 137              	  exit
 137              	>  rpop pc
 137 271c 5CF804FB 	>>  ldr pc,[rp],#4
 138              	
 139              	@ ------------------------------------------------------------------------
 140              	@ version of unpack used on extended kernel
 141              	
 142              	eunpack:
 143              	  rpush lr
 143 2720 4CF804ED 	>  str lr,[rp,#-4]!
 144 2724 40F20005 	  movw r5, #:lower16:turnkeyd @ turnkeyd apps have no headers to relocate
 145 2728 C0F20005 	  movt r5, #:upper16:turnkeyd
 146 272c AD68     	  ldr r5, [r5, #BODY]
 147 272e 002D     	  cmp r5, #0
 148 2730 18BF     	  it ne
 149 2732 5CF804FB 	  ldmfdne rp!, { pc }
 150              	
 151 2736 AFF2C865 	  adr r5, dp                @ point r5 to where headers got relocated to
 152 273a AD68     	  ldr r5, [r5, #BODY]
 153 273c 40F20006 	  movw r6, #:lower16:bhead  @ point to their real home
 154 2740 C0F20006 	  movt r6, #:upper16:bhead
 155 2744 B668     	  ldr r6, [r6, #BODY]
 156 2746 AFF2C867 	  adr r7, hp                @ point to end of relocated headers
 157 274a D7F80880 	  ldr r8, [r7, #BODY]
 158              	
 159              	0:
 160 274e 15F8010B 	  ldrb r0, [r5], #1
 161 2752 06F8010B 	  strb r0, [r6], #1
 162 2756 4545     	  cmp r5, r8
 163 2758 F9D1     	  bne 0b
 164              	
 165 275a BE60     	  str r6, [r7, #BODY]       @ set real head space pointer address
 166              	
 167              	  next
 167 275c 7047     	>  bx lr
 168              	
 169              	@ ------------------------------------------------------------------------
 170              	@ relocate all headers to here, set hp = end of relocated headers
 171              	
 172              	code "pack", pack
 172              	>  header "pack",pack
 172              	>>  _header_ "pack",pack
 172              	>>>  .section .data
 172 14b0 00000000 	>>>  .int _thread
 172              	>>>  .set _thread,.
 172              	>>> 8:
 172              	>>>  hstring "pack"
 172 14b4 04       	>>>>  .byte lex+9f-(.+1)
 172 14b5 7061636B 	>>>>  .ascii "pack"
 172              	>>>> 9:
 172 14b9 000000   	>>>>  .balign 4,0
 172              	>>>  .set lex,0
 172 14bc 64270000 	>>>  .int pack
 172              	>>>  .previous
 172 275e 0000     	>>  .balign 4,0
 172 2760 B4140000 	>>  .int _thread
 172              	> pack:
 173 2764 00B5     	  push { lr }               @ save return address
 174              	
 175 2766 AFF24800 	  adr r0, eunpack           @ make unpack run extended unpack
 176 276a 40F20001 	  movw r1, #:lower16:unpack @ the reverse of this pack
 177 276e C0F20001 	  movt r1, #:upper16:unpack
 178 2772 8860     	  str r0, [r1, #BODY]
 179              	
 180 2774 40F20005 	  movw r5, #:lower16:bhead  @ point r5 at bottom of head space
 181 2778 C0F20005 	  movt r5, #:upper16:bhead
 182              	
 183 277c AD68     	  ldr r5, [r5, #BODY]
 184 277e AFF21076 	  adr r6, dp                @ point r6 to end of dictionary space
 185 2782 B668     	  ldr r6, [r6, #BODY]
 186 2784 AFF20877 	  adr r7, hp                @ point r7 to head space variable
 187 2788 D7F80880 	  ldr r8, [r7, #BODY]       @ point r8 at end of head space
 188              	
 189              	0:
 190 278c 15F8010B 	  ldrb r0, [r5], #1         @ copy data from head space to end of
 191 2790 06F8010B 	  strb r0, [r6], #1         @ dictionary
 192 2794 4545     	  cmp r5, r8                @ reached end of head space?
 193 2796 F9D1     	  bne 0b
 194              	
 195 2798 BE60     	  str r6, [r7, #BODY]
 196              	
 197 279a 00BD     	  pop { pc }
 198              	
 199              	@ ========================================================================
 335              	  .include "rehash.s"       @ one time fixup
   1              	@ rehash.s  - this file will be disappeared as soon as im meta compiling
   2              	@ ------------------------------------------------------------------------
   3              	
   4              	@ ------------------------------------------------------------------------
   5              	@ i only need this because the gnu assembler is brain dead
   6              	
   7              	  _var_ "voc", voc, 0
   7              	>  header "voc",voc
   7              	>>  _header_ "voc",voc
   7              	>>>  .section .data
   7 14c0 B4140000 	>>>  .int _thread
   7              	>>>  .set _thread,.
   7              	>>> 8:
   7              	>>>  hstring "voc"
   7 14c4 03       	>>>>  .byte lex+9f-(.+1)
   7 14c5 766F63   	>>>>  .ascii "voc"
   7              	>>>> 9:
   7              	>>>>  .balign 4,0
   7              	>>>  .set lex,0
   7 14c8 082C0000 	>>>  .int voc
   7              	>>>  .previous
   7              	>>  .balign 4,0
   7 279c C4140000 	>>  .int _thread
   7              	> voc:
   7              	>  rpush lr
   7 27a0 4CF804ED 	>>  str lr,[rp,#-4]!
   7 27a4 FDF7E8FD 	>  bl dovar
   7 27a8 00000000 	>  .int 0
   8              	
   9              	@ ------------------------------------------------------------------------
  10              	@ store header h1 in vocab in correct hashed thread
  11              	
  12              	@    ( h1 --- )
  13              	
  14              	chain:
  15              	  rpush lr
  15 27ac 4CF804ED 	>  str lr,[rp,#-4]!
  16 27b0 FDF71EFF 	  bl duptor                 @ keep copy of header to rehash
  17 27b4 FFF70AFD 	  bl hash                   @ get hash value for this header
  18 27b8 FFF7F2FF 	  bl voc
  19 27bc FEF7DCF9 	  bl plus                   @ point to thread in scratchpad
  20 27c0 FDF7A0FE 	  bl dup
  21 27c4 FEF700F8 	  bl fetch                  @ fetch header from this thread
  22 27c8 FDF71EFF 	  bl rfetch                 @ get header were linking back
  23 27cc FEF72EFA 	  bl ntolink                @ point to its LFA
  24 27d0 FEF702F8 	  bl store                  @ link header to one that was in the thread
  25 27d4 FDF7FEFE 	  bl rto
  26 27d8 FDF7A6FE 	  bl swap
  27 27dc FDF7FCFF 	  bl store                  @ store our header in the thread
  28              	  exit
  28              	>  rpop pc
  28 27e0 5CF804FB 	>>  ldr pc,[rp],#4
  29              	
  30              	@ ------------------------------------------------------------------------
  31              	@ rehash one complete vocabulary
  32              	
  33              	@    ( voc[] --- )
  34              	
  35              	prehash:
  36              	  rpush lr
  36 27e4 4CF804ED 	>  str lr,[rp,#-4]!
  37 27e8 FFF7DAFF 	  bl voc
  38              	
  39 27ec FDF78AFE 	  bl dup
  40 27f0 FDF7EAFF 	  bl fetch                  @ fetch chain on first thread of vocab
  41 27f4 FDF798FE 	  bl swap                   @ erase first thread. entire vocabulary
  42 27f8 FEF7B2F8 	  bl off
  43              	
  44              	  @   ( thread --- )
  45              	
  46              	1:
  47 27fc FDF782FE 	  bl dup                    @ next header in chain
  48 2800 FEF714FA 	  bl ntolink
  49 2804 FDF7E0FF 	  bl fetch
  50 2808 FDF78EFE 	  bl swap
  51 280c FFF7CEFF 	  bl chain                  @ link this into correct thread of #tmp
  52 2810 FDF772FE 	  bl qdup                   @ loop till end of chain
  53 2814 FEF766FB 	  bl zequals
  54 2818 FFF728FB 	  bl qbranch
  55 281c E1FF     	  .hword (1b - .) + 1
  56              	  exit
  56              	>  rpop pc
  56 281e 5CF804FB 	>>  ldr pc,[rp],#4
  57              	
  58              	@ ------------------------------------------------------------------------
  59              	
  60              	_rehash:
  61              	  rpush lr
  61 2822 4CF804ED 	>  str lr,[rp,#-4]!
  62              	
  63 2826 40F20000 	  movw r0, #:lower16:rehash @ neuter rehash
  64 282a C0F20000 	  movt r0, #:upper16:rehash
  65 282e 40F20001 	  movw r1, #:lower16:noop
  66 2832 C0F20001 	  movt r1, #:upper16:noop
  67 2836 8160     	  str r1, [r0, #BODY]
  68              	
  69 2838 00F040F8 	  bl voclink                @ point to last vocabulary defined
  70              	1:
  71 283c FFF736FC 	  bl tobody                 @ fetch pointer to vocs hash buffer
  72 2840 FDF7E6FF 	  bl zstoreto
  73 2844 FFF7ACFF 	  bl voc
  74              	
  75 2848 FFF7CCFF 	  bl prehash                @ rehash this vocabulary
  76              	
  77 284c FFF7A8FF 	  bl voc                    @ get address of next header in chain
  78 2850 00F054F8 	  bl numthreads
  79 2854 FDF782FF 	  bl cells_fetch
  80 2858 FDF74EFE 	  bl qdup                   @ loop till no more vocabularies in chain
  81 285c FEF742FB 	  bl zequals
  82 2860 FFF704FB 	  bl qbranch                @ until
  83 2864 D9FF     	  .hword (1b - .) + 1
  84              	  exit
  84              	>  rpop pc
  84 2866 5CF804FB 	>>  ldr pc,[rp],#4
  85              	
  86              	@ ========================================================================
 336              	
 337              	  @ vocabs.s MUST be the last file included
 338              	
 339              	  .include "vocabs.s"       @ vocabulary manipulation
   1              	@ vocabs.s
   2              	@ ------------------------------------------------------------------------
   3              	
   4              	@ ------------------------------------------------------------------------
   5              	@ the default context stack = the search order
   6              	
   7              	  _variable_ "context0", context0, 0
   7              	>  header "context0",context0
   7              	>>  _header_ "context0",context0
   7              	>>>  .section .data
   7 14cc C4140000 	>>>  .int _thread
   7              	>>>  .set _thread,.
   7              	>>> 8:
   7              	>>>  hstring "context0"
   7 14d0 08       	>>>>  .byte lex+9f-(.+1)
   7 14d1 636F6E74 	>>>>  .ascii "context0"
   7      65787430 
   7              	>>>> 9:
   7 14d9 000000   	>>>>  .balign 4,0
   7              	>>>  .set lex,0
   7 14dc 70280000 	>>>  .int context0
   7              	>>>  .previous
   7 286a 0000     	>>  .balign 4,0
   7 286c D0140000 	>>  .int _thread
   7              	> context0:
   7              	>  rpush lr
   7 2870 4CF804ED 	>>  str lr,[rp,#-4]!
   7 2874 FDF78AFD 	>  bl dovariable
   7 2878 00000000 	>  .int 0
   8 287c 00000000 	  .int 0, 0, 0, 0, 0, 0
   8      00000000 
   8      00000000 
   8      00000000 
   8      00000000 
   9 2894 00000000 	  .int 0, 0, 0, 0, 0, 0
   9      00000000 
   9      00000000 
   9      00000000 
   9      00000000 
  10 28ac E8290000 	  .int forth
  11 28b0 F82A0000 	  .int compiler
  12 28b4 082C0000 	  .int root
  13              	
  14              	@ ------------------------------------------------------------------------
  15              	
  16              	  _var_ "voclink", voclink, root
  16              	>  header "voclink",voclink
  16              	>>  _header_ "voclink",voclink
  16              	>>>  .section .data
  16 14e0 D0140000 	>>>  .int _thread
  16              	>>>  .set _thread,.
  16              	>>> 8:
  16              	>>>  hstring "voclink"
  16 14e4 07       	>>>>  .byte lex+9f-(.+1)
  16 14e5 766F636C 	>>>>  .ascii "voclink"
  16      696E6B
  16              	>>>> 9:
  16              	>>>>  .balign 4,0
  16              	>>>  .set lex,0
  16 14ec BC280000 	>>>  .int voclink
  16              	>>>  .previous
  16              	>>  .balign 4,0
  16 28b8 E4140000 	>>  .int _thread
  16              	> voclink:
  16              	>  rpush lr
  16 28bc 4CF804ED 	>>  str lr,[rp,#-4]!
  16 28c0 FDF75AFD 	>  bl dovar
  16 28c4 082C0000 	>  .int root
  17              	  _var_ "current", current, forth
  17              	>  header "current",current
  17              	>>  _header_ "current",current
  17              	>>>  .section .data
  17 14f0 E4140000 	>>>  .int _thread
  17              	>>>  .set _thread,.
  17              	>>> 8:
  17              	>>>  hstring "current"
  17 14f4 07       	>>>>  .byte lex+9f-(.+1)
  17 14f5 63757272 	>>>>  .ascii "current"
  17      656E74
  17              	>>>> 9:
  17              	>>>>  .balign 4,0
  17              	>>>  .set lex,0
  17 14fc CC280000 	>>>  .int current
  17              	>>>  .previous
  17              	>>  .balign 4,0
  17 28c8 F4140000 	>>  .int _thread
  17              	> current:
  17              	>  rpush lr
  17 28cc 4CF804ED 	>>  str lr,[rp,#-4]!
  17 28d0 FDF752FD 	>  bl dovar
  17 28d4 E8290000 	>  .int forth
  18              	  _var_ "context", context, context0 + BODY
  18              	>  header "context",context
  18              	>>  _header_ "context",context
  18              	>>>  .section .data
  18 1500 F4140000 	>>>  .int _thread
  18              	>>>  .set _thread,.
  18              	>>> 8:
  18              	>>>  hstring "context"
  18 1504 07       	>>>>  .byte lex+9f-(.+1)
  18 1505 636F6E74 	>>>>  .ascii "context"
  18      657874
  18              	>>>> 9:
  18              	>>>>  .balign 4,0
  18              	>>>  .set lex,0
  18 150c DC280000 	>>>  .int context
  18              	>>>  .previous
  18              	>>  .balign 4,0
  18 28d8 04150000 	>>  .int _thread
  18              	> context:
  18              	>  rpush lr
  18 28dc 4CF804ED 	>>  str lr,[rp,#-4]!
  18 28e0 FDF74AFD 	>  bl dovar
  18 28e4 78280000 	>  .int context0+BODY
  19              	  _var_ "#context", numcontext, 3
  19              	>  header "#context",numcontext
  19              	>>  _header_ "#context",numcontext
  19              	>>>  .section .data
  19 1510 04150000 	>>>  .int _thread
  19              	>>>  .set _thread,.
  19              	>>> 8:
  19              	>>>  hstring "#context"
  19 1514 08       	>>>>  .byte lex+9f-(.+1)
  19 1515 23636F6E 	>>>>  .ascii "#context"
  19      74657874 
  19              	>>>> 9:
  19 151d 000000   	>>>>  .balign 4,0
  19              	>>>  .set lex,0
  19 1520 EC280000 	>>>  .int numcontext
  19              	>>>  .previous
  19              	>>  .balign 4,0
  19 28e8 14150000 	>>  .int _thread
  19              	> numcontext:
  19              	>  rpush lr
  19 28ec 4CF804ED 	>>  str lr,[rp,#-4]!
  19 28f0 FDF742FD 	>  bl dovar
  19 28f4 03000000 	>  .int 3
  20              	
  21              	@ ------------------------------------------------------------------------
  22              	
  23              	  _constant_ "#threads", numthreads, 64
  23              	>  header "#threads",numthreads
  23              	>>  _header_ "#threads",numthreads
  23              	>>>  .section .data
  23 1524 14150000 	>>>  .int _thread
  23              	>>>  .set _thread,.
  23              	>>> 8:
  23              	>>>  hstring "#threads"
  23 1528 08       	>>>>  .byte lex+9f-(.+1)
  23 1529 23746872 	>>>>  .ascii "#threads"
  23      65616473 
  23              	>>>> 9:
  23 1531 000000   	>>>>  .balign 4,0
  23              	>>>  .set lex,0
  23 1534 FC280000 	>>>  .int numthreads
  23              	>>>  .previous
  23              	>>  .balign 4,0
  23 28f8 28150000 	>>  .int _thread
  23              	> numthreads:
  23              	>  rpush lr
  23 28fc 4CF804ED 	>>  str lr,[rp,#-4]!
  23 2900 FDF73AFD 	>  bl dovar
  23 2904 40000000 	>  .int 64
  24              	  _constant_ "'dovoc", tdovoc, dovoc
  24              	>  header "'dovoc",tdovoc
  24              	>>  _header_ "'dovoc",tdovoc
  24              	>>>  .section .data
  24 1538 28150000 	>>>  .int _thread
  24              	>>>  .set _thread,.
  24              	>>> 8:
  24              	>>>  hstring "'dovoc"
  24 153c 06       	>>>>  .byte lex+9f-(.+1)
  24 153d 27646F76 	>>>>  .ascii "'dovoc"
  24      6F63
  24              	>>>> 9:
  24 1543 00       	>>>>  .balign 4,0
  24              	>>>  .set lex,0
  24 1544 0C290000 	>>>  .int tdovoc
  24              	>>>  .previous
  24              	>>  .balign 4,0
  24 2908 3C150000 	>>  .int _thread
  24              	> tdovoc:
  24              	>  rpush lr
  24 290c 4CF804ED 	>>  str lr,[rp,#-4]!
  24 2910 FDF732FD 	>  bl dovar
  24 2914 40290000 	>  .int dovoc
  25              	
  26              	@ ------------------------------------------------------------------------
  27              	@ return true if voc r8 is in context
  28              	
  29              	find_voc:
  30 2918 AFF24001 	  adr r1, context           @ point r1 at context stack
  31 291c 8968     	  ldr r1, [r1, #BODY]
  32 291e AFF23402 	  adr r2, numcontext        @ set r3 = context depth
  33 2922 9368     	  ldr r3, [r2, #BODY]
  34              	
  35 2924 C3F11004 	  rsb r4, r3, #16           @ set r4 = index to next item on stack
  36              	0:
  37 2928 51F82450 	  ldr r5, [r1, r4, lsl #2]
  38 292c 4545     	  cmp r5, r8
  39 292e 08BF     	  it eq
  40 2930 7047     	  bxeq lr                   @ return with "eq" condition
  41              	
  42 2932 04F10104 	  add r4, r4, #1
  43 2936 013B     	  subs r3, r3, #1
  44 2938 F6D1     	  bne 0b
  45              	
  46 293a B8F17B0F 	  cmp r8, #123              @ return with "ne" condition
  47 293e 7047     	  bx lr
  48              	
  49              	@ ------------------------------------------------------------------------
  50              	@ run time handler for all vocabularies
  51              	
  52              	@     ( a1 --- )
  53              	
  54              	dovoc:
  55 2940 F046     	  mov r8, lr
  56 2942 A8F10908 	  sub r8, r8, #9            @ body> (also dethumbificates the address)
  57 2946 FFF7E7FF 	  bl find_voc               @ is r8 in context?
  58 294a 09D0     	  beq 0f
  59              	
  60              	  @ vocabulary is not in context, put it there
  61              	
  62 294c 9368     	  ldr r3, [r2, #BODY]       @ r3 = #context
  63 294e 03F10103 	  add r3, r3, #1            @ increment #context
  64 2952 9360     	  str r3, [r2, #BODY]
  65 2954 C3F11003 	  rsb r3, r3, #16           @ r3 = index to stuff new into
  66 2958 41F82380 	  str r8, [r1, r3, lsl #2]  @ stuff vocabulary r8 in context
  67              	  exit
  67              	>  rpop pc
  67 295c 5CF804FB 	>>  ldr pc,[rp],#4
  68              	
  69              	  @ vocabulary is in context, rotate it out to top
  70              	
  71              	0:
  72 2960 9368     	  ldr r3, [r2, #BODY]       @ set r3 = index to top of context stack
  73 2962 C3F11003 	  rsb r3, r3, #16
  74              	
  75              	1:
  76 2966 51F82390 	  ldr r9, [r1, r3, lsl #2]
  77 296a 41F82380 	  str r8, [r1, r3, lsl #2]
  78 296e 5FEA0908 	  movs r8, r9
  79 2972 A342     	  cmp r3, r4                @ current index = index to w1 ?
  80 2974 1CBF     	  itt ne
  81 2976 0133     	  addne r3, r3, #1
  82 2978 F5E7     	  bne 1b
  83              	  exit
  83              	>  rpop pc
  83 297a 5CF804FB 	>>  ldr pc,[rp],#4
  84              	
  85              	@ ------------------------------------------------------------------------
  86              	@ return context stack address and index to top item of context stack
  87              	
  88              	@     ( --- a1 n1 )
  89              	
  90              	colon ">context", tocontext
  90              	>  header ">context",tocontext
  90              	>>  _header_ ">context",tocontext
  90              	>>>  .section .data
  90 1548 3C150000 	>>>  .int _thread
  90              	>>>  .set _thread,.
  90              	>>> 8:
  90              	>>>  hstring ">context"
  90 154c 08       	>>>>  .byte lex+9f-(.+1)
  90 154d 3E636F6E 	>>>>  .ascii ">context"
  90      74657874 
  90              	>>>> 9:
  90 1555 000000   	>>>>  .balign 4,0
  90              	>>>  .set lex,0
  90 1558 84290000 	>>>  .int tocontext
  90              	>>>  .previous
  90 297e 0000     	>>  .balign 4,0
  90 2980 4C150000 	>>  .int _thread
  90              	> tocontext:
  90 2984 AFF30080 	>  nop.w
  90              	>  rpush lr
  90 2988 4CF804ED 	>>  str lr,[rp,#-4]!
  91 298c FFF7A6FF 	  bl context
  92              	  cliteral 16
  92 2990 01B4     	>  push { r0 }
  92 2992 1020     	>  movs r0,#16
  93 2994 FFF7AAFF 	  bl numcontext
  94 2998 FEF7F4F8 	  bl minus
  95              	  exit
  95              	>  rpop pc
  95 299c 5CF804FB 	>>  ldr pc,[rp],#4
  96              	
  97              	@ ------------------------------------------------------------------------
  98              	
  99              	colon "definitions", definitions
  99              	>  header "definitions",definitions
  99              	>>  _header_ "definitions",definitions
  99              	>>>  .section .data
  99 155c 4C150000 	>>>  .int _thread
  99              	>>>  .set _thread,.
  99              	>>> 8:
  99              	>>>  hstring "definitions"
  99 1560 0B       	>>>>  .byte lex+9f-(.+1)
  99 1561 64656669 	>>>>  .ascii "definitions"
  99      6E697469 
  99      6F6E73
  99              	>>>> 9:
  99              	>>>>  .balign 4,0
  99              	>>>  .set lex,0
  99 156c A4290000 	>>>  .int definitions
  99              	>>>  .previous
  99              	>>  .balign 4,0
  99 29a0 60150000 	>>  .int _thread
  99              	> definitions:
  99 29a4 AFF30080 	>  nop.w
  99              	>  rpush lr
  99 29a8 4CF804ED 	>>  str lr,[rp,#-4]!
 100 29ac FFF7EAFF 	  bl tocontext
 101 29b0 FDF7D4FE 	  bl cells_fetch
 102 29b4 FDF72CFF 	  bl zstoreto
 103 29b8 FFF788FF 	  bl current
 104              	  exit
 104              	>  rpop pc
 104 29bc 5CF804FB 	>>  ldr pc,[rp],#4
 105              	
 106              	@ ------------------------------------------------------------------------
 107              	@ drop top of context stack
 108              	
 109              	colon "previous", previous
 109              	>  header "previous",previous
 109              	>>  _header_ "previous",previous
 109              	>>>  .section .data
 109 1570 60150000 	>>>  .int _thread
 109              	>>>  .set _thread,.
 109              	>>> 8:
 109              	>>>  hstring "previous"
 109 1574 08       	>>>>  .byte lex+9f-(.+1)
 109 1575 70726576 	>>>>  .ascii "previous"
 109      696F7573 
 109              	>>>> 9:
 109 157d 000000   	>>>>  .balign 4,0
 109              	>>>  .set lex,0
 109 1580 C4290000 	>>>  .int previous
 109              	>>>  .previous
 109              	>>  .balign 4,0
 109 29c0 74150000 	>>  .int _thread
 109              	> previous:
 109 29c4 AFF30080 	>  nop.w
 109              	>  rpush lr
 109 29c8 4CF804ED 	>>  str lr,[rp,#-4]!
 110 29cc FFF7DAFF 	  bl tocontext
 111 29d0 FDF7B8FE 	  bl cells_plus
 112 29d4 FDF7C4FF 	  bl off
 113 29d8 FDF74EFF 	  bl zdecrto
 114 29dc FFF786FF 	  bl numcontext
 115              	  exit
 115              	>  rpop pc
 115 29e0 5CF804FB 	>>  ldr pc,[rp],#4
 116              	
 117              	@ ------------------------------------------------------------------------
 118              	@ create the 3 system vocabulary arrays
 119              	
 120              	  _vocab_ "forth",    forth,    forth_link
 120              	>  header "forth",forth
 120              	>>  _header_ "forth",forth
 120              	>>>  .section .data
 120 1584 74150000 	>>>  .int _thread
 120              	>>>  .set _thread,.
 120              	>>> 8:
 120              	>>>  hstring "forth"
 120 1588 05       	>>>>  .byte lex+9f-(.+1)
 120 1589 666F7274 	>>>>  .ascii "forth"
 120      68
 120              	>>>> 9:
 120 158e 0000     	>>>>  .balign 4,0
 120              	>>>  .set lex,0
 120 1590 E8290000 	>>>  .int forth
 120              	>>>  .previous
 120              	>>  .balign 4,0
 120 29e4 88150000 	>>  .int _thread
 120              	> forth:
 120              	>  rpush lr
 120 29e8 4CF804ED 	>>  str lr,[rp,#-4]!
 120 29ec FFF7A8FF 	>  bl dovoc
 120 29f0 400F0000 	>  .int forth_link
 120 29f4 00000000 	>  .fill 63,4,0
 120      00000000 
 120      00000000 
 120      00000000 
 120      00000000 
 120 2af0 00000000 	>  .int _voclink
 120              	>  .set _voclink,forth
 121              	  _vocab_ "compiler", compiler, comp_link
 121              	>  header "compiler",compiler
 121              	>>  _header_ "compiler",compiler
 121              	>>>  .section .data
 121 1594 88150000 	>>>  .int _thread
 121              	>>>  .set _thread,.
 121              	>>> 8:
 121              	>>>  hstring "compiler"
 121 1598 08       	>>>>  .byte lex+9f-(.+1)
 121 1599 636F6D70 	>>>>  .ascii "compiler"
 121      696C6572 
 121              	>>>> 9:
 121 15a1 000000   	>>>>  .balign 4,0
 121              	>>>  .set lex,0
 121 15a4 F82A0000 	>>>  .int compiler
 121              	>>>  .previous
 121              	>>  .balign 4,0
 121 2af4 98150000 	>>  .int _thread
 121              	> compiler:
 121              	>  rpush lr
 121 2af8 4CF804ED 	>>  str lr,[rp,#-4]!
 121 2afc FFF720FF 	>  bl dovoc
 121 2b00 A4140000 	>  .int comp_link
 121 2b04 00000000 	>  .fill 63,4,0
 121      00000000 
 121      00000000 
 121      00000000 
 121      00000000 
 121 2c00 E8290000 	>  .int _voclink
 121              	>  .set _voclink,compiler
 122              	  _vocab_ "root",     root,     8b
 122              	>  header "root",root
 122              	>>  _header_ "root",root
 122              	>>>  .section .data
 122 15a8 98150000 	>>>  .int _thread
 122              	>>>  .set _thread,.
 122              	>>> 8:
 122              	>>>  hstring "root"
 122 15ac 04       	>>>>  .byte lex+9f-(.+1)
 122 15ad 726F6F74 	>>>>  .ascii "root"
 122              	>>>> 9:
 122 15b1 000000   	>>>>  .balign 4,0
 122              	>>>  .set lex,0
 122 15b4 082C0000 	>>>  .int root
 122              	>>>  .previous
 122              	>>  .balign 4,0
 122 2c04 AC150000 	>>  .int _thread
 122              	> root:
 122              	>  rpush lr
 122 2c08 4CF804ED 	>>  str lr,[rp,#-4]!
 122 2c0c FFF798FE 	>  bl dovoc
 122 2c10 AC150000 	>  .int 8b
 122 2c14 00000000 	>  .fill 63,4,0
 122      00000000 
 122      00000000 
 122      00000000 
 122      00000000 
 122 2d10 F82A0000 	>  .int _voclink
 122              	>  .set _voclink,root
 123              	
 124              	@ ------------------------------------------------------------------------
 125              	@ pointer to nfa of last header in system
 126              	
 127              	  .set last_hdr, _thread
 128              	
 129              	@ ========================================================================
 130              	
 340              	
 341              	@ ========================================================================
DEFINED SYMBOLS
                t4.s:9      *ABS*:00000001 ver
                t4.s:11     *ABS*:00100000 MEMSZ
                t4.s:12     *ABS*:00001000 STKSZ
                t4.s:13     *ABS*:000000b4 FLDSZ
                t4.s:14     *ABS*:00000400 TIBSZ
            macros.s:9      *ABS*:00000000 lex
            vocabs.s:122    .data:000015ac _thread
         interpret.s:237    .data:00000f40 forth_link
             fload.s:254    .data:000014a4 comp_link
            macros.s:14     *ABS*:00000000 root_link
            vocabs.s:122    .text:00002c08 _voclink
            macros.s:21     *ABS*:00000001 FORTH
            macros.s:22     *ABS*:00000002 COMPILER
            macros.s:23     *ABS*:00000003 ROOT
            macros.s:27     *ABS*:0000003f LEXMASK
            macros.s:28     *ABS*:00000080 IMM
            macros.s:29     *ABS*:00000040 ALIAS
            macros.s:30     *ABS*:00000008 BODY
                t4.s:31     .text:00000000 origin
                t4.s:286    .text:000002d0 start
                t4.s:32     .text:00000000 $a
            rehash.s:7      .text:000027a0 voc
            vocabs.s:120    .text:000029e8 forth
            vocabs.s:121    .text:00002af8 compiler
            vocabs.s:122    .text:00002c08 root
                t4.s:39     .data:0000000b $d
                t4.s:39     .text:00000008 org
                t4.s:39     .text:00000004 $d
                t4.s:39     .text:00000008 $t
              exec.s:70     .text:00000378 dovar
                t4.s:39     .text:00000010 $d
                t4.s:40     .text:00000018 version
                t4.s:40     .text:00000018 $t
                t4.s:40     .text:00000020 $d
                t4.s:41     .text:00000028 thead
                t4.s:41     .text:00000028 $t
                t4.s:41     .text:00000030 $d
                t4.s:42     .text:00000038 bhead
                t4.s:42     .text:00000038 $t
                t4.s:42     .text:00000040 $d
                t4.s:44     .text:00000048 arg0
                t4.s:44     .text:00000048 $t
                t4.s:44     .text:00000050 $d
                t4.s:45     .text:00000058 argc
                t4.s:45     .text:00000058 $t
                t4.s:45     .text:00000060 $d
                t4.s:46     .text:00000068 argv
                t4.s:46     .text:00000068 $t
                t4.s:46     .text:00000070 $d
                t4.s:47     .text:00000078 envp
                t4.s:47     .text:00000078 $t
                t4.s:47     .text:00000080 $d
                t4.s:48     .text:00000088 auxp
                t4.s:48     .text:00000088 $t
                t4.s:48     .text:00000090 $d
                t4.s:50     .text:00000098 shebang
                t4.s:50     .text:00000098 $t
                t4.s:50     .text:000000a0 $d
                t4.s:51     .text:000000a8 intty
                t4.s:51     .text:000000a8 $t
                t4.s:51     .text:000000b0 $d
                t4.s:52     .text:000000b8 outtty
                t4.s:52     .text:000000b8 $t
                t4.s:52     .text:000000c0 $d
                t4.s:53     .text:000000c8 turnkeyd
                t4.s:53     .text:000000c8 $t
                t4.s:53     .text:000000d0 $d
                t4.s:55     .text:000000d8 qtty
                t4.s:55     .text:000000d8 $t
                t4.s:55     .text:000000e0 $d
                t4.s:57     .text:000000e8 lsp
                t4.s:57     .text:000000e8 $t
                t4.s:57     .text:000000f0 $d
                t4.s:59     .text:000000f8 heap_prot
                t4.s:59     .text:000000f8 $t
                t4.s:59     .text:00000100 $d
                t4.s:60     .text:00000108 heap_flg
                t4.s:60     .text:00000108 $t
                t4.s:60     .text:00000110 $d
                t4.s:65     .text:00000118 rehash
                t4.s:65     .text:00000118 $t
              exec.s:58     .text:00000364 dodefer
                t4.s:65     .text:00000120 $d
            rehash.s:60     .text:00002822 _rehash
                t4.s:66     .text:00000128 unpack
                t4.s:66     .text:00000128 $t
                t4.s:66     .text:00000130 $d
             reloc.s:116    .text:000026e2 kunpack
                t4.s:71     .text:00000138 pdefault
                t4.s:71     .text:00000138 $t
                t4.s:71     .text:00000140 $d
              exec.s:20     .text:00000328 noop
                t4.s:72     .text:00000148 default
                t4.s:72     .text:00000148 $t
                t4.s:72     .text:00000150 $d
                t4.s:73     .text:00000158 ldefault
                t4.s:73     .text:00000158 $t
                t4.s:73     .text:00000160 $d
                t4.s:78     .text:00000168 atexit
                t4.s:78     .text:00000168 $t
                t4.s:78     .text:00000170 $d
                t4.s:83     .text:00000178 dots
                t4.s:83     .text:00000178 $t
                t4.s:83     .text:00000180 $d
                t4.s:84     .text:00000188 udots
                t4.s:84     .text:00000188 $t
                t4.s:84     .text:00000190 $d
                t4.s:89     .text:00000194 _chktty
                t4.s:90     .text:00000194 $t
            header.s:7      .text:00002080 hp
                t4.s:106    .text:000001ac chk_tty
                t4.s:124    .text:000001c8 init_vars
                io.s:24     .text:00001138 tib
                t4.s:163    .text:00000210 get_args
                t4.s:191    .text:00000242 _fetchmap
                t4.s:202    .text:00000250 alloc_ret
            stacks.s:7      .text:000004e8 rp0
            stacks.s:6      .text:000004d8 sp0
                t4.s:223    .text:00000272 init_mem
                t4.s:236    .text:00000284 fmap
                t4.s:236    .text:00000280 $d
                t4.s:236    .text:00000284 $t
                t4.s:270    .text:000002b4 clr_mem
            header.s:6      .text:00002070 dp
         interpret.s:6      .text:00001734 quit
              exec.s:11     .text:00000314 break
              exec.s:11     .text:0000030e $d
              exec.s:12     .text:00000314 $t
              exec.s:20     .text:00000322 $d
              exec.s:21     .text:00000328 $t
              exec.s:28     .text:00000330 xit
              exec.s:28     .text:0000032a $d
              exec.s:28     .text:00000330 $t
             comma.s:96     .text:00002040 litc
              exec.s:38     .text:00000348 qexit
              exec.s:38     .text:00000344 $d
              exec.s:39     .text:00000348 $t
              exec.s:50     .text:00000358 execute
              exec.s:50     .text:00000352 $d
              exec.s:51     .text:00000358 $t
              exec.s:58     .text:0000035e $d
              exec.s:59     .text:00000364 $t
              exec.s:70     .text:00000374 $d
              exec.s:71     .text:00000378 $t
              exec.s:81     .text:0000038c dovariable
              exec.s:81     .text:00000386 $d
              exec.s:82     .text:0000038c $t
              exec.s:89     .text:0000039c bye
              exec.s:89     .text:00000398 $d
              exec.s:89     .text:0000039c $t
                io.s:108    .text:00001224 cr_
                io.s:142    .text:0000128c pdotq
              exec.s:94     .text:000003b4 $d
              exec.s:95     .text:000003c0 $t
          syscalls.s:4      .text:000003d4 errno
          syscalls.s:79     .text:00000438 sys_exit
          syscalls.s:4      .text:000003d0 $d
          syscalls.s:4      .text:000003d4 $t
          syscalls.s:4      .text:000003dc $d
          syscalls.s:9      .text:000003e0 sys1
          syscalls.s:10     .text:000003e0 sys0
          syscalls.s:11     .text:000003e0 $t
          syscalls.s:26     .text:000003f8 sys2
          syscalls.s:33     .text:000003fc sys3
          syscalls.s:39     .text:00000400 sys4
          syscalls.s:45     .text:00000404 sys5
          syscalls.s:51     .text:00000408 sys6
          syscalls.s:57     .text:00000410 do_syscall
          syscalls.s:57     .text:0000040c $d
          syscalls.s:58     .text:00000410 $t
          syscalls.s:64     .text:0000041e $d
          syscalls.s:79     .text:00000434 $d
          syscalls.s:79     .text:00000438 $t
          syscalls.s:79     .text:00000440 $d
          syscalls.s:80     .text:00000448 sys_read
          syscalls.s:80     .text:00000448 $t
          syscalls.s:80     .text:00000450 $d
          syscalls.s:81     .text:00000458 sys_write
          syscalls.s:81     .text:00000458 $t
          syscalls.s:81     .text:00000460 $d
          syscalls.s:82     .text:00000468 sys_open
          syscalls.s:82     .text:00000468 $t
          syscalls.s:82     .text:00000470 $d
          syscalls.s:83     .text:00000478 sys_open3
          syscalls.s:83     .text:00000478 $t
          syscalls.s:83     .text:00000480 $d
          syscalls.s:84     .text:00000488 sys_close
          syscalls.s:84     .text:00000488 $t
          syscalls.s:84     .text:00000490 $d
          syscalls.s:86     .text:00000498 sys_lseek
          syscalls.s:86     .text:00000498 $t
          syscalls.s:86     .text:000004a0 $d
          syscalls.s:89     .text:000004a8 sys_mmap2
          syscalls.s:89     .text:000004a8 $t
          syscalls.s:89     .text:000004b0 $d
          syscalls.s:90     .text:000004b8 sys_munmap
          syscalls.s:90     .text:000004b8 $t
          syscalls.s:90     .text:000004c0 $d
          syscalls.s:91     .text:000004c8 sys_poll
          syscalls.s:91     .text:000004c8 $t
          syscalls.s:91     .text:000004d0 $d
            stacks.s:6      .text:000004d8 $t
            stacks.s:6      .text:000004e0 $d
            stacks.s:7      .text:000004e8 $t
            stacks.s:7      .text:000004f0 $d
            stacks.s:14     .text:000004f8 qdup
            stacks.s:15     .text:000004f8 $t
            stacks.s:25     .text:00000504 dup
            stacks.s:25     .text:00000500 $d
            stacks.s:26     .text:00000504 $t
            stacks.s:34     .text:0000050c twodup
            stacks.s:34     .text:00000508 $d
            stacks.s:35     .text:0000050c $t
            stacks.s:46     .text:0000051c threedup
            stacks.s:46     .text:00000516 $d
            stacks.s:47     .text:0000051c $t
            stacks.s:57     .text:00000528 swap
            stacks.s:57     .text:00000524 $d
            stacks.s:58     .text:00000528 $t
            stacks.s:68     .text:00000534 twoswap
            stacks.s:68     .text:00000530 $d
            stacks.s:69     .text:00000534 $t
            stacks.s:80     .text:00000544 drop
            stacks.s:80     .text:0000053e $d
            stacks.s:81     .text:00000544 $t
            stacks.s:89     .text:0000054c twodrop
            stacks.s:89     .text:00000548 $d
            stacks.s:90     .text:0000054c $t
            stacks.s:99     .text:00000558 threedrop
            stacks.s:99     .text:00000552 $d
            stacks.s:100    .text:00000558 $t
            stacks.s:109    .text:00000564 over
            stacks.s:109    .text:0000055e $d
            stacks.s:110    .text:00000564 $t
            stacks.s:119    .text:00000570 nip
            stacks.s:119    .text:0000056a $d
            stacks.s:120    .text:00000570 $t
            stacks.s:128    .text:00000578 tuck
            stacks.s:128    .text:00000574 $d
            stacks.s:129    .text:00000578 $t
            stacks.s:139    .text:00000584 pluck
            stacks.s:139    .text:00000580 $d
            stacks.s:140    .text:00000584 $t
            stacks.s:149    .text:00000590 pick
            stacks.s:149    .text:0000058a $d
            stacks.s:150    .text:00000590 $t
            stacks.s:158    .text:0000059c rot
            stacks.s:158    .text:00000596 $d
            stacks.s:159    .text:0000059c $t
            stacks.s:169    .text:000005a8 drot
            stacks.s:169    .text:000005a4 $d
            stacks.s:170    .text:000005a8 $t
            stacks.s:180    .text:000005b4 tor
            stacks.s:180    .text:000005b0 $d
            stacks.s:181    .text:000005b4 $t
            stacks.s:190    .text:000005c0 twotor
            stacks.s:190    .text:000005bc $d
            stacks.s:191    .text:000005c0 $t
            stacks.s:202    .text:000005d4 rto
            stacks.s:202    .text:000005ce $d
            stacks.s:203    .text:000005d4 $t
            stacks.s:212    .text:000005e0 tworto
            stacks.s:212    .text:000005dc $d
            stacks.s:213    .text:000005e0 $t
            stacks.s:224    .text:000005f0 duptor
            stacks.s:224    .text:000005ec $d
            stacks.s:225    .text:000005f0 $t
            stacks.s:230    .text:000005fc rdrop
            stacks.s:230    .text:000005f6 $d
            stacks.s:231    .text:000005fc $t
            stacks.s:239    .text:00000608 rfetch
            stacks.s:239    .text:00000602 $d
            stacks.s:240    .text:00000608 $t
            stacks.s:249    .text:00000614 spfetch
            stacks.s:249    .text:00000610 $d
            stacks.s:250    .text:00000614 $t
            stacks.s:259    .text:00000620 spstore
            stacks.s:259    .text:0000061a $d
            stacks.s:260    .text:00000620 $t
            stacks.s:269    .text:0000062c rpfetch
            stacks.s:269    .text:00000626 $d
            stacks.s:270    .text:0000062c $t
            stacks.s:279    .text:00000638 rpstore
            stacks.s:279    .text:00000632 $d
            stacks.s:280    .text:00000638 $t
            stacks.s:289    .text:00000644 split
            stacks.s:289    .text:0000063e $d
            stacks.s:290    .text:00000644 $t
            stacks.s:299    .text:00000654 join
            stacks.s:299    .text:00000650 $d
            stacks.s:300    .text:00000654 $t
            stacks.s:307    .text:00000660 depth
            stacks.s:307    .text:0000065c $d
            stacks.s:307    .text:00000660 $t
              math.s:19     .text:00000b84 minus
            stacks.s:317    .text:00000684 dotunder
            stacks.s:317    .text:0000067e $d
            stacks.s:317    .text:00000684 $t
            stacks.s:319    .text:00000690 $d
         interpret.s:7      .text:00001744 abort
            stacks.s:320    .text:000006a4 $t
            stacks.s:324    .text:000006ac dotover
            stacks.s:324    .text:000006a8 $d
            stacks.s:324    .text:000006ac $t
            stacks.s:326    .text:000006b8 $d
            stacks.s:327    .text:000006c8 $t
            stacks.s:331    .text:000006d0 qstack
            stacks.s:331    .text:000006cc $d
            stacks.s:331    .text:000006d0 $t
             logic.s:123    .text:00000f54 ugreater
             loops.s:136    .text:00001e6c qbranch
            stacks.s:336    .text:000006e8 $d
            stacks.s:337    .text:000006ea $t
            stacks.s:344    .text:000006fe $d
            stacks.s:345    .text:00000700 $t
            memory.s:6      .text:0000072c cell
            memory.s:6      .text:00000726 $d
            memory.s:6      .text:0000072c $t
            memory.s:6      .text:00000734 $d
              math.s:179    .text:00000c24 fourplus
            memory.s:10     .text:00000c24 cellplus
              math.s:188    .text:00000c2c fourminus
            memory.s:11     .text:00000c2c cellminus
              math.s:88     .text:00000bd4 fourstar
            memory.s:12     .text:00000bd4 cells
            memory.s:16     .text:0000073c cellslash
            memory.s:17     .text:0000073c $t
            memory.s:25     .text:00000744 cells_plus
            memory.s:25     .text:00000740 $d
            memory.s:26     .text:00000744 $t
            memory.s:32     .text:00000750 wplus
            memory.s:32     .text:0000074c $d
            memory.s:33     .text:00000750 $t
            memory.s:42     .text:0000075c cells_fetch
            memory.s:42     .text:00000758 $d
            memory.s:43     .text:0000075c $t
            memory.s:55     .text:00000770 cells_store
            memory.s:55     .text:0000076c $d
            memory.s:56     .text:00000770 $t
            memory.s:68     .text:00000784 wxfetch
            memory.s:68     .text:00000780 $d
            memory.s:69     .text:00000784 $t
            memory.s:77     .text:00000790 wxstore
            memory.s:77     .text:0000078c $d
            memory.s:78     .text:00000790 $t
            memory.s:85     .text:000007a0 cxfetch
            memory.s:85     .text:0000079a $d
            memory.s:86     .text:000007a0 $t
            memory.s:92     .text:000007ac cxstore
            memory.s:92     .text:000007a6 $d
            memory.s:93     .text:000007ac $t
            memory.s:106    .text:000007b8 fetch_up
            memory.s:106    .text:000007b4 $d
            memory.s:107    .text:000007b8 $t
            memory.s:117    .text:000007c8 fetch
            memory.s:117    .text:000007c2 $d
            memory.s:118    .text:000007c8 $t
            memory.s:127    .text:000007d8 store
            memory.s:127    .text:000007d2 $d
            memory.s:128    .text:000007d8 $t
            memory.s:139    .text:000007e8 cfetch
            memory.s:139    .text:000007e4 $d
            memory.s:140    .text:000007e8 $t
            memory.s:147    .text:000007f0 cstore
            memory.s:147    .text:000007ec $d
            memory.s:148    .text:000007f0 $t
            memory.s:157    .text:000007fc wfetch
            memory.s:157    .text:000007f8 $d
            memory.s:158    .text:000007fc $t
            memory.s:165    .text:00000804 wstore
            memory.s:165    .text:00000800 $d
            memory.s:166    .text:00000804 $t
            memory.s:175    .text:00000810 zstoreto
            memory.s:175    .text:0000080c $d
            memory.s:176    .text:00000810 $t
           compile.s:111    .text:00001b4c xtfetch
            memory.s:190    .text:00000830 zplusstoreto
            memory.s:190    .text:0000082a $d
            memory.s:191    .text:00000830 $t
            memory.s:207    .text:00000854 zincrto
            memory.s:207    .text:00000850 $d
            memory.s:208    .text:00000854 $t
            memory.s:224    .text:00000878 zdecrto
            memory.s:224    .text:00000874 $d
            memory.s:225    .text:00000878 $t
            memory.s:241    .text:0000089c zonto
            memory.s:241    .text:00000898 $d
            memory.s:242    .text:0000089c $t
            memory.s:257    .text:000008c0 zoffto
            memory.s:257    .text:000008ba $d
            memory.s:258    .text:000008c0 $t
            memory.s:274    .text:000008e0 count
            memory.s:274    .text:000008dc $d
            memory.s:275    .text:000008e0 $t
            memory.s:294    .text:000008f0 fetch_plus
            memory.s:294    .text:000008ea $d
            memory.s:295    .text:000008f0 $t
            memory.s:322    .text:00000904 juggle
            memory.s:322    .text:00000900 $d
            memory.s:323    .text:00000904 $t
            memory.s:336    .text:00000918 strlen
            memory.s:336    .text:00000912 $d
            memory.s:337    .text:00000918 $t
            memory.s:363    .text:00000940 cset
            memory.s:363    .text:0000093c $d
            memory.s:364    .text:00000940 $t
            memory.s:390    .text:00000950 on
            memory.s:390    .text:0000094c $d
            memory.s:391    .text:00000950 $t
            memory.s:402    .text:00000960 off
            memory.s:402    .text:0000095c $d
            memory.s:403    .text:00000960 $t
            memory.s:414    .text:00000970 incr
            memory.s:414    .text:0000096a $d
            memory.s:415    .text:00000970 $t
            memory.s:430    .text:00000988 decr
            memory.s:430    .text:00000984 $d
            memory.s:431    .text:00000988 $t
            memory.s:447    .text:000009a0 zdecr
            memory.s:447    .text:0000099c $d
            memory.s:448    .text:000009a0 $t
            memory.s:461    .text:000009b4 plusstore
            memory.s:461    .text:000009b0 $d
            memory.s:462    .text:000009b4 $t
            memory.s:478    .text:000009d0 cmove
            memory.s:478    .text:000009ca $d
            memory.s:479    .text:000009d0 $t
            memory.s:498    .text:000009ec cmoveto
            memory.s:498    .text:000009e6 $d
            memory.s:499    .text:000009ec $t
            memory.s:522    .text:00000a0c fill
            memory.s:522    .text:00000a08 $d
            memory.s:523    .text:00000a0c $t
            memory.s:525    .text:00000a0e _fill1
            memory.s:551    .text:00000a24 erase
            memory.s:551    .text:00000a1e $d
            memory.s:552    .text:00000a24 $t
            memory.s:561    .text:00000a30 dfill
            memory.s:561    .text:00000a2c $d
            memory.s:562    .text:00000a30 $t
            memory.s:577    .text:00000a44 atbl
            memory.s:578    .text:00000a44 $d
            memory.s:600    .text:00000ac8 upc
            memory.s:601    .text:00000ac8 $t
            memory.s:611    .text:00000ad8 comp
            memory.s:611    .text:00000ad4 $d
            memory.s:612    .text:00000ad8 $t
            memory.s:639    .text:00000b00 s2z
            memory.s:639    .text:00000afa $d
            memory.s:640    .text:00000b00 $t
            memory.s:651    .text:00000b10 strstore
            memory.s:651    .text:00000b0c $d
            memory.s:651    .text:00000b10 $t
              math.s:125    .text:00000bf4 oneplus
            memory.s:664    .text:00000b34 strplus
            memory.s:664    .text:00000b30 $d
            memory.s:664    .text:00000b34 $t
              math.s:9      .text:00000b78 plus
              math.s:9      .text:00000b74 $d
              math.s:10     .text:00000b78 $t
              math.s:19     .text:00000b7e $d
              math.s:20     .text:00000b84 $t
              math.s:29     .text:00000b90 abs
              math.s:29     .text:00000b8a $d
              math.s:30     .text:00000b90 $t
              math.s:40     .text:00000b9c shll
              math.s:40     .text:00000b98 $d
              math.s:41     .text:00000b9c $t
              math.s:50     .text:00000ba8 shrr
              math.s:50     .text:00000ba4 $d
              math.s:51     .text:00000ba8 $t
              math.s:60     .text:00000bb4 ushr
              math.s:60     .text:00000bb0 $d
              math.s:61     .text:00000bb4 $t
              math.s:70     .text:00000bc0 twostar
              math.s:70     .text:00000bbc $d
              math.s:71     .text:00000bc0 $t
              math.s:79     .text:00000bc8 threestar
              math.s:79     .text:00000bc4 $d
              math.s:80     .text:00000bc8 $t
              math.s:88     .text:00000bce $d
              math.s:89     .text:00000bd4 $t
              math.s:98     .text:00000bdc twoslash
              math.s:98     .text:00000bd8 $d
              math.s:99     .text:00000bdc $t
              math.s:107    .text:00000be4 u2slash
              math.s:107    .text:00000be0 $d
              math.s:108    .text:00000be4 $t
              math.s:116    .text:00000bec fourslash
              math.s:116    .text:00000be8 $d
              math.s:117    .text:00000bec $t
              math.s:125    .text:00000bf0 $d
              math.s:126    .text:00000bf4 $t
              math.s:134    .text:00000bfc oneminus
              math.s:134    .text:00000bf8 $d
              math.s:135    .text:00000bfc $t
              math.s:143    .text:00000c04 twoplus
              math.s:143    .text:00000c00 $d
              math.s:144    .text:00000c04 $t
              math.s:152    .text:00000c0c twominus
              math.s:152    .text:00000c08 $d
              math.s:153    .text:00000c0c $t
              math.s:161    .text:00000c14 threeplus
              math.s:161    .text:00000c10 $d
              math.s:162    .text:00000c14 $t
              math.s:170    .text:00000c1c threeminus
              math.s:170    .text:00000c18 $d
              math.s:171    .text:00000c1c $t
              math.s:179    .text:00000c20 $d
              math.s:180    .text:00000c24 $t
              math.s:188    .text:00000c28 $d
              math.s:189    .text:00000c2c $t
              math.s:197    .text:00000c34 negate
              math.s:197    .text:00000c30 $d
              math.s:198    .text:00000c34 $t
              math.s:206    .text:00000c3c qnegate
              math.s:206    .text:00000c38 $d
              math.s:207    .text:00000c3c $t
              math.s:218    .text:00000c4c dnegate
              math.s:218    .text:00000c46 $d
              math.s:219    .text:00000c4c $t
              math.s:231    .text:00000c60 dplus
              math.s:231    .text:00000c5a $d
              math.s:232    .text:00000c60 $t
              math.s:243    .text:00000c70 dminus
              math.s:243    .text:00000c6a $d
              math.s:243    .text:00000c70 $t
              math.s:253    .text:00000c88 dabs
              math.s:253    .text:00000c84 $d
              math.s:254    .text:00000c88 $t
              math.s:263    .text:00000c94 s2d
              math.s:263    .text:00000c8e $d
              math.s:264    .text:00000c94 $t
              math.s:273    .text:00000ca0 umstar
              math.s:273    .text:00000c9a $d
              math.s:274    .text:00000ca0 $t
              math.s:285    .text:00000cb0 mstar
              math.s:285    .text:00000cac $d
              math.s:286    .text:00000cb0 $t
              math.s:297    .text:00000cc0 star
              math.s:297    .text:00000cbc $d
              math.s:298    .text:00000cc0 $t
              math.s:307    .text:00000ccc star_plus
              math.s:307    .text:00000cc8 $d
              math.s:308    .text:00000ccc $t
              math.s:318    .text:00000cdc sdiv
              math.s:318    .text:00000cd6 $d
              math.s:319    .text:00000cdc $t
              math.s:334    .text:00000cfc udiv
              math.s:334    .text:00000cf6 $d
              math.s:335    .text:00000cfc $t
              math.s:347    .text:00000d10 ummod
              math.s:347    .text:00000d0c $d
              math.s:348    .text:00000d10 $t
              math.s:373    .text:00000d34 vdiv
              math.s:373    .text:00000d30 $d
              math.s:374    .text:00000d34 $t
              math.s:402    .text:00000d78 uxth
              math.s:402    .text:00000d72 $d
              math.s:403    .text:00000d78 $t
              math.s:411    .text:00000d80 sxth
              math.s:411    .text:00000d7c $d
              math.s:412    .text:00000d80 $t
              math.s:420    .text:00000d88 musmod
              math.s:420    .text:00000d84 $d
              math.s:420    .text:00000d88 $t
              math.s:434    .text:00000dbc psmod
              math.s:434    .text:00000db8 $d
              math.s:434    .text:00000dbc $t
             logic.s:96     .text:00000f34 zless
             logic.s:31     .text:00000ed0 xor
              math.s:453    .text:00000e00 smod
              math.s:453    .text:00000dfc $d
              math.s:453    .text:00000e00 $t
              math.s:458    .text:00000e18 $d
              math.s:459    .text:00000e1a $t
              math.s:463    .text:00000e2a $d
              math.s:464    .text:00000e2c $t
             loops.s:128    .text:00001e58 branch
              math.s:471    .text:00000e48 $d
              math.s:473    .text:00000e4a $t
              math.s:476    .text:00000e52 $d
              math.s:478    .text:00000e54 $t
              math.s:484    .text:00000e60 mod
              math.s:484    .text:00000e5c $d
              math.s:484    .text:00000e60 $t
              math.s:491    .text:00000e78 slash
              math.s:491    .text:00000e74 $d
              math.s:491    .text:00000e78 $t
              math.s:499    .text:00000e90 bswap
              math.s:499    .text:00000e8c $d
              math.s:500    .text:00000e90 $t
             logic.s:6      .text:00000e98 true
             logic.s:6      .text:00000e94 $d
             logic.s:6      .text:00000e98 $t
             logic.s:6      .text:00000ea0 $d
             logic.s:7      .text:00000ea8 false
             logic.s:7      .text:00000ea8 $t
             logic.s:7      .text:00000eb0 $d
             logic.s:13     .text:00000eb8 and_
             logic.s:14     .text:00000eb8 $t
             logic.s:22     .text:00000ec4 or_
             logic.s:22     .text:00000ebe $d
             logic.s:23     .text:00000ec4 $t
             logic.s:31     .text:00000eca $d
             logic.s:32     .text:00000ed0 $t
             logic.s:40     .text:00000edc not
             logic.s:40     .text:00000ed6 $d
             logic.s:41     .text:00000edc $t
             logic.s:48     .text:00000ee4 zequals
             logic.s:48     .text:00000ee0 $d
             logic.s:49     .text:00000ee4 $t
             logic.s:57     .text:00000ef0 dzequ
             logic.s:57     .text:00000eea $d
             logic.s:58     .text:00000ef0 $t
             logic.s:66     .text:00000efc znotequ
             logic.s:66     .text:00000ef8 $d
             logic.s:67     .text:00000efc $t
             logic.s:76     .text:00000f0c equals
             logic.s:76     .text:00000f08 $d
             logic.s:77     .text:00000f0c $t
             logic.s:87     .text:00000f1c notequals
             logic.s:87     .text:00000f16 $d
             logic.s:87     .text:00000f1c $t
             logic.s:96     .text:00000f30 $d
             logic.s:97     .text:00000f34 $t
             logic.s:104    .text:00000f3c zgreater
             logic.s:104    .text:00000f38 $d
             logic.s:105    .text:00000f3c $t
             logic.s:113    .text:00000f48 uless
             logic.s:113    .text:00000f44 $d
             logic.s:114    .text:00000f48 $t
             logic.s:123    .text:00000f50 $d
             logic.s:124    .text:00000f54 $t
             logic.s:133    .text:00000f60 less
             logic.s:133    .text:00000f5c $d
             logic.s:134    .text:00000f60 $t
             logic.s:145    .text:00000f74 greater
             logic.s:145    .text:00000f6e $d
             logic.s:146    .text:00000f74 $t
             logic.s:157    .text:00000f88 dequals
             logic.s:157    .text:00000f82 $d
             logic.s:157    .text:00000f88 $t
             logic.s:167    .text:00000fa4 dzless
             logic.s:167    .text:00000fa0 $d
             logic.s:168    .text:00000fa4 $t
             logic.s:176    .text:00000fb0 dless
             logic.s:176    .text:00000faa $d
             logic.s:176    .text:00000fb0 $t
             logic.s:185    .text:00000fc8 dgreater
             logic.s:185    .text:00000fc2 $d
             logic.s:185    .text:00000fc8 $t
             logic.s:194    .text:00000fe0 dnotequ
             logic.s:194    .text:00000fdc $d
             logic.s:194    .text:00000fe0 $t
             logic.s:203    .text:00000ff8 min
             logic.s:203    .text:00000ff4 $d
             logic.s:204    .text:00000ff8 $t
             logic.s:214    .text:00001008 max
             logic.s:214    .text:00001002 $d
             logic.s:215    .text:00001008 $t
             logic.s:225    .text:00001018 umin
             logic.s:225    .text:00001012 $d
             logic.s:226    .text:00001018 $t
             logic.s:236    .text:00001028 umax
             logic.s:236    .text:00001022 $d
             logic.s:237    .text:00001028 $t
             logic.s:247    .text:00001038 between
             logic.s:247    .text:00001032 $d
             logic.s:248    .text:00001038 $t
             logic.s:261    .text:00001050 within
             logic.s:261    .text:0000104a $d
             logic.s:262    .text:00001050 $t
                io.s:6      .text:00001068 rows
                io.s:6      .text:00001062 $d
                io.s:6      .text:00001068 $t
                io.s:6      .text:00001070 $d
                io.s:7      .text:00001078 cols
                io.s:7      .text:00001078 $t
                io.s:7      .text:00001080 $d
                io.s:8      .text:00001088 bl_
                io.s:8      .text:00001088 $t
                io.s:8      .text:00001090 $d
                io.s:12     .text:00001098 source
                io.s:12     .text:00001098 $t
                io.s:12     .text:000010a0 $d
                io.s:31     .text:00001148 psource
                io.s:13     .text:000010a8 refill
                io.s:13     .text:000010a8 $t
                io.s:13     .text:000010b0 $d
            expect.s:142    .text:000014b4 query
                io.s:14     .text:000010b8 emit
                io.s:14     .text:000010b8 $t
                io.s:14     .text:000010c0 $d
                io.s:41     .text:00001160 pemit
                io.s:15     .text:000010c8 type
                io.s:15     .text:000010c8 $t
                io.s:15     .text:000010d0 $d
                io.s:93     .text:000011f8 ptype
                io.s:16     .text:000010d8 key
                io.s:16     .text:000010d8 $t
                io.s:16     .text:000010e0 $d
                io.s:75     .text:000011c0 pkey
                io.s:18     .text:000010e8 fdout
                io.s:18     .text:000010e8 $t
                io.s:18     .text:000010f0 $d
                io.s:20     .text:000010f8 numtib
                io.s:20     .text:000010f8 $t
                io.s:20     .text:00001100 $d
                io.s:21     .text:00001108 toin
                io.s:21     .text:00001108 $t
                io.s:21     .text:00001110 $d
                io.s:22     .text:00001118 numout
                io.s:22     .text:00001118 $t
                io.s:22     .text:00001120 $d
                io.s:23     .text:00001128 numline
                io.s:23     .text:00001128 $t
                io.s:23     .text:00001130 $d
                io.s:24     .text:00001138 $t
                io.s:24     .text:00001140 $d
                io.s:31     .text:00001148 $t
                io.s:41     .text:0000115c $d
                io.s:41     .text:00001160 $t
                io.s:57     .text:00001190 qkey
                io.s:57     .text:0000118c $d
                io.s:57     .text:00001190 $t
                io.s:67     .text:000011b4 $d
                io.s:75     .text:000011c0 $t
                io.s:93     .text:000011f4 $d
                io.s:93     .text:000011f8 $t
             loops.s:310    .text:00001fc8 bounds
             loops.s:213    .text:00001f0c pqdo
                io.s:96     .text:00001208 $d
             loops.s:226    .text:00001f28 i
                io.s:98     .text:0000120a $t
             loops.s:167    .text:00001ea8 ploop
                io.s:102    .text:0000121a $d
                io.s:104    .text:0000121c $t
                io.s:108    .text:00001220 $d
                io.s:108    .text:00001224 $t
            expect.s:9      .text:00001350 eol
                io.s:124    .text:0000125c space
                io.s:124    .text:00001258 $d
                io.s:124    .text:0000125c $t
                io.s:134    .text:00001274 spaces
                io.s:134    .text:00001270 $d
                io.s:134    .text:00001274 $t
             loops.s:299    .text:00001fac dorep
                io.s:142    .text:00001288 $d
                io.s:142    .text:0000128c $t
           compile.s:31     .text:00001ad0 align
                io.s:159    .text:000012c0 pabortq
                io.s:159    .text:000012bc $d
                io.s:159    .text:000012c0 $t
                io.s:165    .text:000012dc $d
                io.s:167    .text:000012de $t
                io.s:183    .text:00001304 pad
                io.s:183    .text:000012fe $d
                io.s:183    .text:00001304 $t
            header.s:6      .text:00002070 here
                io.s:194    .text:00001320 sstring
                io.s:194    .text:0000131c $d
                io.s:195    .text:00001320 $t
            expect.s:4      .text:00001330 expect
            expect.s:4      .text:0000132a $d
            expect.s:4      .text:00001330 $t
            expect.s:4      .text:00001338 $d
            expect.s:110    .text:00001464 pexpect
            expect.s:8      .text:00001340 bs_
            expect.s:8      .text:00001340 $t
            expect.s:8      .text:00001348 $d
            expect.s:9      .text:00001350 $t
            expect.s:9      .text:00001358 $d
            expect.s:21     .text:00001360 pbs
            expect.s:21     .text:00001360 $t
            expect.s:35     .text:00001388 bsin
            expect.s:35     .text:00001384 $d
            expect.s:35     .text:00001388 $t
            expect.s:50     .text:000013b4 crin
            expect.s:50     .text:000013b0 $d
            expect.s:50     .text:000013b4 $t
            expect.s:67     .text:000013e8 qbsin
            expect.s:67     .text:000013e4 $d
            expect.s:67     .text:000013e8 $t
            expect.s:79     .text:00001408 ctrlchr
            expect.s:79     .text:00001404 $d
            expect.s:79     .text:00001408 $t
             loops.s:85     .text:00001e0c qcolon
            expect.s:97     .text:00001440 normchar
            expect.s:97     .text:0000143c $d
            expect.s:97     .text:00001440 $t
            expect.s:110    .text:00001460 $d
            expect.s:110    .text:00001464 $t
            expect.s:118    .text:00001484 $d
            expect.s:120    .text:00001486 $t
            expect.s:129    .text:000014a6 $d
            expect.s:136    .text:000014a8 $t
            expect.s:142    .text:000014b0 $d
            expect.s:142    .text:000014b4 $t
              scan.s:14     .text:000014dc wchar
              scan.s:14     .text:000014d6 $d
              scan.s:14     .text:000014dc $t
              scan.s:14     .text:000014e4 $d
              scan.s:21     .text:000014ec skip
              scan.s:22     .text:000014ec $t
              scan.s:46     .text:0000150c scan
              scan.s:46     .text:00001508 $d
              scan.s:47     .text:0000150c $t
              scan.s:90     .text:0000152c scan_word
              scan.s:90     .text:00001526 $d
              scan.s:91     .text:0000152c $t
            number.s:4      .text:00001558 base
            number.s:4      .text:00001554 $d
            number.s:4      .text:00001558 $t
            number.s:4      .text:00001560 $d
            number.s:11     .text:00001564 digit
            number.s:12     .text:00001564 $t
            number.s:34     .text:00001584 pnumber
             loops.s:193    .text:00001ee0 pdo
            number.s:40     .text:00001598 $d
            number.s:42     .text:0000159a $t
            number.s:49     .text:000015b6 $d
            number.s:50     .text:000015b8 $t
             loops.s:145    .text:00001e7c undo
            number.s:60     .text:000015dc $d
            number.s:62     .text:000015de $t
            number.s:70     .text:000015ea pnum
            number.s:87     .text:00001612 chrnum
            number.s:96     .text:00001632 $d
            number.s:97     .text:0000163c $t
            number.s:109    .text:00001658 binnum
            number.s:121    .text:00001670 octnum
            number.s:133    .text:00001688 hexnum
            number.s:143    .text:000016a0 defnum
            number.s:154    .text:000016b0 qnegative
            number.s:163    .text:000016d0 $d
            number.s:164    .text:000016d2 $t
            number.s:174    .text:000016e4 number
            number.s:174    .text:000016de $d
            number.s:174    .text:000016e4 $t
             loops.s:8      .text:00001d94 docase
            number.s:180    .text:00001700 $d
            number.s:188    .text:0000172c $t
         interpret.s:6      .text:00001730 $d
         interpret.s:6      .text:00001734 $t
         interpret.s:6      .text:0000173c $d
         interpret.s:223    .text:00001a18 pquit
         interpret.s:7      .text:00001744 $t
         interpret.s:7      .text:0000174c $d
         interpret.s:237    .text:00001a48 pabort
         interpret.s:8      .text:00001754 pinterpret
         interpret.s:8      .text:00001754 $t
         interpret.s:8      .text:0000175c $d
         interpret.s:180    .text:00001988 pxinterpret
         interpret.s:9      .text:00001764 dotstatus
         interpret.s:9      .text:00001764 $t
         interpret.s:9      .text:0000176c $d
         interpret.s:10     .text:00001774 dotl
         interpret.s:10     .text:00001774 $t
         interpret.s:10     .text:0000177c $d
         interpret.s:11     .text:00001784 qok
         interpret.s:11     .text:00001784 $t
         interpret.s:11     .text:0000178c $d
         interpret.s:15     .text:00001794 parse
         interpret.s:15     .text:00001794 $t
         interpret.s:37     .text:000017e8 parseword
         interpret.s:37     .text:000017e4 $d
         interpret.s:37     .text:000017e8 $t
         interpret.s:67     .text:00001850 left
         interpret.s:67     .text:0000184c $d
         interpret.s:67     .text:00001850 $t
         interpret.s:76     .text:0000186c qrefill
         interpret.s:76     .text:00001868 $d
         interpret.s:76     .text:0000186c $t
         interpret.s:87     .text:00001888 word_
         interpret.s:87     .text:00001884 $d
         interpret.s:87     .text:00001888 $t
            header.s:7      .text:00002080 hhere
         interpret.s:99     .text:000018a8 defined
         interpret.s:99     .text:000018a4 $d
         interpret.s:99     .text:000018a8 $t
              find.s:81     .text:0000224c find
         interpret.s:110    .text:000018c4 qmissing
         interpret.s:110    .text:000018c0 $d
         interpret.s:110    .text:000018c4 $t
         interpret.s:119    .text:000018ec $d
         interpret.s:127    .text:000018f4 tick
         interpret.s:127    .text:000018f4 $t
         interpret.s:138    .text:00001910 qcompnum
         interpret.s:138    .text:0000190c $d
         interpret.s:138    .text:00001910 $t
           compile.s:6      .text:00001a88 state
           compile.s:243    .text:00001c58 literal
         interpret.s:150    .text:00001930 qnum
         interpret.s:150    .text:0000192c $d
         interpret.s:150    .text:00001930 $t
         interpret.s:167    .text:00001964 qexec
         interpret.s:167    .text:00001960 $d
         interpret.s:167    .text:00001964 $t
           compile.s:99     .text:00001b2c commaxt
         interpret.s:180    .text:00001984 $d
         interpret.s:180    .text:00001988 $t
         interpret.s:190    .text:000019a8 interpret
         interpret.s:190    .text:000019a4 $d
         interpret.s:190    .text:000019a8 $t
         interpret.s:198    .text:000019c8 $d
         interpret.s:199    .text:000019ca $t
         interpret.s:203    .text:000019d4 dotok
         interpret.s:203    .text:000019ce $d
         interpret.s:203    .text:000019d4 $t
             fload.s:8      .text:000022e0 floads
         interpret.s:211    .text:000019f8 $d
         interpret.s:212    .text:000019fa $t
         interpret.s:213    .text:000019fe $d
         interpret.s:215    .text:00001a04 $t
         interpret.s:223    .text:00001a14 $d
         interpret.s:223    .text:00001a18 $t
           compile.s:273    .text:00001cac lbracket
         interpret.s:237    .text:00001a42 $d
         interpret.s:237    .text:00001a48 $t
         interpret.s:242    .text:00001a5c $d
             fload.s:150    .text:00002498 abort_fload
         interpret.s:243    .text:00001a5e $t
         interpret.s:245    .text:00001a66 $d
         interpret.s:247    .text:00001a68 $t
           compile.s:6      .text:00001a84 $d
           compile.s:6      .text:00001a88 $t
           compile.s:6      .text:00001a90 $d
           compile.s:7      .text:00001a98 last
           compile.s:7      .text:00001a98 $t
           compile.s:7      .text:00001aa0 $d
            vocabs.s:122    .data:000015ac last_hdr
           compile.s:8      .text:00001aa8 thread
           compile.s:8      .text:00001aa8 $t
           compile.s:8      .text:00001ab0 $d
           compile.s:17     .text:00001ab8 clrcache
           compile.s:18     .text:00001ab8 $t
           compile.s:31     .text:00001aca $d
           compile.s:32     .text:00001ad0 $t
           compile.s:61     .text:00001adc callstore
           compile.s:61     .text:00001ad8 $d
           compile.s:62     .text:00001adc $t
           compile.s:99     .text:00001b26 $d
           compile.s:99     .text:00001b2c $t
             comma.s:20     .text:00001fec allot
           compile.s:111    .text:00001b48 $d
           compile.s:112    .text:00001b4c $t
             loops.s:55     .text:00001dd8 from_bl
           compile.s:130    .text:00001b70 pcompile
           compile.s:130    .text:00001b6a $d
           compile.s:130    .text:00001b70 $t
           compile.s:143    .text:00001b94 compile
           compile.s:143    .text:00001b90 $d
           compile.s:143    .text:00001b94 $t
           compile.s:153    .text:00001bac bcompile
           compile.s:153    .text:00001ba8 $d
           compile.s:153    .text:00001bac $t
           compile.s:163    .text:00001bc4 btcomma
           compile.s:163    .text:00001bc0 $d
           compile.s:163    .text:00001bc4 $t
             comma.s:66     .text:00002024 comma
           compile.s:177    .text:00001bdc pliteral
           compile.s:177    .text:00001bd8 $d
           compile.s:178    .text:00001bdc $t
           compile.s:204    .text:00001c0c wliteral
           compile.s:217    .text:00001c20 dliteral
           compile.s:231    .text:00001c3a cliteral
             comma.s:55     .text:00002014 wcomma
           compile.s:243    .text:00001c52 $d
           compile.s:243    .text:00001c58 $t
             comma.s:108    .text:0000205c wlitc
           compile.s:251    .text:00001c78 $d
           compile.s:252    .text:00001c7a $t
           compile.s:260    .text:00001c94 $d
           compile.s:261    .text:00001c96 $t
           compile.s:273    .text:00001ca6 $d
           compile.s:274    .text:00001cac $t
           compile.s:283    .text:00001cbc rbracket
           compile.s:283    .text:00001cb6 $d
           compile.s:284    .text:00001cbc $t
           compile.s:292    .text:00001cc2 rpushlr
           compile.s:301    .text:00001cd4 suses
           compile.s:301    .text:00001cd0 $d
           compile.s:301    .text:00001cd4 $t
            header.s:68     .text:000020c8 nameto
           compile.s:315    .text:00001cf8 scode
           compile.s:315    .text:00001cf4 $d
           compile.s:316    .text:00001cf8 $t
           compile.s:324    .text:00001d08 immediate
           compile.s:324    .text:00001d04 $d
           compile.s:324    .text:00001d08 $t
           compile.s:333    .text:00001d24 create
           compile.s:333    .text:00001d20 $d
           compile.s:333    .text:00001d24 $t
            header.s:119    .text:00002174 headcomma
            header.s:128    .text:00002190 reveal
           compile.s:346    .text:00001d4c colon
           compile.s:346    .text:00001d48 $d
           compile.s:346    .text:00001d4c $t
           compile.s:360    .text:00001d74 semi
           compile.s:360    .text:00001d70 $d
           compile.s:360    .text:00001d74 $t
             loops.s:8      .text:00001d90 $d
             loops.s:9      .text:00001d94 $t
             loops.s:55     .text:00001dd2 $d
             loops.s:56     .text:00001dd8 $t
             loops.s:85     .text:00001e08 $d
             loops.s:86     .text:00001e0c $t
             loops.s:117    .text:00001e3c execc
             loops.s:117    .text:00001e36 $d
             loops.s:118    .text:00001e3c $t
             loops.s:128    .text:00001e52 $d
             loops.s:129    .text:00001e58 $t
             loops.s:136    .text:00001e66 $d
             loops.s:137    .text:00001e6c $t
             loops.s:145    .text:00001e78 $d
             loops.s:146    .text:00001e7c $t
             loops.s:151    .text:00001e88 pleave
             loops.s:151    .text:00001e82 $d
             loops.s:152    .text:00001e88 $t
             loops.s:157    .text:00001e94 pqleave
             loops.s:157    .text:00001e90 $d
             loops.s:158    .text:00001e94 $t
             loops.s:167    .text:00001ea4 $d
             loops.s:168    .text:00001ea8 $t
             loops.s:182    .text:00001ec8 pploop
             loops.s:182    .text:00001ec2 $d
             loops.s:183    .text:00001ec8 $t
             loops.s:193    .text:00001eda $d
             loops.s:194    .text:00001ee0 $t
             loops.s:195    .text:00001ee2 _do
             loops.s:213    .text:00001f08 $d
             loops.s:214    .text:00001f0c $t
             loops.s:226    .text:00001f22 $d
             loops.s:227    .text:00001f28 $t
             loops.s:228    .text:00001f2a ijk
             loops.s:238    .text:00001f3c j
             loops.s:238    .text:00001f38 $d
             loops.s:239    .text:00001f3c $t
             loops.s:244    .text:00001f44 k
             loops.s:244    .text:00001f40 $d
             loops.s:245    .text:00001f44 $t
             loops.s:252    .text:00001f4c dofor
             loops.s:252    .text:00001f48 $d
             loops.s:253    .text:00001f4c $t
             loops.s:264    .text:00001f60 pnxt
             loops.s:264    .text:00001f5c $d
             loops.s:265    .text:00001f60 $t
             loops.s:280    .text:00001f7c prep
             loops.s:280    .text:00001f78 $d
             loops.s:280    .text:00001f7c $t
             loops.s:283    .text:00001f8c $d
             loops.s:285    .text:00001f8e $t
             loops.s:289    .text:00001f9e $d
             loops.s:291    .text:00001fa0 $t
             loops.s:299    .text:00001fa8 $d
             loops.s:299    .text:00001fac $t
             loops.s:310    .text:00001fc4 $d
             loops.s:311    .text:00001fc8 $t
             comma.s:7      .text:00001fd8 alignc
             comma.s:7      .text:00001fd2 $d
             comma.s:8      .text:00001fd8 $t
             comma.s:20     .text:00001fe6 $d
             comma.s:21     .text:00001fec $t
             comma.s:35     .text:00001ffc hallot
             comma.s:35     .text:00001ff8 $d
             comma.s:36     .text:00001ffc $t
             comma.s:44     .text:00002004 ccomma
             comma.s:44     .text:00002000 $d
             comma.s:45     .text:00002004 $t
             comma.s:55     .text:0000200e $d
             comma.s:56     .text:00002014 $t
             comma.s:66     .text:0000201e $d
             comma.s:67     .text:00002024 $t
             comma.s:80     .text:00002038 hcomma
             comma.s:80     .text:00002034 $d
             comma.s:81     .text:00002038 $t
             comma.s:96     .text:0000203c $d
             comma.s:97     .text:00002040 $t
             comma.s:108    .text:00002058 $d
             comma.s:109    .text:0000205c $t
            header.s:6      .text:0000206c $d
            header.s:6      .text:00002070 $t
            header.s:6      .text:00002078 $d
            header.s:7      .text:00002080 $t
            header.s:7      .text:00002088 $d
            header.s:8      .text:00002090 old_dp
            header.s:8      .text:00002090 $t
            header.s:8      .text:00002098 $d
            header.s:18     .text:000020a0 lexmask
            header.s:19     .text:000020a0 $t
            header.s:27     .text:000020ac tobody
            header.s:27     .text:000020a6 $d
            header.s:28     .text:000020ac $t
            header.s:36     .text:000020b4 bodyto
            header.s:36     .text:000020b0 $d
            header.s:37     .text:000020b4 $t
            header.s:45     .text:00000c2c ntolink
            header.s:52     .text:00000c24 ltoname
            header.s:59     .text:000020bc toname
            header.s:59     .text:000020b8 $d
            header.s:60     .text:000020bc $t
            header.s:68     .text:000020c2 $d
            header.s:68     .text:000020c8 $t
            header.s:80     .text:000020ec phead
            header.s:80     .text:000020e8 $d
            header.s:80     .text:000020ec $t
            vocabs.s:17     .text:000028cc current
              find.s:9      .text:000021cc hash
            header.s:119    .text:00002170 $d
            header.s:119    .text:00002174 $t
            header.s:128    .text:0000218c $d
            header.s:128    .text:00002190 $t
              find.s:9      .text:000021c6 $d
              find.s:10     .text:000021cc $t
              find.s:29     .text:000021f4 pfind
              find.s:29     .text:000021ee $d
              find.s:30     .text:000021f4 $t
              find.s:81     .text:00002248 $d
              find.s:81     .text:0000224c $t
            vocabs.s:90     .text:00002984 tocontext
              find.s:89     .text:0000226c $d
              find.s:91     .text:0000226e $t
              find.s:102    .text:00002296 $d
              find.s:106    .text:00002298 $t
              find.s:113    .text:000022ac $d
              find.s:116    .text:000022ae $t
             fload.s:6      .text:000022c0 fd
             fload.s:6      .text:000022ba $d
             fload.s:6      .text:000022c0 $t
             fload.s:6      .text:000022c8 $d
             fload.s:7      .text:000022d0 linenum
             fload.s:7      .text:000022d0 $t
             fload.s:7      .text:000022d8 $d
             fload.s:8      .text:000022e0 $t
             fload.s:8      .text:000022e8 $d
             fload.s:9      .text:000022f0 flsize
             fload.s:9      .text:000022f0 $t
             fload.s:9      .text:000022f8 $d
             fload.s:10     .text:00002300 fladdr
             fload.s:10     .text:00002300 $t
             fload.s:10     .text:00002308 $d
             fload.s:11     .text:00002310 fltoin
             fload.s:11     .text:00002310 $t
             fload.s:11     .text:00002318 $d
             fload.s:16     .text:00002320 ktotal
             fload.s:16     .text:00002320 $t
             fload.s:16     .text:00002328 $d
             fload.s:23     .text:00002330 qopen
             fload.s:23     .text:00002330 $t
             fload.s:32     .text:00002358 $d
             fload.s:39     .text:00002368 qfs
             fload.s:39     .text:00002368 $t
             fload.s:49     .text:00002388 fmmap
             fload.s:49     .text:00002384 $d
             fload.s:49     .text:00002388 $t
             fload.s:66     .text:000023c0 pushlist
             fload.s:67     .text:000023c0 $d
             fload.s:81     .text:000023e8 poplist
             fload.s:96     .text:00002410 save_state
             fload.s:97     .text:00002410 $t
             fload.s:114    .text:00002430 restore_state
             fload.s:133    .text:00002458 end_fload
             fload.s:133    .text:00002452 $d
             fload.s:133    .text:00002458 $t
             fload.s:150    .text:00002494 $d
             fload.s:150    .text:00002498 $t
             fload.s:159    .text:000024b8 pflrefill
             fload.s:159    .text:000024b4 $d
             fload.s:159    .text:000024b8 $t
             fload.s:172    .text:000024ee $d
             fload.s:173    .text:00002504 $t
             fload.s:188    .text:00002538 flrefill
             fload.s:188    .text:00002534 $d
             fload.s:188    .text:00002538 $t
             fload.s:195    .text:00002558 $d
             fload.s:196    .text:0000255a $t
             fload.s:207    .text:00002570 fstate
             fload.s:207    .text:0000256a $d
             fload.s:207    .text:00002570 $t
             fload.s:229    .text:000025c4 qfdepth
             fload.s:229    .text:000025be $d
             fload.s:229    .text:000025c4 $t
             fload.s:234    .text:000025dc $d
             fload.s:235    .text:000025f4 $t
             fload.s:239    .text:000025fc pfload
             fload.s:239    .text:000025f8 $d
             fload.s:239    .text:000025fc $t
             fload.s:254    .text:00002634 fload
             fload.s:254    .text:00002630 $d
             fload.s:254    .text:00002634 $t
             reloc.s:35     .text:00002664 rethread
            vocabs.s:16     .text:000028bc voclink
             reloc.s:66     .text:00002686 hreloc
             reloc.s:104    .text:000026d2 relocate
             reloc.s:142    .text:00002720 eunpack
             reloc.s:172    .text:00002764 pack
             reloc.s:172    .text:0000275e $d
             reloc.s:173    .text:00002764 $t
            rehash.s:7      .text:0000279c $d
            rehash.s:7      .text:000027a0 $t
            rehash.s:7      .text:000027a8 $d
            rehash.s:14     .text:000027ac chain
            rehash.s:15     .text:000027ac $t
            rehash.s:35     .text:000027e4 prehash
            rehash.s:55     .text:0000281c $d
            rehash.s:56     .text:0000281e $t
            vocabs.s:23     .text:000028fc numthreads
            rehash.s:83     .text:00002864 $d
            rehash.s:84     .text:00002866 $t
            vocabs.s:7      .text:00002870 context0
            vocabs.s:7      .text:0000286a $d
            vocabs.s:7      .text:00002870 $t
            vocabs.s:7      .text:00002878 $d
            vocabs.s:16     .text:000028bc $t
            vocabs.s:16     .text:000028c4 $d
            vocabs.s:17     .text:000028cc $t
            vocabs.s:17     .text:000028d4 $d
            vocabs.s:18     .text:000028dc context
            vocabs.s:18     .text:000028dc $t
            vocabs.s:18     .text:000028e4 $d
            vocabs.s:19     .text:000028ec numcontext
            vocabs.s:19     .text:000028ec $t
            vocabs.s:19     .text:000028f4 $d
            vocabs.s:23     .text:000028fc $t
            vocabs.s:23     .text:00002904 $d
            vocabs.s:24     .text:0000290c tdovoc
            vocabs.s:24     .text:0000290c $t
            vocabs.s:24     .text:00002914 $d
            vocabs.s:54     .text:00002940 dovoc
            vocabs.s:29     .text:00002918 find_voc
            vocabs.s:30     .text:00002918 $t
            vocabs.s:90     .text:0000297e $d
            vocabs.s:90     .text:00002984 $t
            vocabs.s:99     .text:000029a4 definitions
            vocabs.s:99     .text:000029a0 $d
            vocabs.s:99     .text:000029a4 $t
            vocabs.s:109    .text:000029c4 previous
            vocabs.s:109    .text:000029c0 $d
            vocabs.s:109    .text:000029c4 $t
            vocabs.s:120    .text:000029e4 $d
            vocabs.s:120    .text:000029e8 $t
            vocabs.s:120    .text:000029f0 $d
            vocabs.s:121    .text:00002af8 $t
            vocabs.s:121    .text:00002b00 $d
            vocabs.s:122    .text:00002c08 $t
            vocabs.s:122    .text:00002c10 $d
                   .debug_aranges:0000000c $d
          syscalls.s:65     .text:00000425 $d
          syscalls.s:65     .text:00000426 $t

UNDEFINED SYMBOLS
_headers
